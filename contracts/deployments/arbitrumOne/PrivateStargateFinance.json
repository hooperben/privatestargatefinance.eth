{
  "address": "0xA91C4C647733f9a8D4e195f1353d94B7Edd63A79",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_endpoint",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_depositVerifier",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_transferVerifier",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_withdrawVerifier",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_warpVerifier",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AccessControlBadConfirmation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "neededRole",
          "type": "bytes32"
        }
      ],
      "name": "AccessControlUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidDelegate",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidEndpointCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LzTokenUnavailable",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        }
      ],
      "name": "NoPeer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "msgValue",
          "type": "uint256"
        }
      ],
      "name": "NotEnoughNative",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "OnlyEndpoint",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "sender",
          "type": "bytes32"
        }
      ],
      "name": "OnlyPeer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnableInvalidOwner",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "OwnableUnauthorizedAccount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "SafeERC20FailedOperation",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "leafIndex",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "leafValue",
          "type": "uint256"
        }
      ],
      "name": "LeafInserted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "encryptedNote",
          "type": "bytes"
        }
      ],
      "name": "NotePayload",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "nullifier",
          "type": "uint256"
        }
      ],
      "name": "NullifierUsed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "name": "PeerSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "previousAdminRole",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "newAdminRole",
          "type": "bytes32"
        }
      ],
      "name": "RoleAdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleGranted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "RoleRevoked",
      "type": "event"
    },
    {
      "stateMutability": "payable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "DEFAULT_ADMIN_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "DEPOSIT_ROLE",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "INITIAL_ROOT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_LEAF_INDEX",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_VALUE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROOT_HISTORY_SIZE",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_oft",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_enabled",
          "type": "bool"
        }
      ],
      "name": "addSupportedOFT",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct Origin",
          "name": "origin",
          "type": "tuple"
        }
      ],
      "name": "allowInitializePath",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "availableOFTs",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentRootIndex",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_erc20",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "_amount",
          "type": "uint64"
        },
        {
          "internalType": "bytes",
          "name": "_proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes32[]",
          "name": "_publicInputs",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_payload",
          "type": "bytes[]"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "depositVerifier",
      "outputs": [
        {
          "internalType": "contract DepositVerifier",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "endpoint",
      "outputs": [
        {
          "internalType": "contract ILayerZeroEndpointV2",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "filledSubtrees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        }
      ],
      "name": "getRoleAdmin",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "grantRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "hasRole",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_left",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_right",
          "type": "uint256"
        }
      ],
      "name": "hashLeftRight",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "height",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct Origin",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "_sender",
          "type": "address"
        }
      ],
      "name": "isComposeMsgSender",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_root",
          "type": "uint256"
        }
      ],
      "name": "isKnownRoot",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "srcEid",
              "type": "uint32"
            },
            {
              "internalType": "bytes32",
              "name": "sender",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "nonce",
              "type": "uint64"
            }
          ],
          "internalType": "struct Origin",
          "name": "_origin",
          "type": "tuple"
        },
        {
          "internalType": "bytes32",
          "name": "_guid",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "_executor",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "lzReceive",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "nextIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "nextNonce",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "nonce",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "nullifierUsed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oAppVersion",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "senderVersion",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "receiverVersion",
          "type": "uint64"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "eid",
          "type": "uint32"
        }
      ],
      "name": "peers",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "peer",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_dstEid",
          "type": "uint32"
        },
        {
          "internalType": "uint256[]",
          "name": "notes",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        },
        {
          "internalType": "bool",
          "name": "_payInLzToken",
          "type": "bool"
        }
      ],
      "name": "quote",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "nativeFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lzTokenFee",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "callerConfirmation",
          "type": "address"
        }
      ],
      "name": "renounceRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "role",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "revokeRole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "roots",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_delegate",
          "type": "address"
        }
      ],
      "name": "setDelegate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_eid",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_peer",
          "type": "bytes32"
        }
      ],
      "name": "setPeer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes32[]",
          "name": "_publicInputs",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_payload",
          "type": "bytes[]"
        }
      ],
      "name": "transfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "transferVerifier",
      "outputs": [
        {
          "internalType": "contract TransferVerifier",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_dstEid",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "_proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes32[]",
          "name": "_publicInputs",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes",
          "name": "_options",
          "type": "bytes"
        },
        {
          "internalType": "bytes[]",
          "name": "_payload",
          "type": "bytes[]"
        }
      ],
      "name": "warp",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "warpVerifier",
      "outputs": [
        {
          "internalType": "contract WarpVerifier",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_proof",
          "type": "bytes"
        },
        {
          "internalType": "bytes32[]",
          "name": "_publicInputs",
          "type": "bytes32[]"
        }
      ],
      "name": "withdraw",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawVerifier",
      "outputs": [
        {
          "internalType": "contract WithdrawVerifier",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "i",
          "type": "uint256"
        }
      ],
      "name": "zeros",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "transactionHash": "0x30a2e77ebebe39b456243fe311a948b3c35838a20c9ef5fc327acb10ecdc653c",
  "receipt": {
    "to": null,
    "from": "0xef5f762010De2d72609A6243af59F29A0563c99c",
    "contractAddress": "0xA91C4C647733f9a8D4e195f1353d94B7Edd63A79",
    "transactionIndex": 68,
    "gasUsed": "5779958",
    "logsBloom": "0x00100004000000000000000000000000000000000000002000800000009000000000000000000000000000020000000000000002020000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000000000800000000000010000000000000000000400000000000000000000000000000000000000000000000000000000000400004000000000000000000000000000000000000000000000000001000000000000400000000000000000000000000000000000000000000000100000000000020000000000000000000000000040000000000000000010000000000008000000000",
    "blockHash": "0xde709be7b3bde41b58bbc6ef979f207dbce9d84a4f3d6eaa3c9ed9745d45effa",
    "transactionHash": "0x30a2e77ebebe39b456243fe311a948b3c35838a20c9ef5fc327acb10ecdc653c",
    "logs": [
      {
        "transactionIndex": 68,
        "blockNumber": 349766781,
        "transactionHash": "0x30a2e77ebebe39b456243fe311a948b3c35838a20c9ef5fc327acb10ecdc653c",
        "address": "0xA91C4C647733f9a8D4e195f1353d94B7Edd63A79",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000ef5f762010de2d72609a6243af59f29a0563c99c"
        ],
        "data": "0x",
        "logIndex": 96,
        "blockHash": "0xde709be7b3bde41b58bbc6ef979f207dbce9d84a4f3d6eaa3c9ed9745d45effa"
      },
      {
        "transactionIndex": 68,
        "blockNumber": 349766781,
        "transactionHash": "0x30a2e77ebebe39b456243fe311a948b3c35838a20c9ef5fc327acb10ecdc653c",
        "address": "0x1a44076050125825900e736c501f859c50fE728c",
        "topics": [
          "0x6ee10e9ed4d6ce9742703a498707862f4b00f1396a87195eb93267b3d7983981"
        ],
        "data": "0x000000000000000000000000a91c4c647733f9a8d4e195f1353d94b7edd63a79000000000000000000000000ef5f762010de2d72609a6243af59f29a0563c99c",
        "logIndex": 97,
        "blockHash": "0xde709be7b3bde41b58bbc6ef979f207dbce9d84a4f3d6eaa3c9ed9745d45effa"
      },
      {
        "transactionIndex": 68,
        "blockNumber": 349766781,
        "transactionHash": "0x30a2e77ebebe39b456243fe311a948b3c35838a20c9ef5fc327acb10ecdc653c",
        "address": "0xA91C4C647733f9a8D4e195f1353d94B7Edd63A79",
        "topics": [
          "0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000ef5f762010de2d72609a6243af59f29a0563c99c",
          "0x000000000000000000000000ef5f762010de2d72609a6243af59f29a0563c99c"
        ],
        "data": "0x",
        "logIndex": 98,
        "blockHash": "0xde709be7b3bde41b58bbc6ef979f207dbce9d84a4f3d6eaa3c9ed9745d45effa"
      },
      {
        "transactionIndex": 68,
        "blockNumber": 349766781,
        "transactionHash": "0x30a2e77ebebe39b456243fe311a948b3c35838a20c9ef5fc327acb10ecdc653c",
        "address": "0xA91C4C647733f9a8D4e195f1353d94B7Edd63A79",
        "topics": [
          "0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d",
          "0x2561bf26f818282a3be40719542054d2173eb0d38539e8a8d3cff22f29fd2384",
          "0x000000000000000000000000ef5f762010de2d72609a6243af59f29a0563c99c",
          "0x000000000000000000000000ef5f762010de2d72609a6243af59f29a0563c99c"
        ],
        "data": "0x",
        "logIndex": 99,
        "blockHash": "0xde709be7b3bde41b58bbc6ef979f207dbce9d84a4f3d6eaa3c9ed9745d45effa"
      }
    ],
    "blockNumber": 349766781,
    "cumulativeGasUsed": "13140849",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x1a44076050125825900e736c501f859c50fE728c",
    "0xef5f762010De2d72609A6243af59F29A0563c99c",
    "0x9558A77FF5f42922c49089E691254F8B79511377",
    "0x14F9480d37E20AD99277394aa30446AAE9980852",
    "0x348d05e429E74D178F5C7A2b0E19c4039caa27e7",
    "0x75fDD175d10e0E49dEb938198dBA3De6A7EbCabe"
  ],
  "numDeployments": 1,
  "solcInputHash": "ff2cf19e98bd3f11c8dc979ea849e6a9",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_endpoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_transferVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_withdrawVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_warpVerifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDelegate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEndpointCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LzTokenUnavailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"NoPeer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"msgValue\",\"type\":\"uint256\"}],\"name\":\"NotEnoughNative\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"OnlyEndpoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"}],\"name\":\"OnlyPeer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"leafIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"leafValue\",\"type\":\"uint256\"}],\"name\":\"LeafInserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encryptedNote\",\"type\":\"bytes\"}],\"name\":\"NotePayload\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nullifier\",\"type\":\"uint256\"}],\"name\":\"NullifierUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"name\":\"PeerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INITIAL_ROOT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LEAF_INDEX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_HISTORY_SIZE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oft\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"addSupportedOFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"origin\",\"type\":\"tuple\"}],\"name\":\"allowInitializePath\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"availableOFTs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRootIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_amount\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_publicInputs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_payload\",\"type\":\"bytes[]\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositVerifier\",\"outputs\":[{\"internalType\":\"contract DepositVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpointV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"filledSubtrees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_right\",\"type\":\"uint256\"}],\"name\":\"hashLeftRight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"height\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"isComposeMsgSender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_root\",\"type\":\"uint256\"}],\"name\":\"isKnownRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"srcEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"internalType\":\"struct Origin\",\"name\":\"_origin\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"_guid\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nextNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nullifierUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oAppVersion\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"senderVersion\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"receiverVersion\",\"type\":\"uint64\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"eid\",\"type\":\"uint32\"}],\"name\":\"peers\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"peer\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"uint256[]\",\"name\":\"notes\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_payInLzToken\",\"type\":\"bool\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lzTokenFee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegate\",\"type\":\"address\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_eid\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_peer\",\"type\":\"bytes32\"}],\"name\":\"setPeer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_publicInputs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_payload\",\"type\":\"bytes[]\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferVerifier\",\"outputs\":[{\"internalType\":\"contract TransferVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_dstEid\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_publicInputs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_payload\",\"type\":\"bytes[]\"}],\"name\":\"warp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"warpVerifier\",\"outputs\":[{\"internalType\":\"contract WarpVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_publicInputs\",\"type\":\"bytes32[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawVerifier\",\"outputs\":[{\"internalType\":\"contract WithdrawVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"zeros\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}],\"SafeERC20FailedOperation(address)\":[{\"details\":\"An operation with an ERC-20 token failed.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted to signal this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call. This account bears the admin role (for the granted role). Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"allowInitializePath((uint32,bytes32,uint64))\":{\"details\":\"This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.This defaults to assuming if a peer has been set, its initialized. Can be overridden by the OApp if there is other logic to determine this.\",\"params\":{\"origin\":\"The origin information containing the source endpoint and sender address.\"},\"returns\":{\"_0\":\"Whether the path has been initialized.\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"isComposeMsgSender((uint32,bytes32,uint64),bytes,address)\":{\"details\":\"_origin The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message._message The lzReceive payload.Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.The default sender IS the OAppReceiver implementer.\",\"params\":{\"_sender\":\"The sender address.\"},\"returns\":{\"_0\":\"isSender Is a valid sender.\"}},\"lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)\":{\"details\":\"Entry point for receiving messages or packets from the endpoint.Entry point for receiving msg/packet from the LayerZero endpoint.\",\"params\":{\"_executor\":\"The address of the executor for the received message.\",\"_extraData\":\"Additional arbitrary data provided by the corresponding executor.\",\"_guid\":\"The unique identifier for the received LayerZero message.\",\"_message\":\"The payload of the received message.\",\"_origin\":\"The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message.\"}},\"nextNonce(uint32,bytes32)\":{\"details\":\"_srcEid The source endpoint ID._sender The sender address.The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.Is required by the off-chain executor to determine the OApp expects msg execution is ordered.This is also enforced by the OApp.By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\",\"returns\":{\"nonce\":\"The next nonce.\"}},\"oAppVersion()\":{\"returns\":{\"receiverVersion\":\"The version of the OAppReceiver.sol implementation.\",\"senderVersion\":\"The version of the OAppSender.sol implementation.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"setDelegate(address)\":{\"details\":\"Only the owner/admin of the OApp can call this function.Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\",\"params\":{\"_delegate\":\"The address of the delegate to be set.\"}},\"setPeer(uint32,bytes32)\":{\"details\":\"Only the owner/admin of the OApp can call this function.Indicates that the peer is trusted to send LayerZero messages to this OApp.Set this to bytes32(0) to remove the peer address.Peer is a bytes32 to accommodate non-evm chains.\",\"params\":{\"_eid\":\"The endpoint ID.\",\"_peer\":\"The address of the peer to be associated with the corresponding endpoint.\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"allowInitializePath((uint32,bytes32,uint64))\":{\"notice\":\"Checks if the path initialization is allowed based on the provided origin.\"},\"endpoint()\":{\"notice\":\"Retrieves the LayerZero endpoint associated with the OApp.\"},\"isComposeMsgSender((uint32,bytes32,uint64),bytes,address)\":{\"notice\":\"Indicates whether an address is an approved composeMsg sender to the Endpoint.\"},\"nextNonce(uint32,bytes32)\":{\"notice\":\"Retrieves the next nonce for a given source endpoint and sender address.\"},\"oAppVersion()\":{\"notice\":\"Retrieves the OApp version information.\"},\"peers(uint32)\":{\"notice\":\"Retrieves the peer (OApp) associated with a corresponding endpoint.\"},\"setDelegate(address)\":{\"notice\":\"Sets the delegate address for the OApp.\"},\"setPeer(uint32,bytes32)\":{\"notice\":\"Sets the peer address (OApp instance) for a corresponding endpoint.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/PrivateStargateFinance.sol\":\"PrivateStargateFinance\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IOAppCore, ILayerZeroEndpointV2 } from \\\"./interfaces/IOAppCore.sol\\\";\\n\\n/**\\n * @title OAppCore\\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\\n */\\nabstract contract OAppCore is IOAppCore, Ownable {\\n    // The LayerZero endpoint associated with the given OApp\\n    ILayerZeroEndpointV2 public immutable endpoint;\\n\\n    // Mapping to store peers associated with corresponding endpoints\\n    mapping(uint32 eid => bytes32 peer) public peers;\\n\\n    /**\\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\\n     *\\n     * @dev The delegate typically should be set as the owner of the contract.\\n     */\\n    constructor(address _endpoint, address _delegate) {\\n        endpoint = ILayerZeroEndpointV2(_endpoint);\\n\\n        if (_delegate == address(0)) revert InvalidDelegate();\\n        endpoint.setDelegate(_delegate);\\n    }\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     *\\n     * @dev Only the owner/admin of the OApp can call this function.\\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\\n     * @dev Set this to bytes32(0) to remove the peer address.\\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\\n     */\\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\\n        _setPeer(_eid, _peer);\\n    }\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     *\\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\\n     * @dev Set this to bytes32(0) to remove the peer address.\\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\\n     */\\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\\n        peers[_eid] = _peer;\\n        emit PeerSet(_eid, _peer);\\n    }\\n\\n    /**\\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\\n     * ie. the peer is set to bytes32(0).\\n     * @param _eid The endpoint ID.\\n     * @return peer The address of the peer associated with the specified endpoint.\\n     */\\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\\n        bytes32 peer = peers[_eid];\\n        if (peer == bytes32(0)) revert NoPeer(_eid);\\n        return peer;\\n    }\\n\\n    /**\\n     * @notice Sets the delegate address for the OApp.\\n     * @param _delegate The address of the delegate to be set.\\n     *\\n     * @dev Only the owner/admin of the OApp can call this function.\\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\\n     */\\n    function setDelegate(address _delegate) public onlyOwner {\\n        endpoint.setDelegate(_delegate);\\n    }\\n}\\n\",\"keccak256\":\"0x13a9c2d1d2c1f086b8624f2e84c4a4702212daae36f701d92bb915b535cbe4cc\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { SafeERC20, IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport { OAppCore } from \\\"./OAppCore.sol\\\";\\n\\n/**\\n * @title OAppSender\\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\\n */\\nabstract contract OAppSender is OAppCore {\\n    using SafeERC20 for IERC20;\\n\\n    // Custom error messages\\n    error NotEnoughNative(uint256 msgValue);\\n    error LzTokenUnavailable();\\n\\n    // @dev The version of the OAppSender implementation.\\n    // @dev Version is bumped when changes are made to this contract.\\n    uint64 internal constant SENDER_VERSION = 1;\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     *\\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\\n     * ie. this is a SEND only OApp.\\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\\n     */\\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\\n        return (SENDER_VERSION, 0);\\n    }\\n\\n    /**\\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\\n     * @param _dstEid The destination endpoint ID.\\n     * @param _message The message payload.\\n     * @param _options Additional options for the message.\\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\\n     * @return fee The calculated MessagingFee for the message.\\n     *      - nativeFee: The native fee for the message.\\n     *      - lzTokenFee: The LZ token fee for the message.\\n     */\\n    function _quote(\\n        uint32 _dstEid,\\n        bytes memory _message,\\n        bytes memory _options,\\n        bool _payInLzToken\\n    ) internal view virtual returns (MessagingFee memory fee) {\\n        return\\n            endpoint.quote(\\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\\n                address(this)\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\\n     * @param _dstEid The destination endpoint ID.\\n     * @param _message The message payload.\\n     * @param _options Additional options for the message.\\n     * @param _fee The calculated LayerZero fee for the message.\\n     *      - nativeFee: The native fee.\\n     *      - lzTokenFee: The lzToken fee.\\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\\n     * @return receipt The receipt for the sent message.\\n     *      - guid: The unique identifier for the sent message.\\n     *      - nonce: The nonce of the sent message.\\n     *      - fee: The LayerZero fee incurred for the message.\\n     */\\n    function _lzSend(\\n        uint32 _dstEid,\\n        bytes memory _message,\\n        bytes memory _options,\\n        MessagingFee memory _fee,\\n        address _refundAddress\\n    ) internal virtual returns (MessagingReceipt memory receipt) {\\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\\n        uint256 messageValue = _payNative(_fee.nativeFee);\\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\\n\\n        return\\n            // solhint-disable-next-line check-send-result\\n            endpoint.send{ value: messageValue }(\\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\\n                _refundAddress\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the native fee associated with the message.\\n     * @param _nativeFee The native fee to be paid.\\n     * @return nativeFee The amount of native currency paid.\\n     *\\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\\n     * this will need to be overridden because msg.value would contain multiple lzFees.\\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\\n     */\\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\\n        return _nativeFee;\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the LZ token fee associated with the message.\\n     * @param _lzTokenFee The LZ token fee to be paid.\\n     *\\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\\n     */\\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\\n        address lzToken = endpoint.lzToken();\\n        if (lzToken == address(0)) revert LzTokenUnavailable();\\n\\n        // Pay LZ token fee by sending tokens to the endpoint.\\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\\n    }\\n}\\n\",\"keccak256\":\"0x518cf4adca601923ed4baa6619846a253ea32b8d8775f8bc1faa3dfac7f67c20\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { ILayerZeroEndpointV2 } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\n\\n/**\\n * @title IOAppCore\\n */\\ninterface IOAppCore {\\n    // Custom error messages\\n    error OnlyPeer(uint32 eid, bytes32 sender);\\n    error NoPeer(uint32 eid);\\n    error InvalidEndpointCall();\\n    error InvalidDelegate();\\n\\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\\n    event PeerSet(uint32 eid, bytes32 peer);\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     */\\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\\n\\n    /**\\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\\n     * @return iEndpoint The LayerZero endpoint as an interface.\\n     */\\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\\n\\n    /**\\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\\n     */\\n    function peers(uint32 _eid) external view returns (bytes32 peer);\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     */\\n    function setPeer(uint32 _eid, bytes32 _peer) external;\\n\\n    /**\\n     * @notice Sets the delegate address for the OApp Core.\\n     * @param _delegate The address of the delegate to be set.\\n     */\\n    function setDelegate(address _delegate) external;\\n}\\n\",\"keccak256\":\"0x40e49f2de74506e1da5dcaed53a39853f691647f4ceb0fccc8f49a68d3f47c58\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { MessagingReceipt, MessagingFee } from \\\"../../oapp/OAppSender.sol\\\";\\n\\n/**\\n * @dev Struct representing token parameters for the OFT send() operation.\\n */\\nstruct SendParam {\\n    uint32 dstEid; // Destination endpoint ID.\\n    bytes32 to; // Recipient address.\\n    uint256 amountLD; // Amount to send in local decimals.\\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\\n    bytes composeMsg; // The composed message for the send() operation.\\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\\n}\\n\\n/**\\n * @dev Struct representing OFT limit information.\\n * @dev These amounts can change dynamically and are up the the specific oft implementation.\\n */\\nstruct OFTLimit {\\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\\n}\\n\\n/**\\n * @dev Struct representing OFT receipt information.\\n */\\nstruct OFTReceipt {\\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\\n}\\n\\n/**\\n * @dev Struct representing OFT fee details.\\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\\n */\\nstruct OFTFeeDetail {\\n    int256 feeAmountLD; // Amount of the fee in local decimals.\\n    string description; // Description of the fee.\\n}\\n\\n/**\\n * @title IOFT\\n * @dev Interface for the OftChain (OFT) token.\\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\\n * @dev This specific interface ID is '0x02e49c2c'.\\n */\\ninterface IOFT {\\n    // Custom error messages\\n    error InvalidLocalDecimals();\\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\\n\\n    // Events\\n    event OFTSent(\\n        bytes32 indexed guid, // GUID of the OFT message.\\n        uint32 dstEid, // Destination Endpoint ID.\\n        address indexed fromAddress, // Address of the sender on the src chain.\\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\\n    );\\n    event OFTReceived(\\n        bytes32 indexed guid, // GUID of the OFT message.\\n        uint32 srcEid, // Source Endpoint ID.\\n        address indexed toAddress, // Address of the recipient on the dst chain.\\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\\n    );\\n\\n    /**\\n     * @notice Retrieves interfaceID and the version of the OFT.\\n     * @return interfaceId The interface ID.\\n     * @return version The version.\\n     *\\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\\n     */\\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\\n\\n    /**\\n     * @notice Retrieves the address of the token associated with the OFT.\\n     * @return token The address of the ERC20 token implementation.\\n     */\\n    function token() external view returns (address);\\n\\n    /**\\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\\n     * @return requiresApproval Needs approval of the underlying token implementation.\\n     *\\n     * @dev Allows things like wallet implementers to determine integration requirements,\\n     * without understanding the underlying token implementation.\\n     */\\n    function approvalRequired() external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the shared decimals of the OFT.\\n     * @return sharedDecimals The shared decimals of the OFT.\\n     */\\n    function sharedDecimals() external view returns (uint8);\\n\\n    /**\\n     * @notice Provides a quote for OFT-related operations.\\n     * @param _sendParam The parameters for the send operation.\\n     * @return limit The OFT limit information.\\n     * @return oftFeeDetails The details of OFT fees.\\n     * @return receipt The OFT receipt information.\\n     */\\n    function quoteOFT(\\n        SendParam calldata _sendParam\\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\\n\\n    /**\\n     * @notice Provides a quote for the send() operation.\\n     * @param _sendParam The parameters for the send() operation.\\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\\n     *\\n     * @dev MessagingFee: LayerZero msg fee\\n     *  - nativeFee: The native fee.\\n     *  - lzTokenFee: The lzToken fee.\\n     */\\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\\n\\n    /**\\n     * @notice Executes the send() operation.\\n     * @param _sendParam The parameters for the send operation.\\n     * @param _fee The fee information supplied by the caller.\\n     *      - nativeFee: The native fee.\\n     *      - lzTokenFee: The lzToken fee.\\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\\n     * @return receipt The LayerZero messaging receipt from the send() operation.\\n     * @return oftReceipt The OFT receipt information.\\n     *\\n     * @dev MessagingReceipt: LayerZero msg receipt\\n     *  - guid: The unique identifier for the sent message.\\n     *  - nonce: The nonce of the sent message.\\n     *  - fee: The LayerZero fee incurred for the message.\\n     */\\n    function send(\\n        SendParam calldata _sendParam,\\n        MessagingFee calldata _fee,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\\n}\\n\",\"keccak256\":\"0x42431bdbe135f7cfefd0be6cd345a6a1045124f6ea707a06756ef2322140eef5\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { IMessageLibManager } from \\\"./IMessageLibManager.sol\\\";\\nimport { IMessagingComposer } from \\\"./IMessagingComposer.sol\\\";\\nimport { IMessagingChannel } from \\\"./IMessagingChannel.sol\\\";\\nimport { IMessagingContext } from \\\"./IMessagingContext.sol\\\";\\n\\nstruct MessagingParams {\\n    uint32 dstEid;\\n    bytes32 receiver;\\n    bytes message;\\n    bytes options;\\n    bool payInLzToken;\\n}\\n\\nstruct MessagingReceipt {\\n    bytes32 guid;\\n    uint64 nonce;\\n    MessagingFee fee;\\n}\\n\\nstruct MessagingFee {\\n    uint256 nativeFee;\\n    uint256 lzTokenFee;\\n}\\n\\nstruct Origin {\\n    uint32 srcEid;\\n    bytes32 sender;\\n    uint64 nonce;\\n}\\n\\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\\n\\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\\n\\n    event PacketDelivered(Origin origin, address receiver);\\n\\n    event LzReceiveAlert(\\n        address indexed receiver,\\n        address indexed executor,\\n        Origin origin,\\n        bytes32 guid,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    event LzTokenSet(address token);\\n\\n    event DelegateSet(address sender, address delegate);\\n\\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\\n\\n    function send(\\n        MessagingParams calldata _params,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory);\\n\\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\\n\\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\\n\\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        address _receiver,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n\\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\\n\\n    function setLzToken(address _lzToken) external;\\n\\n    function lzToken() external view returns (address);\\n\\n    function nativeToken() external view returns (address);\\n\\n    function setDelegate(address _delegate) external;\\n}\\n\",\"keccak256\":\"0xf7f941bee89ea6369950fe54e8ac476ae6478b958b20fc0e8a83e8ff1364eac3\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nimport { Origin } from \\\"./ILayerZeroEndpointV2.sol\\\";\\n\\ninterface ILayerZeroReceiver {\\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\\n\\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\\n\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x9641abba8d53b08bb517d1b74801dd15ea7b84d77a6719085bd96c8ea94e3ca0\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\nstruct SetConfigParam {\\n    uint32 eid;\\n    uint32 configType;\\n    bytes config;\\n}\\n\\ninterface IMessageLibManager {\\n    struct Timeout {\\n        address lib;\\n        uint256 expiry;\\n    }\\n\\n    event LibraryRegistered(address newLib);\\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\\n\\n    function registerLibrary(address _lib) external;\\n\\n    function isRegisteredLibrary(address _lib) external view returns (bool);\\n\\n    function getRegisteredLibraries() external view returns (address[] memory);\\n\\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\\n\\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\\n\\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\\n\\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\\n\\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function isSupportedEid(uint32 _eid) external view returns (bool);\\n\\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\\n\\n    /// ------------------- OApp interfaces -------------------\\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\\n\\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\\n\\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\\n\\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\\n\\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\\n\\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\\n\\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\\n\\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\\n\\n    function getConfig(\\n        address _oapp,\\n        address _lib,\\n        uint32 _eid,\\n        uint32 _configType\\n    ) external view returns (bytes memory config);\\n}\\n\",\"keccak256\":\"0x919b37133adff4dc528e3061deb2789c3149971b530c61e556fb3d09ab315dfc\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingChannel {\\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\\n\\n    function eid() external view returns (uint32);\\n\\n    // this is an emergency function if a message cannot be verified for some reasons\\n    // required to provide _nextNonce to avoid race condition\\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\\n\\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\\n\\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\\n\\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n\\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\\n\\n    function inboundPayloadHash(\\n        address _receiver,\\n        uint32 _srcEid,\\n        bytes32 _sender,\\n        uint64 _nonce\\n    ) external view returns (bytes32);\\n\\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\\n}\\n\",\"keccak256\":\"0x0878f64dffebf58c4165569416372f40860fab546b88cd926eba0d5cb6d8d972\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingComposer {\\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\\n    event LzComposeAlert(\\n        address indexed from,\\n        address indexed to,\\n        address indexed executor,\\n        bytes32 guid,\\n        uint16 index,\\n        uint256 gas,\\n        uint256 value,\\n        bytes message,\\n        bytes extraData,\\n        bytes reason\\n    );\\n\\n    function composeQueue(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index\\n    ) external view returns (bytes32 messageHash);\\n\\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\\n\\n    function lzCompose(\\n        address _from,\\n        address _to,\\n        bytes32 _guid,\\n        uint16 _index,\\n        bytes calldata _message,\\n        bytes calldata _extraData\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x85bc7090134529ec474866dc4bb1c48692d518c756eb0a961c82574829c51901\",\"license\":\"MIT\"},\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessagingContext {\\n    function isSendingMessage() external view returns (bool);\\n\\n    function getSendContext() external view returns (uint32 dstEid, address sender);\\n}\\n\",\"keccak256\":\"0xff0c546c2813dae3e440882f46b377375f7461b0714efd80bd3f0c6e5cb8da4e\",\"license\":\"MIT\"},\"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\\n// solhint-disable-next-line no-unused-import\\nimport { OAppSender, MessagingFee, MessagingReceipt } from \\\"./OAppSender.sol\\\";\\n// @dev Import the 'Origin' so it's exposed to OApp implementers\\n// solhint-disable-next-line no-unused-import\\nimport { OAppReceiver, Origin } from \\\"./OAppReceiver.sol\\\";\\nimport { OAppCore } from \\\"./OAppCore.sol\\\";\\n\\n/**\\n * @title OApp\\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\\n */\\nabstract contract OApp is OAppSender, OAppReceiver {\\n    /**\\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\\n     */\\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol implementation.\\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\\n     */\\n    function oAppVersion()\\n        public\\n        pure\\n        virtual\\n        override(OAppSender, OAppReceiver)\\n        returns (uint64 senderVersion, uint64 receiverVersion)\\n    {\\n        return (SENDER_VERSION, RECEIVER_VERSION);\\n    }\\n}\\n\",\"keccak256\":\"0xac362c4c291fad2f1511a968424b2e78a5ad502d1c867bd31da04be742aca8c5\",\"license\":\"MIT\"},\"@layerzerolabs/oapp-evm/contracts/oapp/OAppCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport { IOAppCore, ILayerZeroEndpointV2 } from \\\"./interfaces/IOAppCore.sol\\\";\\n\\n/**\\n * @title OAppCore\\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\\n */\\nabstract contract OAppCore is IOAppCore, Ownable {\\n    // The LayerZero endpoint associated with the given OApp\\n    ILayerZeroEndpointV2 public immutable endpoint;\\n\\n    // Mapping to store peers associated with corresponding endpoints\\n    mapping(uint32 eid => bytes32 peer) public peers;\\n\\n    /**\\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\\n     *\\n     * @dev The delegate typically should be set as the owner of the contract.\\n     */\\n    constructor(address _endpoint, address _delegate) {\\n        endpoint = ILayerZeroEndpointV2(_endpoint);\\n\\n        if (_delegate == address(0)) revert InvalidDelegate();\\n        endpoint.setDelegate(_delegate);\\n    }\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     *\\n     * @dev Only the owner/admin of the OApp can call this function.\\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\\n     * @dev Set this to bytes32(0) to remove the peer address.\\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\\n     */\\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\\n        _setPeer(_eid, _peer);\\n    }\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     *\\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\\n     * @dev Set this to bytes32(0) to remove the peer address.\\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\\n     */\\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\\n        peers[_eid] = _peer;\\n        emit PeerSet(_eid, _peer);\\n    }\\n\\n    /**\\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\\n     * ie. the peer is set to bytes32(0).\\n     * @param _eid The endpoint ID.\\n     * @return peer The address of the peer associated with the specified endpoint.\\n     */\\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\\n        bytes32 peer = peers[_eid];\\n        if (peer == bytes32(0)) revert NoPeer(_eid);\\n        return peer;\\n    }\\n\\n    /**\\n     * @notice Sets the delegate address for the OApp.\\n     * @param _delegate The address of the delegate to be set.\\n     *\\n     * @dev Only the owner/admin of the OApp can call this function.\\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\\n     */\\n    function setDelegate(address _delegate) public onlyOwner {\\n        endpoint.setDelegate(_delegate);\\n    }\\n}\\n\",\"keccak256\":\"0x13a9c2d1d2c1f086b8624f2e84c4a4702212daae36f701d92bb915b535cbe4cc\",\"license\":\"MIT\"},\"@layerzerolabs/oapp-evm/contracts/oapp/OAppReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { IOAppReceiver, Origin } from \\\"./interfaces/IOAppReceiver.sol\\\";\\nimport { OAppCore } from \\\"./OAppCore.sol\\\";\\n\\n/**\\n * @title OAppReceiver\\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\\n */\\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\\n    // Custom error message for when the caller is not the registered endpoint/\\n    error OnlyEndpoint(address addr);\\n\\n    // @dev The version of the OAppReceiver implementation.\\n    // @dev Version is bumped when changes are made to this contract.\\n    uint64 internal constant RECEIVER_VERSION = 2;\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     *\\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\\n     * ie. this is a RECEIVE only OApp.\\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\\n     */\\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\\n        return (0, RECEIVER_VERSION);\\n    }\\n\\n    /**\\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\\n     * @dev _origin The origin information containing the source endpoint and sender address.\\n     *  - srcEid: The source chain endpoint ID.\\n     *  - sender: The sender address on the src chain.\\n     *  - nonce: The nonce of the message.\\n     * @dev _message The lzReceive payload.\\n     * @param _sender The sender address.\\n     * @return isSender Is a valid sender.\\n     *\\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\\n     * @dev The default sender IS the OAppReceiver implementer.\\n     */\\n    function isComposeMsgSender(\\n        Origin calldata /*_origin*/,\\n        bytes calldata /*_message*/,\\n        address _sender\\n    ) public view virtual returns (bool) {\\n        return _sender == address(this);\\n    }\\n\\n    /**\\n     * @notice Checks if the path initialization is allowed based on the provided origin.\\n     * @param origin The origin information containing the source endpoint and sender address.\\n     * @return Whether the path has been initialized.\\n     *\\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\\n     * @dev This defaults to assuming if a peer has been set, its initialized.\\n     * Can be overridden by the OApp if there is other logic to determine this.\\n     */\\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\\n        return peers[origin.srcEid] == origin.sender;\\n    }\\n\\n    /**\\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\\n     * @dev _srcEid The source endpoint ID.\\n     * @dev _sender The sender address.\\n     * @return nonce The next nonce.\\n     *\\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\\n     * @dev This is also enforced by the OApp.\\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\\n     */\\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Entry point for receiving messages or packets from the endpoint.\\n     * @param _origin The origin information containing the source endpoint and sender address.\\n     *  - srcEid: The source chain endpoint ID.\\n     *  - sender: The sender address on the src chain.\\n     *  - nonce: The nonce of the message.\\n     * @param _guid The unique identifier for the received LayerZero message.\\n     * @param _message The payload of the received message.\\n     * @param _executor The address of the executor for the received message.\\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\\n     *\\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\\n     */\\n    function lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) public payable virtual {\\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\\n\\n        // Ensure that the sender matches the expected peer for the source endpoint.\\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\\n\\n        // Call the internal OApp implementation of lzReceive.\\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\\n    }\\n\\n    /**\\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\\n     */\\n    function _lzReceive(\\n        Origin calldata _origin,\\n        bytes32 _guid,\\n        bytes calldata _message,\\n        address _executor,\\n        bytes calldata _extraData\\n    ) internal virtual;\\n}\\n\",\"keccak256\":\"0x0174e9f1ec4cefe4b5adc26c392269c699b9ff75965364e5b7264426a462c70b\",\"license\":\"MIT\"},\"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { SafeERC20, IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\nimport { OAppCore } from \\\"./OAppCore.sol\\\";\\n\\n/**\\n * @title OAppSender\\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\\n */\\nabstract contract OAppSender is OAppCore {\\n    using SafeERC20 for IERC20;\\n\\n    // Custom error messages\\n    error NotEnoughNative(uint256 msgValue);\\n    error LzTokenUnavailable();\\n\\n    // @dev The version of the OAppSender implementation.\\n    // @dev Version is bumped when changes are made to this contract.\\n    uint64 internal constant SENDER_VERSION = 1;\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     *\\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\\n     * ie. this is a SEND only OApp.\\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\\n     */\\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\\n        return (SENDER_VERSION, 0);\\n    }\\n\\n    /**\\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\\n     * @param _dstEid The destination endpoint ID.\\n     * @param _message The message payload.\\n     * @param _options Additional options for the message.\\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\\n     * @return fee The calculated MessagingFee for the message.\\n     *      - nativeFee: The native fee for the message.\\n     *      - lzTokenFee: The LZ token fee for the message.\\n     */\\n    function _quote(\\n        uint32 _dstEid,\\n        bytes memory _message,\\n        bytes memory _options,\\n        bool _payInLzToken\\n    ) internal view virtual returns (MessagingFee memory fee) {\\n        return\\n            endpoint.quote(\\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\\n                address(this)\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\\n     * @param _dstEid The destination endpoint ID.\\n     * @param _message The message payload.\\n     * @param _options Additional options for the message.\\n     * @param _fee The calculated LayerZero fee for the message.\\n     *      - nativeFee: The native fee.\\n     *      - lzTokenFee: The lzToken fee.\\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\\n     * @return receipt The receipt for the sent message.\\n     *      - guid: The unique identifier for the sent message.\\n     *      - nonce: The nonce of the sent message.\\n     *      - fee: The LayerZero fee incurred for the message.\\n     */\\n    function _lzSend(\\n        uint32 _dstEid,\\n        bytes memory _message,\\n        bytes memory _options,\\n        MessagingFee memory _fee,\\n        address _refundAddress\\n    ) internal virtual returns (MessagingReceipt memory receipt) {\\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\\n        uint256 messageValue = _payNative(_fee.nativeFee);\\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\\n\\n        return\\n            // solhint-disable-next-line check-send-result\\n            endpoint.send{ value: messageValue }(\\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\\n                _refundAddress\\n            );\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the native fee associated with the message.\\n     * @param _nativeFee The native fee to be paid.\\n     * @return nativeFee The amount of native currency paid.\\n     *\\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\\n     * this will need to be overridden because msg.value would contain multiple lzFees.\\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\\n     */\\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\\n        return _nativeFee;\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the LZ token fee associated with the message.\\n     * @param _lzTokenFee The LZ token fee to be paid.\\n     *\\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\\n     */\\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\\n        address lzToken = endpoint.lzToken();\\n        if (lzToken == address(0)) revert LzTokenUnavailable();\\n\\n        // Pay LZ token fee by sending tokens to the endpoint.\\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\\n    }\\n}\\n\",\"keccak256\":\"0x518cf4adca601923ed4baa6619846a253ea32b8d8775f8bc1faa3dfac7f67c20\",\"license\":\"MIT\"},\"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { ILayerZeroEndpointV2 } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\\\";\\n\\n/**\\n * @title IOAppCore\\n */\\ninterface IOAppCore {\\n    // Custom error messages\\n    error OnlyPeer(uint32 eid, bytes32 sender);\\n    error NoPeer(uint32 eid);\\n    error InvalidEndpointCall();\\n    error InvalidDelegate();\\n\\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\\n    event PeerSet(uint32 eid, bytes32 peer);\\n\\n    /**\\n     * @notice Retrieves the OApp version information.\\n     * @return senderVersion The version of the OAppSender.sol contract.\\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\\n     */\\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\\n\\n    /**\\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\\n     * @return iEndpoint The LayerZero endpoint as an interface.\\n     */\\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\\n\\n    /**\\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\\n     */\\n    function peers(uint32 _eid) external view returns (bytes32 peer);\\n\\n    /**\\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\\n     * @param _eid The endpoint ID.\\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\\n     */\\n    function setPeer(uint32 _eid, bytes32 _peer) external;\\n\\n    /**\\n     * @notice Sets the delegate address for the OApp Core.\\n     * @param _delegate The address of the delegate to be set.\\n     */\\n    function setDelegate(address _delegate) external;\\n}\\n\",\"keccak256\":\"0x40e49f2de74506e1da5dcaed53a39853f691647f4ceb0fccc8f49a68d3f47c58\",\"license\":\"MIT\"},\"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { ILayerZeroReceiver, Origin } from \\\"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\\\";\\n\\ninterface IOAppReceiver is ILayerZeroReceiver {\\n    /**\\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\\n     * @param _origin The origin information containing the source endpoint and sender address.\\n     *  - srcEid: The source chain endpoint ID.\\n     *  - sender: The sender address on the src chain.\\n     *  - nonce: The nonce of the message.\\n     * @param _message The lzReceive payload.\\n     * @param _sender The sender address.\\n     * @return isSender Is a valid sender.\\n     *\\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\\n     * @dev The default sender IS the OAppReceiver implementer.\\n     */\\n    function isComposeMsgSender(\\n        Origin calldata _origin,\\n        bytes calldata _message,\\n        address _sender\\n    ) external view returns (bool isSender);\\n}\\n\",\"keccak256\":\"0xd26135185e19b3732746d4a9e2923e896f28dec8664bab161faea2ee26fcdc3d\",\"license\":\"MIT\"},\"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport { MessagingReceipt, MessagingFee } from \\\"@layerzerolabs/oapp-evm/contracts/oapp/OAppSender.sol\\\";\\n\\n/**\\n * @dev Struct representing token parameters for the OFT send() operation.\\n */\\nstruct SendParam {\\n    uint32 dstEid; // Destination endpoint ID.\\n    bytes32 to; // Recipient address.\\n    uint256 amountLD; // Amount to send in local decimals.\\n    uint256 minAmountLD; // Minimum amount to send in local decimals.\\n    bytes extraOptions; // Additional options supplied by the caller to be used in the LayerZero message.\\n    bytes composeMsg; // The composed message for the send() operation.\\n    bytes oftCmd; // The OFT command to be executed, unused in default OFT implementations.\\n}\\n\\n/**\\n * @dev Struct representing OFT limit information.\\n * @dev These amounts can change dynamically and are up the specific oft implementation.\\n */\\nstruct OFTLimit {\\n    uint256 minAmountLD; // Minimum amount in local decimals that can be sent to the recipient.\\n    uint256 maxAmountLD; // Maximum amount in local decimals that can be sent to the recipient.\\n}\\n\\n/**\\n * @dev Struct representing OFT receipt information.\\n */\\nstruct OFTReceipt {\\n    uint256 amountSentLD; // Amount of tokens ACTUALLY debited from the sender in local decimals.\\n    // @dev In non-default implementations, the amountReceivedLD COULD differ from this value.\\n    uint256 amountReceivedLD; // Amount of tokens to be received on the remote side.\\n}\\n\\n/**\\n * @dev Struct representing OFT fee details.\\n * @dev Future proof mechanism to provide a standardized way to communicate fees to things like a UI.\\n */\\nstruct OFTFeeDetail {\\n    int256 feeAmountLD; // Amount of the fee in local decimals.\\n    string description; // Description of the fee.\\n}\\n\\n/**\\n * @title IOFT\\n * @dev Interface for the OftChain (OFT) token.\\n * @dev Does not inherit ERC20 to accommodate usage by OFTAdapter as well.\\n * @dev This specific interface ID is '0x02e49c2c'.\\n */\\ninterface IOFT {\\n    // Custom error messages\\n    error InvalidLocalDecimals();\\n    error SlippageExceeded(uint256 amountLD, uint256 minAmountLD);\\n\\n    // Events\\n    event OFTSent(\\n        bytes32 indexed guid, // GUID of the OFT message.\\n        uint32 dstEid, // Destination Endpoint ID.\\n        address indexed fromAddress, // Address of the sender on the src chain.\\n        uint256 amountSentLD, // Amount of tokens sent in local decimals.\\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\\n    );\\n    event OFTReceived(\\n        bytes32 indexed guid, // GUID of the OFT message.\\n        uint32 srcEid, // Source Endpoint ID.\\n        address indexed toAddress, // Address of the recipient on the dst chain.\\n        uint256 amountReceivedLD // Amount of tokens received in local decimals.\\n    );\\n\\n    /**\\n     * @notice Retrieves interfaceID and the version of the OFT.\\n     * @return interfaceId The interface ID.\\n     * @return version The version.\\n     *\\n     * @dev interfaceId: This specific interface ID is '0x02e49c2c'.\\n     * @dev version: Indicates a cross-chain compatible msg encoding with other OFTs.\\n     * @dev If a new feature is added to the OFT cross-chain msg encoding, the version will be incremented.\\n     * ie. localOFT version(x,1) CAN send messages to remoteOFT version(x,1)\\n     */\\n    function oftVersion() external view returns (bytes4 interfaceId, uint64 version);\\n\\n    /**\\n     * @notice Retrieves the address of the token associated with the OFT.\\n     * @return token The address of the ERC20 token implementation.\\n     */\\n    function token() external view returns (address);\\n\\n    /**\\n     * @notice Indicates whether the OFT contract requires approval of the 'token()' to send.\\n     * @return requiresApproval Needs approval of the underlying token implementation.\\n     *\\n     * @dev Allows things like wallet implementers to determine integration requirements,\\n     * without understanding the underlying token implementation.\\n     */\\n    function approvalRequired() external view returns (bool);\\n\\n    /**\\n     * @notice Retrieves the shared decimals of the OFT.\\n     * @return sharedDecimals The shared decimals of the OFT.\\n     */\\n    function sharedDecimals() external view returns (uint8);\\n\\n    /**\\n     * @notice Provides a quote for OFT-related operations.\\n     * @param _sendParam The parameters for the send operation.\\n     * @return limit The OFT limit information.\\n     * @return oftFeeDetails The details of OFT fees.\\n     * @return receipt The OFT receipt information.\\n     */\\n    function quoteOFT(\\n        SendParam calldata _sendParam\\n    ) external view returns (OFTLimit memory, OFTFeeDetail[] memory oftFeeDetails, OFTReceipt memory);\\n\\n    /**\\n     * @notice Provides a quote for the send() operation.\\n     * @param _sendParam The parameters for the send() operation.\\n     * @param _payInLzToken Flag indicating whether the caller is paying in the LZ token.\\n     * @return fee The calculated LayerZero messaging fee from the send() operation.\\n     *\\n     * @dev MessagingFee: LayerZero msg fee\\n     *  - nativeFee: The native fee.\\n     *  - lzTokenFee: The lzToken fee.\\n     */\\n    function quoteSend(SendParam calldata _sendParam, bool _payInLzToken) external view returns (MessagingFee memory);\\n\\n    /**\\n     * @notice Executes the send() operation.\\n     * @param _sendParam The parameters for the send operation.\\n     * @param _fee The fee information supplied by the caller.\\n     *      - nativeFee: The native fee.\\n     *      - lzTokenFee: The lzToken fee.\\n     * @param _refundAddress The address to receive any excess funds from fees etc. on the src.\\n     * @return receipt The LayerZero messaging receipt from the send() operation.\\n     * @return oftReceipt The OFT receipt information.\\n     *\\n     * @dev MessagingReceipt: LayerZero msg receipt\\n     *  - guid: The unique identifier for the sent message.\\n     *  - nonce: The nonce of the sent message.\\n     *  - fee: The LayerZero fee incurred for the message.\\n     */\\n    function send(\\n        SendParam calldata _sendParam,\\n        MessagingFee calldata _fee,\\n        address _refundAddress\\n    ) external payable returns (MessagingReceipt memory, OFTReceipt memory);\\n}\\n\",\"keccak256\":\"0x278e7bdeb2e8aa3f528373d8a3b3fedfe2e1bec050bcaf95065a136645cf56bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IAccessControl} from \\\"./IAccessControl.sol\\\";\\nimport {Context} from \\\"../utils/Context.sol\\\";\\nimport {ERC165} from \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc1bebdee8943bd5e9ef1e0f2e63296aa1dd4171a66b9e74d0286220e891e1458\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted to signal this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\",\"keccak256\":\"0x4d9a2b261b56a1e4a37bb038151dec98b952fed16de2bdfdda27e38e2b12b530\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xff6d0bb2e285473e5311d9d3caacb525ae3538a80758c10649a4d61029b017bb\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC1363.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9b6b3e7803bc5f2f8cd7ad57db8ac1def61a9930a5a3107df4882e028a9605d7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"../utils/introspection/IERC165.sol\\\";\\n\",\"keccak256\":\"0xde7e9fd9aee8d4f40772f96bb3b58836cbc6dfc0227014a061947f8821ea9724\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../token/ERC20/IERC20.sol\\\";\\n\",\"keccak256\":\"0xce41876e78d1badc0512229b4d14e4daf83bc1003d7f83978d18e0e56f965b9c\",\"license\":\"MIT\"},\"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Standard ERC-20 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\\n */\\ninterface IERC20Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC20InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC20InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender`\\u2019s `allowance`. Used in transfers.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\\n     * @param needed Minimum amount required to perform a transfer.\\n     */\\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC20InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC20InvalidSpender(address spender);\\n}\\n\\n/**\\n * @dev Standard ERC-721 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\\n */\\ninterface IERC721Errors {\\n    /**\\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\\n     * Used in balance queries.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721InvalidOwner(address owner);\\n\\n    /**\\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721NonexistentToken(uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param tokenId Identifier number of a token.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC721InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC721InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC721InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC721InvalidOperator(address operator);\\n}\\n\\n/**\\n * @dev Standard ERC-1155 Errors\\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\\n */\\ninterface IERC1155Errors {\\n    /**\\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     * @param balance Current balance for the interacting account.\\n     * @param needed Minimum amount required to perform a transfer.\\n     * @param tokenId Identifier number of a token.\\n     */\\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\\n\\n    /**\\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\\n     * @param sender Address whose tokens are being transferred.\\n     */\\n    error ERC1155InvalidSender(address sender);\\n\\n    /**\\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\\n     * @param receiver Address to which tokens are being transferred.\\n     */\\n    error ERC1155InvalidReceiver(address receiver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator`\\u2019s approval. Used in transfers.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     * @param owner Address of the current owner of a token.\\n     */\\n    error ERC1155MissingApprovalForAll(address operator, address owner);\\n\\n    /**\\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\\n     * @param approver Address initiating an approval operation.\\n     */\\n    error ERC1155InvalidApprover(address approver);\\n\\n    /**\\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\\n     */\\n    error ERC1155InvalidOperator(address operator);\\n\\n    /**\\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\\n     * Used in batch transfers.\\n     * @param idsLength Length of the array of token identifiers\\n     * @param valuesLength Length of the array of token amounts\\n     */\\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\\n}\\n\",\"keccak256\":\"0x880da465c203cec76b10d72dbd87c80f387df4102274f23eea1f9c9b0918792b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\nimport {IERC20Metadata} from \\\"./extensions/IERC20Metadata.sol\\\";\\nimport {Context} from \\\"../../utils/Context.sol\\\";\\nimport {IERC20Errors} from \\\"../../interfaces/draft-IERC6093.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC-20\\n * applications.\\n */\\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\\n    mapping(address account => uint256) private _balances;\\n\\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * Both values are immutable: they can only be set once during construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `value`.\\n     */\\n    function transfer(address to, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `value`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `value`.\\n     */\\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _transfer(address from, address to, uint256 value) internal {\\n        if (from == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        if (to == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\\n     * this function.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _update(address from, address to, uint256 value) internal virtual {\\n        if (from == address(0)) {\\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\\n            _totalSupply += value;\\n        } else {\\n            uint256 fromBalance = _balances[from];\\n            if (fromBalance < value) {\\n                revert ERC20InsufficientBalance(from, fromBalance, value);\\n            }\\n            unchecked {\\n                // Overflow not possible: value <= fromBalance <= totalSupply.\\n                _balances[from] = fromBalance - value;\\n            }\\n        }\\n\\n        if (to == address(0)) {\\n            unchecked {\\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\\n                _totalSupply -= value;\\n            }\\n        } else {\\n            unchecked {\\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\\n                _balances[to] += value;\\n            }\\n        }\\n\\n        emit Transfer(from, to, value);\\n    }\\n\\n    /**\\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\\n     * Relies on the `_update` mechanism\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\\n     */\\n    function _mint(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidReceiver(address(0));\\n        }\\n        _update(address(0), account, value);\\n    }\\n\\n    /**\\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\\n     * Relies on the `_update` mechanism.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * NOTE: This function is not virtual, {_update} should be overridden instead\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        if (account == address(0)) {\\n            revert ERC20InvalidSender(address(0));\\n        }\\n        _update(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     *\\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        _approve(owner, spender, value, true);\\n    }\\n\\n    /**\\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\\n     *\\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\\n     * `Approval` event during `transferFrom` operations.\\n     *\\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\\n     * true using the following override:\\n     *\\n     * ```solidity\\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\\n     *     super._approve(owner, spender, value, true);\\n     * }\\n     * ```\\n     *\\n     * Requirements are the same as {_approve}.\\n     */\\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\\n        if (owner == address(0)) {\\n            revert ERC20InvalidApprover(address(0));\\n        }\\n        if (spender == address(0)) {\\n            revert ERC20InvalidSpender(address(0));\\n        }\\n        _allowances[owner][spender] = value;\\n        if (emitEvent) {\\n            emit Approval(owner, spender, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\\n     *\\n     * Does not update the allowance value in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Does not emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance < type(uint256).max) {\\n            if (currentAllowance < value) {\\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\\n            }\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - value, false);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x41f6b3b9e030561e7896dbef372b499cc8d418a80c3884a4d65a68f2fdc7493a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\",\"keccak256\":\"0xe06a3f08a987af6ad2e1c1e774405d4fe08f1694b67517438b467cecf0da0ef7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x70f2f713b13b7ce4610bcd0ac9fec0f3cc43693b043abcb8dc40a42a726eb330\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\\"../IERC20.sol\\\";\\nimport {IERC1363} from \\\"../../../interfaces/IERC1363.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\\"client\\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\\"client\\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\\"standard\\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            // bubble errors\\n            if iszero(success) {\\n                let ptr := mload(0x40)\\n                returndatacopy(ptr, 0, returndatasize())\\n                revert(ptr, returndatasize())\\n            }\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n\\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly (\\\"memory-safe\\\") {\\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0)\\n        }\\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\\n    }\\n}\\n\",\"keccak256\":\"0x982c5cb790ab941d1e04f807120a71709d4c313ba0bfc16006447ffbd27fbbd5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC165} from \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xddce8e17e3d3f9ed818b4f4c4478a8262aab8b11ed322f1bf5ed705bb4bd97fa\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x79796192ec90263f21b464d5bc90b777a525971d3de8232be80d9c4f9fb353b8\",\"license\":\"MIT\"},\"contracts/IStargate.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// Solidity does not support splitting import across multiple lines\\n// solhint-disable-next-line max-line-length\\nimport {IOFT, SendParam, MessagingFee, MessagingReceipt, OFTReceipt} from \\\"@layerzerolabs/lz-evm-oapp-v2/contracts/oft/interfaces/IOFT.sol\\\";\\n\\n/// @notice Stargate implementation type.\\nenum StargateType {\\n    Pool,\\n    OFT\\n}\\n\\n/// @notice Ticket data for bus ride.\\nstruct Ticket {\\n    uint72 ticketId;\\n    bytes passengerBytes;\\n}\\n\\n/// @title Interface for Stargate.\\n/// @notice Defines an API for sending tokens to destination chains.\\ninterface IStargate is IOFT {\\n    /// @dev This function is same as `send` in OFT interface but returns the ticket data if in the bus ride mode,\\n    /// which allows the caller to ride and drive the bus in the same transaction.\\n    function sendToken(\\n        SendParam calldata _sendParam,\\n        MessagingFee calldata _fee,\\n        address _refundAddress\\n    )\\n        external\\n        payable\\n        returns (\\n            MessagingReceipt memory msgReceipt,\\n            OFTReceipt memory oftReceipt,\\n            Ticket memory ticket\\n        );\\n\\n    /// @notice Returns the Stargate implementation type.\\n    function stargateType() external pure returns (StargateType);\\n}\\n\",\"keccak256\":\"0xe2fb02ca1b2b8a6247ecf9fdfc031357eb047e29ea633dae572291e21fff73e2\",\"license\":\"BUSL-1.1\"},\"contracts/IStargatePool.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\nimport {IStargate, SendParam, MessagingReceipt, MessagingFee, OFTReceipt} from \\\"./IStargate.sol\\\";\\n\\n/// @title An interface for Stargate Pools\\n/// @notice Stargate Pools are a type of IStargate that allows users to pool token liquidity.\\ninterface IStargatePool is IStargate {\\n    /// @notice Deposit token into the pool\\n    /// @param _receiver The account to mint the LP tokens to\\n    /// @param _amountLD The amount of tokens to deposit in LD\\n    /// @return amountLD The actual amount of tokens deposited in LD\\n    function deposit(\\n        address _receiver,\\n        uint256 _amountLD\\n    ) external payable returns (uint256 amountLD);\\n\\n    /// @notice Redeem an amount of LP tokens from the senders account, claiming rewards.\\n    /// @param _amountLD The amount of LP tokens to redeem\\n    /// @param _receiver The account to transfer the\\n    function redeem(\\n        uint256 _amountLD,\\n        address _receiver\\n    ) external returns (uint256 amountLD);\\n\\n    /// @notice Get how many LP tokens are redeemable for a given account\\n    /// @param _owner The address of the account to check\\n    /// @return amountLD The amount of LP tokens redeemable, in LD\\n    function redeemable(\\n        address _owner\\n    ) external view returns (uint256 amountLD);\\n\\n    /// @notice Redeem LP tokens and send the withdrawn tokens to a destination endpoint.\\n    /// @param _sendParam The SendParam payload describing the redeem and send\\n    /// @param _fee The MessagingFee to perform redeemSend\\n    /// @param _refundAddress The address to refund excess LayerZero messaging fees.\\n    /// @return receipt The MessagingReceipt describing the result of redeemSend\\n    /// @return oftReceipt The OFTReceipt describing the result of redeemSend\\n    function redeemSend(\\n        SendParam calldata _sendParam,\\n        MessagingFee calldata _fee,\\n        address _refundAddress\\n    )\\n        external\\n        payable\\n        returns (MessagingReceipt memory receipt, OFTReceipt memory oftReceipt);\\n\\n    /// @notice Quote the messaging fee for a redeemSend operation\\n    /// @param _sendParam The SendParam payload describing the redeem and send\\n    /// @param _payInLzToken Whether to pay the fee in LZ token\\n    /// @return messagingFee The MessagingFee for the redeemSend operation\\n    function quoteRedeemSend(\\n        SendParam calldata _sendParam,\\n        bool _payInLzToken\\n    ) external view returns (MessagingFee memory messagingFee);\\n\\n    /// @notice Get the Total Value Locked in the pool.\\n    /// @return The total value locked\\n    function tvl() external view returns (uint256);\\n\\n    /// @notice Get the available balance of the pool\\n    function poolBalance() external view returns (uint256);\\n\\n    /// @notice Get the address of the LP token\\n    /// @return The address of the LP token contract.\\n    function lpToken() external view returns (address);\\n}\\n\",\"keccak256\":\"0xba0f1c74a40f71fed3d8230188e784f479be9b93e8615277beba09c0c47ddf6d\",\"license\":\"BUSL-1.1\"},\"contracts/PoseidonMerkleTree.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport \\\"./utils/Poseidon2.sol\\\";\\n\\ncontract PoseidonMerkleTree {\\n    using Field for *;\\n\\n    // The root of a poseidon2 merkle tree with height 12 and all leaf nodes filled with:\\n    // EMPTY_LEAF = keccak256(abi.encodePacked(\\\"TANGERINE\\\")) % FIELD_MODULUS\\n    uint256 public constant INITIAL_ROOT =\\n        0x124005ad54174bbcb8c2dd053ea318daa80106cdcc518731504b771d6006123f;\\n\\n    // The maximum field that can be hashed in our poseidon2 order\\n    uint256 public constant MAX_VALUE = Field.PRIME;\\n\\n    // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\\n    // it removes index range check on every interaction\\n    mapping(uint256 => uint256) public filledSubtrees;\\n    mapping(uint256 => uint256) public roots;\\n\\n    uint256 public immutable height; // 12\\n\\n    uint32 public constant ROOT_HISTORY_SIZE = 100;\\n    uint32 public currentRootIndex = 0;\\n    uint256 public nextIndex = 0;\\n\\n    uint256 public MAX_LEAF_INDEX;\\n\\n    Poseidon2 poseidon2Hasher;\\n\\n    constructor(uint256 _height) {\\n        height = _height;\\n        MAX_LEAF_INDEX = 2 ** (_height - 1);\\n\\n        poseidon2Hasher = new Poseidon2();\\n\\n        roots[0] = uint256(INITIAL_ROOT);\\n    }\\n\\n    function zeros(uint256 i) public pure returns (uint256) {\\n        if (i == 0) {\\n            // Base ZERO_VALUE: keccak256(abi.encodePacked(\\\"TANGERINE\\\")) % FIELD_MODULUS\\n            return\\n                uint256(\\n                    0x1e2856f9f722631c878a92dc1d84283d04b76df3e1831492bdf7098c1e65e478\\n                );\\n        } else if (i == 1) {\\n            return\\n                uint256(\\n                    0x2c2eecb1b14035bfd9765e84195684b401a84fdb58c3c03f1bcea86dcf0c8105\\n                );\\n        } else if (i == 2) {\\n            return\\n                uint256(\\n                    0x237e412a71db31e5769f63d92346a09dd0f30b9c335e9d9aa96b6625eb537445\\n                );\\n        } else if (i == 3) {\\n            return\\n                uint256(\\n                    0x0b3ff120d61a7de2da3d80ff99d393796805c74be5c39e8a4c7436d1c65dad4c\\n                );\\n        } else if (i == 4) {\\n            return\\n                uint256(\\n                    0x0fc58e21665302678bef68714d9e5889583071f7bd3cf018b64fafc51b0a9cf3\\n                );\\n        } else if (i == 5) {\\n            return\\n                uint256(\\n                    0x235df7c585524ed8a26aea20a0fb168038f10df71d84720c9a8c1b3e78e3b6cd\\n                );\\n        } else if (i == 6) {\\n            return\\n                uint256(\\n                    0x1c6cabee394ea24dc09eab1788f7f62b367e95789f883e33690d94215d819264\\n                );\\n        } else if (i == 7) {\\n            return\\n                uint256(\\n                    0x09bec327ab2c8dda5d2d435cd267cb21e71f21371a01739885817eb1625d8976\\n                );\\n        } else if (i == 8) {\\n            return\\n                uint256(\\n                    0x2d35519ad7061578be50cbbfe040327843f6b4cdf1458e01b5f9737dbaf82b18\\n                );\\n        } else if (i == 9) {\\n            return\\n                uint256(\\n                    0x0f86c9e9c9e689394a4944bb87291a3f55cc930b21432fccf41b8267f1a98d6f\\n                );\\n        } else if (i == 10) {\\n            return\\n                uint256(\\n                    0x181c9ba70900093b180c96f55cc2b1d73d60b8ab613344cbba83b33cbcc94e2b\\n                );\\n        } else {\\n            revert(\\\"Index out of bounds\\\");\\n        }\\n    }\\n\\n    event LeafInserted(uint256 indexed leafIndex, uint256 indexed leafValue);\\n\\n    // Add a helper function to generate consistent keys\\n    function getStorageKey(\\n        uint256 level,\\n        uint256 index\\n    ) internal pure returns (uint256) {\\n        return (level << 32) | index; // Combine level and index into a single key\\n    }\\n\\n    function _insert(uint256 _leaf) internal returns (uint256 index) {\\n        uint256 insertIndex = nextIndex;\\n        require(insertIndex != MAX_LEAF_INDEX, \\\"Tree Full\\\");\\n\\n        uint256 currentIndex = insertIndex;\\n        uint256 currentHash = _leaf;\\n\\n        // Store leaf at level 0\\n        filledSubtrees[getStorageKey(0, currentIndex)] = currentHash;\\n\\n        for (uint256 i = 0; i < height - 1; i++) {\\n            bool isLeft = currentIndex % 2 == 0;\\n            uint256 siblingIndex = isLeft ? currentIndex + 1 : currentIndex - 1;\\n\\n            // Get sibling value using consistent key generation\\n            uint256 siblingKey = getStorageKey(i, siblingIndex);\\n            uint256 sibling = filledSubtrees[siblingKey];\\n            if (sibling == 0) {\\n                sibling = zeros(i);\\n            }\\n\\n            // Calculate parent hash based on position\\n            if (isLeft) {\\n                currentHash = hashLeftRight(currentHash, sibling);\\n            } else {\\n                currentHash = hashLeftRight(sibling, currentHash);\\n            }\\n\\n            // Move up to parent level\\n            currentIndex = currentIndex / 2;\\n\\n            // Store the computed hash for the next level using consistent key\\n            filledSubtrees[getStorageKey(i + 1, currentIndex)] = currentHash;\\n        }\\n\\n        uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\\n        currentRootIndex = newRootIndex;\\n        roots[newRootIndex] = currentHash;\\n\\n        nextIndex = insertIndex + 1;\\n        emit LeafInserted(insertIndex, _leaf);\\n\\n        return insertIndex;\\n    }\\n\\n    function hashLeftRight(\\n        uint256 _left,\\n        uint256 _right\\n    ) public view returns (uint256) {\\n        return\\n            poseidon2Hasher\\n                .hash_2(uint256(_left).toField(), uint256(_right).toField())\\n                .toUint256();\\n    }\\n\\n    function isKnownRoot(uint256 _root) public view returns (bool) {\\n        if (_root == 0) {\\n            return false;\\n        }\\n        uint32 _currentRootIndex = currentRootIndex;\\n        uint32 i = _currentRootIndex;\\n        do {\\n            if (_root == roots[i]) {\\n                return true;\\n            }\\n            if (i == 0) {\\n                i = ROOT_HISTORY_SIZE;\\n            }\\n            i--;\\n        } while (i != _currentRootIndex);\\n        return false;\\n    }\\n}\\n\",\"keccak256\":\"0x7e4431c699ca6f66373887900e23108f248a55cda04b1c3ef0f8397631216eaa\",\"license\":\"UNLICENSED\"},\"contracts/PrivateStargateFinance.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {AccessControl} from \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\nimport {DepositVerifier} from \\\"./verifiers/DepositVerifier.sol\\\";\\nimport {TransferVerifier} from \\\"./verifiers/TransferVerifier.sol\\\";\\nimport {WithdrawVerifier} from \\\"./verifiers/WithdrawVerifier.sol\\\";\\nimport {WarpVerifier} from \\\"./verifiers/WarpVerifier.sol\\\";\\nimport {IStargatePool} from \\\"./IStargatePool.sol\\\";\\n\\nimport \\\"./PrivateStargateOApp.sol\\\";\\nimport \\\"./StargateSenderBase.sol\\\";\\n\\nuint256 constant NOTES_INPUT_LENGTH = 3;\\nuint256 constant EXIT_ASSET_START_INDEX = 4;\\nuint256 constant EXIT_AMOUNT_START_INDEX = 7;\\nuint256 constant EXIT_ADDRESSES_START_INDEX = 10;\\n\\ncontract PrivateStargateFinance is\\n    PrivateStargateOApp,\\n    StargateSenderBase,\\n    AccessControl\\n{\\n    DepositVerifier public depositVerifier;\\n    TransferVerifier public transferVerifier;\\n    WithdrawVerifier public withdrawVerifier;\\n    WarpVerifier public warpVerifier;\\n\\n    bytes32 public DEPOSIT_ROLE = keccak256(\\\"DEPOSIT_ROLE\\\"); // :(\\n\\n    mapping(bytes32 => bool) public nullifierUsed;\\n    mapping(address => bool) public availableOFTs;\\n\\n    event NullifierUsed(uint256 indexed nullifier);\\n    event NotePayload(bytes encryptedNote);\\n\\n    constructor(\\n        address _endpoint,\\n        address _owner,\\n        address _depositVerifier,\\n        address _transferVerifier,\\n        address _withdrawVerifier,\\n        address _warpVerifier\\n    ) Ownable(_owner) PrivateStargateOApp(_endpoint, _owner) {\\n        depositVerifier = DepositVerifier(_depositVerifier);\\n        transferVerifier = TransferVerifier(_transferVerifier);\\n        withdrawVerifier = WithdrawVerifier(_withdrawVerifier);\\n        warpVerifier = WarpVerifier(_warpVerifier);\\n\\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _grantRole(DEPOSIT_ROLE, msg.sender);\\n    }\\n\\n    function deposit(\\n        address _erc20,\\n        uint64 _amount, // !dev no exponent here\\n        bytes calldata _proof,\\n        bytes32[] calldata _publicInputs,\\n        bytes[] calldata _payload\\n    ) public onlyRole(DEPOSIT_ROLE) {\\n        uint8 decimals = ERC20(_erc20).decimals();\\n        bool depositTransfer = ERC20(_erc20).transferFrom(\\n            msg.sender,\\n            address(this),\\n            _amount * 10 ** decimals\\n        );\\n        require(depositTransfer, \\\"failed to transfer deposit\\\");\\n\\n        // VERIFY PROOF\\n        bool isValidProof = depositVerifier.verify(_proof, _publicInputs);\\n        require(isValidProof, \\\"Invalid deposit proof!\\\");\\n\\n        // CHECK INPUT ADDRESS AND AMOUNT MATCH PROOF INPUTS\\n        require(\\n            _erc20 == address(uint160(uint256(_publicInputs[1]))),\\n            \\\"ERC20 address mismatch\\\"\\n        );\\n        require(\\n            _amount == uint64(uint256(_publicInputs[2])),\\n            \\\"Address amount incorrect\\\"\\n        );\\n\\n        // INSERT NOTE INTO TREE\\n        _insert(uint256(_publicInputs[0]));\\n\\n        // emit payload note parameters\\n        for (uint256 i = 0; i < 3 && i < _payload.length; i++) {\\n            if (_payload[i].length != 0) {\\n                emit NotePayload(_payload[i]);\\n            }\\n        }\\n    }\\n\\n    function transfer(\\n        bytes calldata _proof,\\n        bytes32[] calldata _publicInputs,\\n        bytes[] calldata _payload\\n    ) public {\\n        // verify the root is in the trees history\\n        require(isKnownRoot(uint256(_publicInputs[0])), \\\"Invalid Root!\\\");\\n\\n        // verify the proof\\n        bool isValidProof = transferVerifier.verify(_proof, _publicInputs);\\n        require(isValidProof, \\\"Invalid transfer proof\\\");\\n\\n        // if proof is valid, write nullifiers as spent\\n        for (uint256 i = 1; i < NOTES_INPUT_LENGTH + 1; i++) {\\n            if (_publicInputs[i] != bytes32(0)) {\\n                // check not spent\\n                require(\\n                    nullifierUsed[_publicInputs[i]] == false,\\n                    \\\"Nullifier already spent\\\"\\n                );\\n                // mark as spent\\n                nullifierUsed[_publicInputs[i]] = true;\\n\\n                emit NullifierUsed(uint256(_publicInputs[i]));\\n            }\\n        }\\n\\n        // and insert output note commitments\\n        for (\\n            uint256 i = NOTES_INPUT_LENGTH + 1;\\n            i < NOTES_INPUT_LENGTH + 1 + NOTES_INPUT_LENGTH;\\n            i++\\n        ) {\\n            if (_publicInputs[i] != bytes32(0)) {\\n                _insert(uint256(_publicInputs[i]));\\n            }\\n        }\\n\\n        // emit payload note parameters\\n        for (uint256 i = 0; i < 3 && i < _payload.length; i++) {\\n            if (_payload[i].length != 0) {\\n                emit NotePayload(_payload[i]);\\n            }\\n        }\\n    }\\n\\n    function withdraw(\\n        bytes calldata _proof,\\n        bytes32[] calldata _publicInputs\\n    ) public {\\n        require(isKnownRoot(uint256(_publicInputs[0])), \\\"Invalid Root!\\\");\\n\\n        bool isValidProof = withdrawVerifier.verify(_proof, _publicInputs);\\n        require(isValidProof, \\\"Invalid withdraw proof\\\");\\n\\n        // Mark nullifiers as spent\\n        for (uint256 i = 1; i <= NOTES_INPUT_LENGTH; i++) {\\n            if (_publicInputs[i] != bytes32(0)) {\\n                // check not spent\\n                require(\\n                    nullifierUsed[_publicInputs[i]] == false,\\n                    \\\"Nullifier already spent\\\"\\n                );\\n                // mark as spent\\n                nullifierUsed[_publicInputs[i]] = true;\\n\\n                emit NullifierUsed(uint256(_publicInputs[i]));\\n            }\\n        }\\n\\n        // Process withdrawals - FIX: correct index calculations\\n        for (uint256 i = 0; i < NOTES_INPUT_LENGTH; i++) {\\n            uint256 assetIndex = EXIT_ASSET_START_INDEX + i;\\n            uint256 amountIndex = EXIT_AMOUNT_START_INDEX + i;\\n            uint256 addressIndex = EXIT_ADDRESSES_START_INDEX + i;\\n\\n            address exitAsset = address(\\n                uint160(uint256(_publicInputs[assetIndex]))\\n            );\\n            uint256 exitAmount = uint256(_publicInputs[amountIndex]);\\n            address exitAddress = address(\\n                uint160(uint256(_publicInputs[addressIndex]))\\n            );\\n\\n            if (exitAmount > 0) {\\n                // Get token decimals and calculate actual amount to transfer\\n                uint8 decimals = ERC20(exitAsset).decimals();\\n                uint256 actualAmount = exitAmount * 10 ** decimals;\\n\\n                // Transfer tokens to the exit address\\n                bool success = ERC20(exitAsset).transfer(\\n                    exitAddress,\\n                    actualAmount\\n                );\\n                require(success, \\\"Token transfer failed\\\");\\n            }\\n        }\\n    }\\n\\n    function warp(\\n        uint32 _dstEid,\\n        bytes calldata _proof,\\n        bytes32[] calldata _publicInputs,\\n        bytes calldata _options,\\n        bytes[] calldata _payload\\n    ) public payable {\\n        // verify root is in the history of the tree\\n        require(isKnownRoot(uint256(_publicInputs[0])), \\\"Invalid Root!\\\");\\n\\n        // verify the warp proof\\n        bool isValidProof = warpVerifier.verify(_proof, _publicInputs);\\n        require(isValidProof, \\\"Invalid warp proof\\\");\\n\\n        // check that all assets used in this cross chain request are supported\\n        for (uint256 i = 7; i < 9; i++) {\\n            if (_publicInputs[i] != bytes32(0)) {\\n                address exitAsset = address(uint160(uint256(_publicInputs[i])));\\n                require(availableOFTs[exitAsset], \\\"Not a supported OFT\\\");\\n            }\\n        }\\n\\n        // publicInputs layout:\\n        // 0 = root\\n        // 1 - 3 = nullifiers\\n        // 4 - 6 = output hashes\\n        // 7 - 9 = stargate asset addresses\\n        // 10 - 12 = stargate amounts\\n\\n        // Mark nullifiers as spent\\n        for (uint256 i = 1; i <= NOTES_INPUT_LENGTH; i++) {\\n            if (_publicInputs[i] != bytes32(0)) {\\n                require(\\n                    nullifierUsed[_publicInputs[i]] == false,\\n                    \\\"Nullifier already spent\\\"\\n                );\\n                nullifierUsed[_publicInputs[i]] = true;\\n                emit NullifierUsed(uint256(_publicInputs[i]));\\n            }\\n        }\\n\\n        // Extract non-zero output hashes for cross-chain payload\\n        uint256[] memory finalNotes = _extractOutputHashes(_publicInputs);\\n\\n        // send the note hashes to insert through LZ\\n        bytes memory lzPayload = abi.encode(finalNotes);\\n        _lzSend(\\n            _dstEid,\\n            lzPayload,\\n            _options,\\n            // Fee in native gas and ZRO token.\\n            MessagingFee(msg.value, 0),\\n            // Refund address in case of failed source message.\\n            payable(address(this))\\n        );\\n\\n        // get the address of private stargate finance on the remote chain\\n        bytes32 peer = peers[_dstEid];\\n\\n        // send the stargate assets to the PSF on the remote chain\\n        _sendStargateAssets(_dstEid, peer, _publicInputs, _options);\\n\\n        // emit payload note parameters\\n        for (uint256 i = 0; i < 3 && i < _payload.length; i++) {\\n            if (_payload[i].length != 0) {\\n                emit NotePayload(_payload[i]);\\n            }\\n        }\\n    }\\n\\n    function addSupportedOFT(\\n        address _oft,\\n        bool _enabled\\n    ) public onlyRole(DEFAULT_ADMIN_ROLE) {\\n        availableOFTs[_oft] = _enabled;\\n    }\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {}\\n\\n    function _extractOutputHashes(\\n        bytes32[] calldata _publicInputs\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory notes = new uint256[](NOTES_INPUT_LENGTH);\\n        uint256 noteCount = 0;\\n\\n        for (uint256 i = 4; i <= 6; i++) {\\n            // output hashes are at indices 4-6\\n            if (_publicInputs[i] != bytes32(0)) {\\n                notes[noteCount] = uint256(_publicInputs[i]);\\n                noteCount++;\\n            }\\n        }\\n\\n        // Resize notes array to actual count\\n        uint256[] memory finalNotes = new uint256[](noteCount);\\n        for (uint256 i = 0; i < noteCount; i++) {\\n            finalNotes[i] = notes[i];\\n        }\\n\\n        return finalNotes;\\n    }\\n}\\n\",\"keccak256\":\"0x4d29ddc54bf9702e0784f82e6f43674f8e30af477243ed55da8c1358417e4ad3\",\"license\":\"UNLICENSED\"},\"contracts/PrivateStargateOApp.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport {OApp, Origin, MessagingFee} from \\\"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\\\";\\n\\nimport \\\"./PoseidonMerkleTree.sol\\\";\\n\\nabstract contract PrivateStargateOApp is PoseidonMerkleTree, OApp {\\n    constructor(\\n        address _endpoint,\\n        address _owner\\n    ) PoseidonMerkleTree(12) OApp(_endpoint, _owner) {}\\n\\n    function _lzReceive(\\n        Origin calldata,\\n        bytes32,\\n        bytes calldata payload,\\n        address, // Executor address as specified by the OApp.\\n        bytes calldata // Any extra data or options to trigger on receipt.\\n    ) internal override {\\n        // Decode the payload as uint256[]\\n        uint256[] memory notes = abi.decode(payload, (uint256[]));\\n\\n        // Insert each note into the Merkle tree\\n        for (uint256 i = 0; i < notes.length; i++) {\\n            _insert(notes[i]);\\n        }\\n    }\\n\\n    function quote(\\n        uint32 _dstEid, // Destination chain's endpoint ID.\\n        uint256[] memory notes,\\n        bytes calldata _options,\\n        bool _payInLzToken // boolean for which token to return fee in\\n    ) public view returns (uint256 nativeFee, uint256 lzTokenFee) {\\n        bytes memory _payload = abi.encode(notes);\\n        MessagingFee memory fee = _quote(\\n            _dstEid,\\n            _payload,\\n            _options,\\n            _payInLzToken\\n        );\\n        return (fee.nativeFee, fee.lzTokenFee);\\n    }\\n}\\n\",\"keccak256\":\"0x13d9d7807bea7d0e8c3b3ffc0e549711830b5d0e3fd1d791c9ee6ca1510d21f8\",\"license\":\"UNLICENSED\"},\"contracts/StargateSenderBase.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IOFT, SendParam, OFTReceipt} from \\\"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\\\";\\n\\nimport {MessagingFee} from \\\"@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol\\\";\\n\\ncontract StargateSenderBase {\\n    function _sendStargateAssets(\\n        uint32 _dstEid,\\n        bytes32 peer,\\n        bytes32[] calldata _publicInputs,\\n        bytes calldata _options\\n    ) internal {\\n        for (uint256 i = 7; i < 10; i++) {\\n            address stargateAssetAddress = address(\\n                uint160(uint256(_publicInputs[i]))\\n            );\\n\\n            if (stargateAssetAddress != address(0)) {\\n                _sendSingleStargateAsset(\\n                    _dstEid,\\n                    peer,\\n                    stargateAssetAddress,\\n                    uint256(_publicInputs[i + 3]), // amount is at i+3 (indices 10-12)\\n                    _options\\n                );\\n            }\\n        }\\n    }\\n\\n    function _sendSingleStargateAsset(\\n        uint32 _dstEid,\\n        bytes32 peer,\\n        address stargateAssetAddress,\\n        uint256 amount,\\n        bytes calldata _options\\n    ) internal {\\n        uint256 adjustedAmount = amount *\\n            10 ** ERC20(stargateAssetAddress).decimals();\\n\\n        SendParam memory sendParam = SendParam(\\n            _dstEid,\\n            peer,\\n            adjustedAmount,\\n            adjustedAmount,\\n            _options,\\n            \\\"\\\",\\n            \\\"\\\"\\n        );\\n\\n        MessagingFee memory fee = IOFT(stargateAssetAddress).quoteSend(\\n            sendParam,\\n            false\\n        );\\n\\n        IOFT(stargateAssetAddress).send{value: fee.nativeFee}(\\n            sendParam,\\n            fee,\\n            payable(msg.sender)\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xd93da2b7bc8f755c4ee45eac36048be5298a7f9c5c07c266e91f0e94f13b9742\",\"license\":\"UNLICENSED\"},\"contracts/utils/Field.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.24;\\n\\nlibrary Field {\\n    type Type is uint256;\\n\\n    uint256 constant PRIME =\\n        0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;\\n    uint256 constant PRIME_DIV_2 =\\n        0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n\\n    function checkField(Field.Type a) internal pure {\\n        require(Field.Type.unwrap(a) < PRIME, \\\"Field: input is too large\\\");\\n    }\\n\\n    function toFieldUnchecked(uint256 a) internal pure returns (Field.Type b) {\\n        b = Field.Type.wrap(a);\\n    }\\n\\n    function toField(uint256 a) internal pure returns (Field.Type b) {\\n        b = Field.Type.wrap(a);\\n        checkField(b);\\n    }\\n\\n    function toFieldUnchecked(bytes32 a) internal pure returns (Field.Type b) {\\n        assembly {\\n            b := a\\n        }\\n    }\\n\\n    function toField(bytes32 a) internal pure returns (Field.Type b) {\\n        assembly {\\n            b := a\\n        }\\n        checkField(b);\\n    }\\n\\n    function toBytes32(Field.Type a) internal pure returns (bytes32 b) {\\n        assembly {\\n            b := a\\n        }\\n    }\\n\\n    function toUint256(Field.Type a) internal pure returns (uint256 b) {\\n        assembly {\\n            b := a\\n        }\\n    }\\n\\n    function toAddress(Field.Type a) internal pure returns (address b) {\\n        require(Field.Type.unwrap(a) < (1 << 160), \\\"Field: input is too large\\\");\\n        assembly {\\n            b := a\\n        }\\n    }\\n\\n    function toArr(Field.Type a) internal pure returns (bytes32[] memory b) {\\n        b = new bytes32[](1);\\n        b[0] = toBytes32(a);\\n    }\\n\\n    function toField(address a) internal pure returns (Field.Type b) {\\n        assembly {\\n            b := a\\n        }\\n    }\\n\\n    function toField(int256 a) internal pure returns (Field.Type) {\\n        // return Field.Type.wrap(a);\\n        if (a < 0) {\\n            require(uint256(-a) < PRIME, \\\"Field: input is too large\\\");\\n            return Field.Type.wrap(PRIME - uint256(-a));\\n        } else {\\n            require(uint256(a) < PRIME, \\\"Field: input is too large\\\");\\n            return Field.Type.wrap(uint256(a));\\n        }\\n    }\\n\\n    function into(\\n        Field.Type[] memory a\\n    ) internal pure returns (bytes32[] memory b) {\\n        assembly {\\n            b := a\\n        }\\n    }\\n\\n    function add(\\n        Field.Type a,\\n        Field.Type b\\n    ) internal pure returns (Field.Type c) {\\n        assembly {\\n            c := addmod(a, b, PRIME)\\n        }\\n    }\\n\\n    function mul(\\n        Field.Type a,\\n        Field.Type b\\n    ) internal pure returns (Field.Type c) {\\n        assembly {\\n            c := mulmod(a, b, PRIME)\\n        }\\n    }\\n\\n    function add(Field.Type a, uint256 b) internal pure returns (Field.Type c) {\\n        assembly {\\n            c := addmod(a, b, PRIME)\\n        }\\n    }\\n\\n    function mul(Field.Type a, uint256 b) internal pure returns (Field.Type c) {\\n        assembly {\\n            c := mulmod(a, b, PRIME)\\n        }\\n    }\\n\\n    function eq(Field.Type a, Field.Type b) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, b)\\n        }\\n    }\\n\\n    function isZero(Field.Type a) internal pure returns (bool c) {\\n        assembly {\\n            c := eq(a, 0)\\n        }\\n    }\\n\\n    function signed(\\n        Field.Type a\\n    ) internal pure returns (bool positive, uint256 scalar) {\\n        uint256 raw = Field.Type.unwrap(a);\\n        if (raw > PRIME_DIV_2) {\\n            return (false, PRIME - raw);\\n        } else {\\n            return (true, raw);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xca0394d4102d57a75ba140ee064a29b0a3ef4dce853f5592ae62f433e178521b\",\"license\":\"UNLICENSED\"},\"contracts/utils/Poseidon2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.8;\\n\\nimport {Field} from \\\"./Field.sol\\\";\\nimport {Poseidon2Lib} from \\\"./Poseidon2Lib.sol\\\";\\n\\ncontract Poseidon2 {\\n    using Field for *;\\n\\n    function hash_1(Field.Type x) public view returns (Field.Type) {\\n        return Poseidon2Lib.hash_1(x);\\n    }\\n\\n    function hash_2(\\n        Field.Type x,\\n        Field.Type y\\n    ) public view returns (Field.Type) {\\n        return Poseidon2Lib.hash_2(x, y);\\n    }\\n\\n    function hash_3(\\n        Field.Type x,\\n        Field.Type y,\\n        Field.Type z\\n    ) public view returns (Field.Type) {\\n        return Poseidon2Lib.hash_3(x, y, z);\\n    }\\n\\n    function hash(Field.Type[] memory input) public view returns (Field.Type) {\\n        return Poseidon2Lib.hash(input, input.length, false);\\n    }\\n\\n    function hash(\\n        Field.Type[] memory input,\\n        uint256 std_input_length,\\n        bool is_variable_length\\n    ) public view returns (Field.Type) {\\n        return Poseidon2Lib.hash(input, std_input_length, is_variable_length);\\n    }\\n}\\n\",\"keccak256\":\"0x7c66781a8e6a6f3eff5cca28cd8f50a9ad42f0293cdf70211110e207d3200b6c\",\"license\":\"MIT\"},\"contracts/utils/Poseidon2Lib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.8;\\n\\nimport {Field} from \\\"./Field.sol\\\";\\n\\n// import {console} from \\\"hardhat/console.sol\\\";\\n\\n// Poseidon2 hash function\\n// credits: https://github.com/noir-lang/noir/blob/d8710c4442be2fcffc348f1f5776bc278d028ad0/acvm-repo/bn254_blackbox_solver/src/poseidon2.rs\\nlibrary Poseidon2Lib {\\n    using Field for *;\\n    using Poseidon2Lib for Sponge;\\n\\n    uint256 constant t = 4;\\n    uint256 constant rounds_f = 8;\\n    uint256 constant rounds_p = 56;\\n    uint256 constant RATE = 3;\\n\\n    struct Constants {\\n        Field.Type[4] internal_matrix_diagonal;\\n        Field.Type[4][64] round_constant;\\n    }\\n\\n    struct Sponge {\\n        Field.Type iv;\\n        Field.Type[3] cache;\\n        Field.Type[4] state;\\n        uint256 cache_size;\\n        bool squeeze_mode; // 0 => absorb, 1 => squeeze\\n        Constants constants;\\n    }\\n\\n    /**\\n     * Public API: best for single time use\\n     */\\n    function hash_1(Field.Type m) internal view returns (Field.Type) {\\n        Field.Type[] memory inputs = new Field.Type[](1);\\n        inputs[0] = m;\\n        return hash_internal(load(), inputs, 1, false);\\n    }\\n\\n    function hash_2(\\n        Field.Type m1,\\n        Field.Type m2\\n    ) internal view returns (Field.Type) {\\n        Field.Type[] memory inputs = new Field.Type[](2);\\n        inputs[0] = m1;\\n        inputs[1] = m2;\\n        return hash_internal(load(), inputs, 2, false);\\n    }\\n\\n    function hash_3(\\n        Field.Type m1,\\n        Field.Type m2,\\n        Field.Type m3\\n    ) internal view returns (Field.Type) {\\n        Field.Type[] memory inputs = new Field.Type[](3);\\n        inputs[0] = m1;\\n        inputs[1] = m2;\\n        inputs[2] = m3;\\n        return hash_internal(load(), inputs, 3, false);\\n    }\\n\\n    function hash(\\n        Field.Type[] memory inputs,\\n        uint256 std_input_length,\\n        bool is_variable_length\\n    ) internal view returns (Field.Type) {\\n        return\\n            hash_internal(load(), inputs, std_input_length, is_variable_length);\\n    }\\n\\n    /**\\n     * Public API: best for multiple use in same call context\\n     */\\n    function hash_1(\\n        Poseidon2Lib.Constants memory constants,\\n        Field.Type m\\n    ) internal view returns (Field.Type) {\\n        Field.Type[] memory inputs = new Field.Type[](1);\\n        inputs[0] = m;\\n        return hash_internal(constants, inputs, 1, false);\\n    }\\n\\n    function hash_2(\\n        Poseidon2Lib.Constants memory constants,\\n        Field.Type m1,\\n        Field.Type m2\\n    ) internal view returns (Field.Type) {\\n        Field.Type[] memory inputs = new Field.Type[](2);\\n        inputs[0] = m1;\\n        inputs[1] = m2;\\n        return hash_internal(constants, inputs, 2, false);\\n    }\\n\\n    function hash_3(\\n        Poseidon2Lib.Constants memory constants,\\n        Field.Type m1,\\n        Field.Type m2,\\n        Field.Type m3\\n    ) internal view returns (Field.Type) {\\n        Field.Type[] memory inputs = new Field.Type[](3);\\n        inputs[0] = m1;\\n        inputs[1] = m2;\\n        inputs[2] = m3;\\n        return hash_internal(constants, inputs, 3, false);\\n    }\\n\\n    /**\\n     * Internal methods for hashing\\n     */\\n    function generate_iv(\\n        uint256 input_length\\n    ) internal view returns (Field.Type) {\\n        return Field.Type.wrap(input_length << 64);\\n    }\\n\\n    function hash_internal(\\n        Poseidon2Lib.Constants memory constants,\\n        Field.Type[] memory input,\\n        uint256 std_input_length,\\n        bool is_variable_length\\n    ) internal view returns (Field.Type) {\\n        Poseidon2Lib.Sponge memory sponge = new_poseidon2(\\n            generate_iv(input.length),\\n            constants\\n        );\\n\\n        for (uint256 i; i < input.length; i++) {\\n            if (i < std_input_length) {\\n                sponge.absorb(input[i]);\\n            }\\n        }\\n\\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\\n        // fixed-length and variable-length hashes do not collide)\\n        if (is_variable_length) {\\n            sponge.absorb(Field.Type.wrap(1));\\n        }\\n        return sponge.squeeze();\\n    }\\n\\n    function new_poseidon2(\\n        Field.Type iv,\\n        Constants memory constants\\n    ) private view returns (Poseidon2Lib.Sponge memory) {\\n        Poseidon2Lib.Sponge memory result = Poseidon2Lib.Sponge({\\n            iv: iv,\\n            cache: [Field.Type.wrap(0), Field.Type.wrap(0), Field.Type.wrap(0)],\\n            state: [\\n                Field.Type.wrap(0),\\n                Field.Type.wrap(0),\\n                Field.Type.wrap(0),\\n                Field.Type.wrap(0)\\n            ],\\n            cache_size: 0,\\n            squeeze_mode: false,\\n            constants: constants\\n        });\\n        result.state[RATE] = iv;\\n        return result;\\n    }\\n\\n    function perform_duplex(\\n        Poseidon2Lib.Sponge memory self\\n    ) internal view returns (Field.Type[RATE] memory) {\\n        // zero-pad the cache\\n        for (uint256 i; i < RATE; i++) {\\n            if (i >= self.cache_size) {\\n                self.cache[i] = Field.Type.wrap(0);\\n            }\\n        }\\n\\n        // add the cache into sponge state\\n        for (uint256 i; i < RATE; i++) {\\n            self.state[i] = self.state[i].add(self.cache[i]);\\n        }\\n        self.state = permutation(\\n            self.state,\\n            self.constants.internal_matrix_diagonal,\\n            self.constants.round_constant\\n        );\\n        // return `RATE` number of field elements from the sponge state.\\n        Field.Type[RATE] memory result = [\\n            Field.Type.wrap(0),\\n            Field.Type.wrap(0),\\n            Field.Type.wrap(0)\\n        ];\\n        for (uint256 i; i < RATE; i++) {\\n            result[i] = self.state[i];\\n        }\\n        return result;\\n    }\\n\\n    function absorb(\\n        Poseidon2Lib.Sponge memory self,\\n        Field.Type input\\n    ) internal view {\\n        if ((!self.squeeze_mode) && (self.cache_size == RATE)) {\\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\\n            self.perform_duplex();\\n            self.cache[0] = input;\\n            self.cache_size = 1;\\n        } else if ((!self.squeeze_mode) && (self.cache_size != RATE)) {\\n            // If we're absorbing, and the cache is not full, add the input into the cache\\n            self.cache[self.cache_size] = input;\\n            self.cache_size += 1;\\n        }\\n    }\\n\\n    function squeeze(\\n        Poseidon2Lib.Sponge memory self\\n    ) internal view returns (Field.Type) {\\n        if (!self.squeeze_mode) {\\n            // If we're in absorb mode, apply sponge permutation to compress the cache, populate cache with compressed\\n            // state and switch to squeeze mode. Note: this code block will execute if the previous `if` condition was\\n            // matched\\n            Field.Type[RATE] memory new_output_elements = self.perform_duplex();\\n            self.squeeze_mode = true;\\n            for (uint256 i; i < RATE; i++) {\\n                self.cache[i] = new_output_elements[i];\\n            }\\n            self.cache_size = RATE;\\n        }\\n        // By this point, we should have a non-empty cache. Pop one item off the top of the cache and return it.\\n        Field.Type result = self.cache[0];\\n        for (uint256 i = 1; i < RATE; i++) {\\n            if (i < self.cache_size) {\\n                self.cache[i - 1] = self.cache[i];\\n            }\\n        }\\n\\n        self.cache_size -= 1;\\n        self.cache[self.cache_size] = Field.Type.wrap(0);\\n        return result;\\n    }\\n\\n    function print_state(\\n        Field.Type[4] memory inputs,\\n        string memory s,\\n        uint num\\n    ) internal view {\\n        // console.log(\\\"State\\\", s, num);\\n        for (uint256 i; i < 4; i++) {\\n            print_field(inputs[i]);\\n        }\\n    }\\n\\n    function print_field(Field.Type inp) internal view {\\n        // console.logBytes32(bytes32(Field.Type.unwrap(inp)));\\n    }\\n\\n    function permutation(\\n        Field.Type[4] memory inputs,\\n        Field.Type[4] memory internal_matrix_diagonal,\\n        Field.Type[4][64] memory round_constant\\n    ) private view returns (Field.Type[4] memory) {\\n        // Read witness assignments\\n        Field.Type[4] memory state = [\\n            Field.Type.wrap(0),\\n            Field.Type.wrap(0),\\n            Field.Type.wrap(0),\\n            Field.Type.wrap(0)\\n        ];\\n        for (uint256 i; i < 4; i++) {\\n            state[i] = inputs[i];\\n        }\\n\\n        print_state(state, \\\"Initial state\\\", 0);\\n\\n        // Apply 1st linear layer\\n        matrix_multiplication_4x4(state);\\n\\n        print_state(state, \\\"After matrix multiplication\\\", 0);\\n\\n        // First set of external rounds\\n        uint256 rf_first = rounds_f / 2;\\n        for (uint256 r; r < rf_first; r++) {\\n            add_round_constants(state, round_constant, r);\\n            // print_state(state, \\\"add round constants\\\", r);\\n            s_box(state);\\n            // print_state(state, \\\"s_box\\\", r);\\n            matrix_multiplication_4x4(state);\\n            // print_state(state, \\\"matrix_multiplication_4x4\\\", r);\\n        }\\n\\n        print_state(state, \\\"after first\\\", 0);\\n\\n        // Internal rounds\\n        uint256 p_end = rf_first + rounds_p;\\n        for (uint256 r = rf_first; r < p_end; r++) {\\n            state[0] = state[0].add(round_constant[r][0]);\\n            state[0] = single_box(state[0]);\\n            internal_m_multiplication(state, internal_matrix_diagonal);\\n            print_state(state, \\\"for loop after internm\\\", r);\\n        }\\n\\n        print_state(state, \\\"after second\\\", 0);\\n\\n        // Remaining external rounds\\n        uint256 num_rounds = rounds_f + rounds_p;\\n\\n        for (uint256 r = p_end; r < num_rounds; r++) {\\n            add_round_constants(state, round_constant, r);\\n            s_box(state);\\n            matrix_multiplication_4x4(state);\\n        }\\n\\n        print_state(state, \\\"final third after all rounds\\\", 0);\\n\\n        return state;\\n    }\\n\\n    function single_box(Field.Type x) private view returns (Field.Type) {\\n        // console.log(\\\"singlebox\\\");\\n        // print_field(x);\\n        Field.Type s = x.mul(x);\\n        // print_field(s);\\n        // print_field(s.mul(s));\\n        // print_field(s.mul(s).mul(x));\\n        // console.log(\\\"singlebox done\\\");\\n        return s.mul(s).mul(x);\\n    }\\n\\n    function s_box(Field.Type[4] memory input) private view {\\n        for (uint256 i; i < 4; i++) {\\n            // console.log(\\\"singlebox\\\");\\n            // print_field(input[i]);\\n            input[i] = single_box(input[i]);\\n            // print_field(input[i]);\\n        }\\n    }\\n\\n    function add_round_constants(\\n        Field.Type[4] memory state,\\n        Field.Type[4][64] memory round_constant,\\n        uint256 round\\n    ) private view {\\n        for (uint256 i; i < 4; i++) {\\n            state[i] = state[i].add(round_constant[round][i]);\\n        }\\n    }\\n\\n    function matrix_multiplication_4x4(\\n        Field.Type[4] memory input\\n    ) private view {\\n        Field.Type t0 = input[0].add(input[1]); // A + B\\n        Field.Type t1 = input[2].add(input[3]); // C + D\\n        Field.Type t2 = input[1].add(input[1]); // 2B\\n        t2 = t2.add(t1); // 2B + C + D\\n        Field.Type t3 = input[3].add(input[3]); // 2D\\n        t3 = t3.add(t0); // 2D + A + B\\n        Field.Type t4 = t1.add(t1);\\n        t4 = t4.add(t4);\\n        t4 = t4.add(t3); // A + B + 4C + 6D\\n        Field.Type t5 = t0.add(t0);\\n        t5 = t5.add(t5);\\n        t5 = t5.add(t2); // 4A + 6B + C + D\\n        Field.Type t6 = t3.add(t5); // 5A + 7B + C + 3D\\n        Field.Type t7 = t2.add(t4); // A + 3B + 5C + 7D\\n        input[0] = t6;\\n        input[1] = t5;\\n        input[2] = t7;\\n        input[3] = t4;\\n    }\\n\\n    function internal_m_multiplication(\\n        Field.Type[4] memory input,\\n        Field.Type[4] memory internal_matrix_diagonal\\n    ) private view {\\n        Field.Type sum = Field.Type.wrap(0);\\n        for (uint256 i; i < 4; i++) {\\n            sum = sum.add(input[i]);\\n        }\\n        for (uint256 i; i < 4; i++) {\\n            input[i] = input[i].mul(internal_matrix_diagonal[i]);\\n            input[i] = input[i].add(sum);\\n        }\\n    }\\n\\n    function load() internal view returns (Constants memory constants) {\\n        constants = Constants({\\n            internal_matrix_diagonal: [\\n                Field.Type.wrap(\\n                    0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7\\n                ),\\n                Field.Type.wrap(\\n                    0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b\\n                ),\\n                Field.Type.wrap(\\n                    0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15\\n                ),\\n                Field.Type.wrap(\\n                    0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b\\n                )\\n            ],\\n            round_constant: [\\n                [\\n                    Field.Type.wrap(\\n                        0x19b849f69450b06848da1d39bd5e4a4302bb86744edc26238b0878e269ed23e5\\n                    ),\\n                    Field.Type.wrap(\\n                        0x265ddfe127dd51bd7239347b758f0a1320eb2cc7450acc1dad47f80c8dcf34d6\\n                    ),\\n                    Field.Type.wrap(\\n                        0x199750ec472f1809e0f66a545e1e51624108ac845015c2aa3dfc36bab497d8aa\\n                    ),\\n                    Field.Type.wrap(\\n                        0x157ff3fe65ac7208110f06a5f74302b14d743ea25067f0ffd032f787c7f1cdf8\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2e49c43c4569dd9c5fd35ac45fca33f10b15c590692f8beefe18f4896ac94902\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0e35fb89981890520d4aef2b6d6506c3cb2f0b6973c24fa82731345ffa2d1f1e\\n                    ),\\n                    Field.Type.wrap(\\n                        0x251ad47cb15c4f1105f109ae5e944f1ba9d9e7806d667ffec6fe723002e0b996\\n                    ),\\n                    Field.Type.wrap(\\n                        0x13da07dc64d428369873e97160234641f8beb56fdd05e5f3563fa39d9c22df4e\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0c009b84e650e6d23dc00c7dccef7483a553939689d350cd46e7b89055fd4738\\n                    ),\\n                    Field.Type.wrap(\\n                        0x011f16b1c63a854f01992e3956f42d8b04eb650c6d535eb0203dec74befdca06\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0ed69e5e383a688f209d9a561daa79612f3f78d0467ad45485df07093f367549\\n                    ),\\n                    Field.Type.wrap(\\n                        0x04dba94a7b0ce9e221acad41472b6bbe3aec507f5eb3d33f463672264c9f789b\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0a3f2637d840f3a16eb094271c9d237b6036757d4bb50bf7ce732ff1d4fa28e8\\n                    ),\\n                    Field.Type.wrap(\\n                        0x259a666f129eea198f8a1c502fdb38fa39b1f075569564b6e54a485d1182323f\\n                    ),\\n                    Field.Type.wrap(\\n                        0x28bf7459c9b2f4c6d8e7d06a4ee3a47f7745d4271038e5157a32fdf7ede0d6a1\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0a1ca941f057037526ea200f489be8d4c37c85bbcce6a2aeec91bd6941432447\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0c6f8f958be0e93053d7fd4fc54512855535ed1539f051dcb43a26fd926361cf\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x123106a93cd17578d426e8128ac9d90aa9e8a00708e296e084dd57e69caaf811\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x26e1ba52ad9285d97dd3ab52f8e840085e8fa83ff1e8f1877b074867cd2dee75\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1cb55cad7bd133de18a64c5c47b9c97cbe4d8b7bf9e095864471537e6a4ae2c5\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1dcd73e46acd8f8e0e2c7ce04bde7f6d2a53043d5060a41c7143f08e6e9055d0\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x011003e32f6d9c66f5852f05474a4def0cda294a0eb4e9b9b12b9bb4512e5574\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2b1e809ac1d10ab29ad5f20d03a57dfebadfe5903f58bafed7c508dd2287ae8c\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2539de1785b735999fb4dac35ee17ed0ef995d05ab2fc5faeaa69ae87bcec0a5\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0c246c5a2ef8ee0126497f222b3e0a0ef4e1c3d41c86d46e43982cb11d77951d\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x192089c4974f68e95408148f7c0632edbb09e6a6ad1a1c2f3f0305f5d03b527b\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1eae0ad8ab68b2f06a0ee36eeb0d0c058529097d91096b756d8fdc2fb5a60d85\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x179190e5d0e22179e46f8282872abc88db6e2fdc0dee99e69768bd98c5d06bfb\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x29bb9e2c9076732576e9a81c7ac4b83214528f7db00f31bf6cafe794a9b3cd1c\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x225d394e42207599403efd0c2464a90d52652645882aac35b10e590e6e691e08\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x064760623c25c8cf753d238055b444532be13557451c087de09efd454b23fd59\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x10ba3a0e01df92e87f301c4b716d8a394d67f4bf42a75c10922910a78f6b5b87\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0e070bf53f8451b24f9c6e96b0c2a801cb511bc0c242eb9d361b77693f21471c\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1b94cd61b051b04dd39755ff93821a73ccd6cb11d2491d8aa7f921014de252fb\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1d7cb39bafb8c744e148787a2e70230f9d4e917d5713bb050487b5aa7d74070b\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2ec93189bd1ab4f69117d0fe980c80ff8785c2961829f701bb74ac1f303b17db\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2db366bfdd36d277a692bb825b86275beac404a19ae07a9082ea46bd83517926\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x062100eb485db06269655cf186a68532985275428450359adc99cec6960711b8\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0761d33c66614aaa570e7f1e8244ca1120243f92fa59e4f900c567bf41f5a59b\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x20fc411a114d13992c2705aa034e3f315d78608a0f7de4ccf7a72e494855ad0d\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x25b5c004a4bdfcb5add9ec4e9ab219ba102c67e8b3effb5fc3a30f317250bc5a\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x23b1822d278ed632a494e58f6df6f5ed038b186d8474155ad87e7dff62b37f4b\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x22734b4c5c3f9493606c4ba9012499bf0f14d13bfcfcccaa16102a29cc2f69e0\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x26c0c8fe09eb30b7e27a74dc33492347e5bdff409aa3610254413d3fad795ce5\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x070dd0ccb6bd7bbae88eac03fa1fbb26196be3083a809829bbd626df348ccad9\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x12b6595bdb329b6fb043ba78bb28c3bec2c0a6de46d8c5ad6067c4ebfd4250da\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x248d97d7f76283d63bec30e7a5876c11c06fca9b275c671c5e33d95bb7e8d729\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1a306d439d463b0816fc6fd64cc939318b45eb759ddde4aa106d15d9bd9baaaa\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x28a8f8372e3c38daced7c00421cb4621f4f1b54ddc27821b0d62d3d6ec7c56cf\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0094975717f9a8a8bb35152f24d43294071ce320c829f388bc852183e1e2ce7e\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x04d5ee4c3aa78f7d80fde60d716480d3593f74d4f653ae83f4103246db2e8d65\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2a6cf5e9aa03d4336349ad6fb8ed2269c7bef54b8822cc76d08495c12efde187\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2304d31eaab960ba9274da43e19ddeb7f792180808fd6e43baae48d7efcba3f3\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x03fd9ac865a4b2a6d5e7009785817249bff08a7e0726fcb4e1c11d39d199f0b0\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x00b7258ded52bbda2248404d55ee5044798afc3a209193073f7954d4d63b0b64\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x159f81ada0771799ec38fca2d4bf65ebb13d3a74f3298db36272c5ca65e92d9a\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1ef90e67437fbc8550237a75bc28e3bb9000130ea25f0c5471e144cf4264431f\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1e65f838515e5ff0196b49aa41a2d2568df739bc176b08ec95a79ed82932e30d\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2b1b045def3a166cec6ce768d079ba74b18c844e570e1f826575c1068c94c33f\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0832e5753ceb0ff6402543b1109229c165dc2d73bef715e3f1c6e07c168bb173\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x02f614e9cedfb3dc6b762ae0a37d41bab1b841c2e8b6451bc5a8e3c390b6ad16\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0e2427d38bd46a60dd640b8e362cad967370ebb777bedff40f6a0be27e7ed705\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0493630b7c670b6deb7c84d414e7ce79049f0ec098c3c7c50768bbe29214a53a\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x22ead100e8e482674decdab17066c5a26bb1515355d5461a3dc06cc85327cea9\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x25b3e56e655b42cdaae2626ed2554d48583f1ae35626d04de5084e0b6d2a6f16\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1e32752ada8836ef5837a6cde8ff13dbb599c336349e4c584b4fdc0a0cf6f9d0\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2fa2a871c15a387cc50f68f6f3c3455b23c00995f05078f672a9864074d412e5\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x2f569b8a9a4424c9278e1db7311e889f54ccbf10661bab7fcd18e7c7a7d83505\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x044cb455110a8fdd531ade530234c518a7df93f7332ffd2144165374b246b43d\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x227808de93906d5d420246157f2e42b191fe8c90adfe118178ddc723a5319025\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x02fcca2934e046bc623adead873579865d03781ae090ad4a8579d2e7a6800355\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0ef915f0ac120b876abccceb344a1d36bad3f3c5ab91a8ddcbec2e060d8befac\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0000000000000000000000000000000000000000000000000000000000000000\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x1797130f4b7a3e1777eb757bc6f287f6ab0fb85f6be63b09f3b16ef2b1405d38\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0a76225dc04170ae3306c85abab59e608c7f497c20156d4d36c668555decc6e5\\n                    ),\\n                    Field.Type.wrap(\\n                        0x1fffb9ec1992d66ba1e77a7b93209af6f8fa76d48acb664796174b5326a31a5c\\n                    ),\\n                    Field.Type.wrap(\\n                        0x25721c4fc15a3f2853b57c338fa538d85f8fbba6c6b9c6090611889b797b9c5f\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0c817fd42d5f7a41215e3d07ba197216adb4c3790705da95eb63b982bfcaf75a\\n                    ),\\n                    Field.Type.wrap(\\n                        0x13abe3f5239915d39f7e13c2c24970b6df8cf86ce00a22002bc15866e52b5a96\\n                    ),\\n                    Field.Type.wrap(\\n                        0x2106feea546224ea12ef7f39987a46c85c1bc3dc29bdbd7a92cd60acb4d391ce\\n                    ),\\n                    Field.Type.wrap(\\n                        0x21ca859468a746b6aaa79474a37dab49f1ca5a28c748bc7157e1b3345bb0f959\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x05ccd6255c1e6f0c5cf1f0df934194c62911d14d0321662a8f1a48999e34185b\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0f0e34a64b70a626e464d846674c4c8816c4fb267fe44fe6ea28678cb09490a4\\n                    ),\\n                    Field.Type.wrap(\\n                        0x0558531a4e25470c6157794ca36d0e9647dbfcfe350d64838f5b1a8a2de0d4bf\\n                    ),\\n                    Field.Type.wrap(\\n                        0x09d3dca9173ed2faceea125157683d18924cadad3f655a60b72f5864961f1455\\n                    )\\n                ],\\n                [\\n                    Field.Type.wrap(\\n                        0x0328cbd54e8c0913493f866ed03d218bf23f92d68aaec48617d4c722e5bd4335\\n                    ),\\n                    Field.Type.wrap(\\n                        0x2bf07216e2aff0a223a487b1a7094e07e79e7bcc9798c648ee3347dd5329d34b\\n                    ),\\n                    Field.Type.wrap(\\n                        0x1daf345a58006b736499c583cb76c316d6f78ed6a6dffc82111e11a63fe412df\\n                    ),\\n                    Field.Type.wrap(\\n                        0x176563472456aaa746b694c60e1823611ef39039b2edc7ff391e6f2293d2c404\\n                    )\\n                ]\\n            ]\\n        });\\n    }\\n}\\n\",\"keccak256\":\"0xe3e8d009f067b4c902b663b358f2f43adafedb8e6f8db8aae3024377cbc86b93\",\"license\":\"MIT\"},\"contracts/verifiers/DepositVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.21;\\n\\nuint256 constant N = 256;\\nuint256 constant LOG_N = 8;\\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 3;\\nlibrary HonkVerificationKey {\\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\\n            circuitSize: uint256(256),\\n            logCircuitSize: uint256(8),\\n            publicInputsSize: uint256(3),\\n            ql: Honk.G1Point({ \\n               x: uint256(0x0706286ec8caeaf9a630bbb670fc97508fd6af1fa6a98ea51122cdf981e184c4),\\n               y: uint256(0x1d0dd40a1b56a77dfc3e7f3512765f7884bf76d8abe61655a26d496b75c3c6ce)\\n            }),\\n            qr: Honk.G1Point({ \\n               x: uint256(0x0d6425ab78b54bdc2e8420fe0d9515520d37a1f6d04dece2f57af185179e6a61),\\n               y: uint256(0x100a4864a063b3af3c46bcd8f6673d65a96da80bfc434ed118dab343be4f927a)\\n            }),\\n            qo: Honk.G1Point({ \\n               x: uint256(0x0ade7885903164e54a3ccc2429615001c0ff3e0ec5a4acb371a25d5e15d670e9),\\n               y: uint256(0x0522e70c6ed93b9b7578729b8310c267d0deb1c9695c3a233dd997ba701f67af)\\n            }),\\n            q4: Honk.G1Point({ \\n               x: uint256(0x22d2dc9c8a8d8d683f0e911d1d07bc066c0933c107ef9564fdca1cf2559d1a00),\\n               y: uint256(0x2b0dcf7d83ecf249f51717d2a2aac1af660c2eec742b86551a361ce26382c769)\\n            }),\\n            qm: Honk.G1Point({ \\n               x: uint256(0x08dbbddedaf64ee8decef3c386e365712391deb46d24ee93929354b9481c99cd),\\n               y: uint256(0x1ef73310e1a629ee1dca12b4525b84856d4b32af4379975ce3abf9b029d45efe)\\n            }),\\n            qc: Honk.G1Point({ \\n               x: uint256(0x180253fd74458f495d11e366220e0b8b1ace2ea1acd2460888383b402273bb7a),\\n               y: uint256(0x152f2175d510f4c6b7dd34dcd65c1565eebe2a46bf6bf5d3b730364b9f528f51)\\n            }),\\n            qArith: Honk.G1Point({ \\n               x: uint256(0x1ea52a7c58f78261ca684a542381ead453ce8dbceb58c95e3564b8d67c518e1d),\\n               y: uint256(0x09875c09d2c36ba3caab25772ec7c0bf1d5e81447c510e06e1b88920aa250d36)\\n            }),\\n            qDeltaRange: Honk.G1Point({ \\n               x: uint256(0x1f497cbf5284ff29a2d336e599199929a17181c7934fc3fdbd352eac5cb521b9),\\n               y: uint256(0x13ea38a0bd2aa751a490a724fac818072bd9c0c6beda1fdee6d4ff0432ba9e1b)\\n            }),\\n            qElliptic: Honk.G1Point({ \\n               x: uint256(0x0384638dd92e0abd1d0455ad4b429bee5960e2f4e0eef28e946561e55a4d9807),\\n               y: uint256(0x0edd0d417777cdfe14def171f26ffd8849f800a9aa2563c403966bb405f3a5d3)\\n            }),\\n            qAux: Honk.G1Point({ \\n               x: uint256(0x26131fc1251eb7746e72a19f9f9b250f079744ec926fc2a41fb8a0489d1fb444),\\n               y: uint256(0x03588be01690f20304e3d200c3b81a867f03abc37431898437d94c0822213fbb)\\n            }),\\n            qLookup: Honk.G1Point({ \\n               x: uint256(0x2594d00a131b347f472a021eac09e25eacba35749a9ba8f8c7f4a726ff63a910),\\n               y: uint256(0x2499be5abe1cf5463534a1d0613f82449f1989f1186f2d0b67295bda7f8a0f55)\\n            }),\\n            qPoseidon2External: Honk.G1Point({ \\n               x: uint256(0x2342ad3c9f80d265726011de0e98f729369164805b4229a3bf7e04c500d94cdf),\\n               y: uint256(0x1756f15def234f58df4a8f68b4f10b26ecda7e6ecebaa8862001746309ea9248)\\n            }),\\n            qPoseidon2Internal: Honk.G1Point({ \\n               x: uint256(0x2c20e6cb1cfaf478d9673a371652e5133aed49a04ffe951f2dc443984785c946),\\n               y: uint256(0x1baeded16e0fdb3baf90557e93d7dcbfd0761e64d7967bda2811966fbbfaa636)\\n            }),\\n            s1: Honk.G1Point({ \\n               x: uint256(0x138d1fb08ddfa477283ae2dec71c3ed717dae8411f3f37b27bf5fe9488d1e9be),\\n               y: uint256(0x02676f66a1177457c55d836bfdf72f4d0d9b367e008e96f9ec265085bf8c1d20)\\n            }),\\n            s2: Honk.G1Point({ \\n               x: uint256(0x1882013328407779c80f6f7065e661c4a9ef0f06af192c10b13c5e2601a1f8d3),\\n               y: uint256(0x02ddba1dcb884d05cf49175fcef625cfadffdf89ed5ce3ae5db1f167da530a54)\\n            }),\\n            s3: Honk.G1Point({ \\n               x: uint256(0x198a1735a9fe5fb6fbaa6d1b2e25108d1e3435ac9d56b8187c88de53b48b7bb9),\\n               y: uint256(0x1fa57aeaa19667215424dbbfaaac52f9d480a3128fe09f493aa747a1b0048542)\\n            }),\\n            s4: Honk.G1Point({ \\n               x: uint256(0x2b95f58e44085fde26fe49518d4608b25dc00c111ded19ae4b89737e3bccf3c9),\\n               y: uint256(0x03b870c5743e68c8544ab4818213dede89ad8e640ed43a6538d1eeab011ae16b)\\n            }),\\n            t1: Honk.G1Point({ \\n               x: uint256(0x1fb7c5d789d32e42a08e41296286139f603c7607ce186d0cce6e472dfe021473),\\n               y: uint256(0x09d80a7c25410f51739aadc54ad122874e4551efc35bd23807ecf23a79ef418a)\\n            }),\\n            t2: Honk.G1Point({ \\n               x: uint256(0x108788a192d4d3c38e445629bb550acf212f9b2049b6fb1cc76900bd482fb5b0),\\n               y: uint256(0x195266ac0788c227762333892ad282a4679450ae72e8e8b4a1ead0e63d4f4e04)\\n            }),\\n            t3: Honk.G1Point({ \\n               x: uint256(0x192a87ba208ab02639f2453bde4d15e8c489e522f16c07fd8e312a10142484d8),\\n               y: uint256(0x0978af3f655d807c77436eec1810420c3170702a20ae32933baa816253797b15)\\n            }),\\n            t4: Honk.G1Point({ \\n               x: uint256(0x1a552bd8d3265d1f23e7ff166cf20fffa5c0688c867cfd3a2ea65452d8ad60a4),\\n               y: uint256(0x1cb1414f7b9f8edb7c7a0d61f66e24e632a4050d9b3be0d6c35109aa99693039)\\n            }),\\n            id1: Honk.G1Point({ \\n               x: uint256(0x01ae22bf031b8c1930dec03b8f4704c49c28cd98474dca7d07875473949ef998),\\n               y: uint256(0x03f6eee33948202497991c8673119d4abf66d70d68481c6b80976a643a5b9325)\\n            }),\\n            id2: Honk.G1Point({ \\n               x: uint256(0x22446f485968f51280dc48cc30abf8171154f4910b8798ba65479bdf88c8c461),\\n               y: uint256(0x0e13564c484a1b26820e2601e39196e1b936eb5dd4b9cfeb2cd330b28ff915f3)\\n            }),\\n            id3: Honk.G1Point({ \\n               x: uint256(0x1b5ff984e06c61d45bbe6f3f6a0e799d975e986b0916547be10ca43147839e02),\\n               y: uint256(0x25e0f2d4bb40608a68f3ee8da180c87ca8c87bc35ea252b4a68aa64e54a36bf6)\\n            }),\\n            id4: Honk.G1Point({ \\n               x: uint256(0x2cab3861baed5b5ccd0830a5e20c9aab77cd8f4f568bf79b0376d9036133c577),\\n               y: uint256(0x07dd4372e0ddf9927f4e175f9d2472040e16b1dbb7661e1abb1090ccb205dd99)\\n            }),\\n            lagrangeFirst: Honk.G1Point({ \\n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\\n            }),\\n            lagrangeLast: Honk.G1Point({ \\n               x: uint256(0x29c8a94ab2f7f2c7110344ab367552bfe2cf1e4b374083e44458530da00b67f6),\\n               y: uint256(0x2c5020e20f85671e916492988dd560862e6cd38a99501c4d5d3ff71b72a79891)\\n            })\\n        });\\n        return vk;\\n    }\\n}\\n\\npragma solidity ^0.8.27;\\n\\ntype Fr is uint256;\\n\\nusing { add as + } for Fr global;\\nusing { sub as - } for Fr global;\\nusing { mul as * } for Fr global;\\nusing { exp as ^ } for Fr global;\\nusing { notEqual as != } for Fr global;\\nusing { equal as == } for Fr global;\\n\\nuint256 constant MODULUS =\\n    21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\\n\\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\\n\\n// Instantiation\\nlibrary FrLib\\n{\\n    function from(uint256 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(value % MODULUS);\\n    }\\n\\n    function fromBytes32(bytes32 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(uint256(value) % MODULUS);\\n    }\\n\\n    function toBytes32(Fr value) internal pure returns(bytes32)\\n    {\\n        return bytes32(Fr.unwrap(value));\\n    }\\n\\n    function invert(Fr value) internal view returns(Fr)\\n    {\\n        uint256 v = Fr.unwrap(value);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), v)\\n            mstore(add(free, 0x80), sub(MODULUS, 2))\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function pow(Fr base, uint256 v) internal view returns(Fr)\\n    {\\n        uint256 b = Fr.unwrap(base);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), b)\\n            mstore(add(free, 0x80), v)\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function div(Fr numerator, Fr denominator) internal view returns(Fr)\\n    {\\n        return numerator * invert(denominator);\\n    }\\n\\n    function sqr(Fr value) internal pure returns (Fr) {\\n        return value * value;\\n    }\\n\\n    function unwrap(Fr value) internal pure returns (uint256) {\\n        return Fr.unwrap(value);\\n    }\\n\\n    function neg(Fr value) internal pure returns (Fr) {\\n        return Fr.wrap(MODULUS - Fr.unwrap(value));\\n    }\\n}\\n\\n// Free functions\\nfunction add(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction mul(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction sub(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction exp(Fr base, Fr exponent) pure returns(Fr)\\n{\\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\\n\\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\\n        base = base * base;\\n    }\\n    return base;\\n}\\n\\nfunction notEqual(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) != Fr.unwrap(b);\\n}\\n\\nfunction equal(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) == Fr.unwrap(b);\\n}\\n\\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\\n\\nuint256 constant NUMBER_OF_SUBRELATIONS = 26;\\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\\nuint256 constant NUMBER_OF_ENTITIES = 40;\\nuint256 constant NUMBER_UNSHIFTED = 35;\\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\\n\\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\\nuint256 constant NUMBER_OF_ALPHAS = 25;\\n\\n// Prime field order\\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\\nuint256 constant P = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order, F_r\\n\\n// ENUM FOR WIRES\\nenum WIRE {\\n    Q_M,\\n    Q_C,\\n    Q_L,\\n    Q_R,\\n    Q_O,\\n    Q_4,\\n    Q_LOOKUP,\\n    Q_ARITH,\\n    Q_RANGE,\\n    Q_ELLIPTIC,\\n    Q_AUX,\\n    Q_POSEIDON2_EXTERNAL,\\n    Q_POSEIDON2_INTERNAL,\\n    SIGMA_1,\\n    SIGMA_2,\\n    SIGMA_3,\\n    SIGMA_4,\\n    ID_1,\\n    ID_2,\\n    ID_3,\\n    ID_4,\\n    TABLE_1,\\n    TABLE_2,\\n    TABLE_3,\\n    TABLE_4,\\n    LAGRANGE_FIRST,\\n    LAGRANGE_LAST,\\n    W_L,\\n    W_R,\\n    W_O,\\n    W_4,\\n    Z_PERM,\\n    LOOKUP_INVERSES,\\n    LOOKUP_READ_COUNTS,\\n    LOOKUP_READ_TAGS,\\n    W_L_SHIFT,\\n    W_R_SHIFT,\\n    W_O_SHIFT,\\n    W_4_SHIFT,\\n    Z_PERM_SHIFT\\n}\\n\\nlibrary Honk {\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    struct G1ProofPoint {\\n        uint256 x_0;\\n        uint256 x_1;\\n        uint256 y_0;\\n        uint256 y_1;\\n    }\\n\\n    struct VerificationKey {\\n        // Misc Params\\n        uint256 circuitSize;\\n        uint256 logCircuitSize;\\n        uint256 publicInputsSize;\\n        // Selectors\\n        G1Point qm;\\n        G1Point qc;\\n        G1Point ql;\\n        G1Point qr;\\n        G1Point qo;\\n        G1Point q4;\\n        G1Point qLookup; // Lookup\\n        G1Point qArith; // Arithmetic widget\\n        G1Point qDeltaRange; // Delta Range sort\\n        G1Point qAux; // Auxillary\\n        G1Point qElliptic; // Auxillary\\n        G1Point qPoseidon2External;\\n        G1Point qPoseidon2Internal;\\n        // Copy cnstraints\\n        G1Point s1;\\n        G1Point s2;\\n        G1Point s3;\\n        G1Point s4;\\n        // Copy identity\\n        G1Point id1;\\n        G1Point id2;\\n        G1Point id3;\\n        G1Point id4;\\n        // Precomputed lookup table\\n        G1Point t1;\\n        G1Point t2;\\n        G1Point t3;\\n        G1Point t4;\\n        // Fixed first and last\\n        G1Point lagrangeFirst;\\n        G1Point lagrangeLast;\\n    }\\n\\n    struct RelationParameters {\\n        // challenges\\n        Fr eta;\\n        Fr etaTwo;\\n        Fr etaThree;\\n        Fr beta;\\n        Fr gamma;\\n        // derived\\n        Fr publicInputsDelta;\\n    }\\n\\n\\n    struct Proof {\\n        // Free wires\\n        Honk.G1ProofPoint w1;\\n        Honk.G1ProofPoint w2;\\n        Honk.G1ProofPoint w3;\\n        Honk.G1ProofPoint w4;\\n        // Lookup helpers - Permutations\\n        Honk.G1ProofPoint zPerm;\\n        // Lookup helpers - logup\\n        Honk.G1ProofPoint lookupReadCounts;\\n        Honk.G1ProofPoint lookupReadTags;\\n        Honk.G1ProofPoint lookupInverses;\\n        // Sumcheck\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\\n        // Shplemini\\n        Honk.G1ProofPoint[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\\n        Honk.G1ProofPoint shplonkQ;\\n        Honk.G1ProofPoint kzgQuotient;\\n    }\\n}\\n\\n// Transcript library to generate fiat shamir challenges\\nstruct Transcript {\\n    // Oink\\n    Honk.RelationParameters relationParameters;\\n    Fr[NUMBER_OF_ALPHAS] alphas;\\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\\n    // Sumcheck\\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\\n    // Gemini\\n    Fr rho;\\n    Fr geminiR;\\n    // Shplonk\\n    Fr shplonkNu;\\n    Fr shplonkZ;\\n}\\n\\nlibrary TranscriptLib {\\n    function generateTranscript(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Transcript memory t)\\n    {\\n        Fr previousChallenge;\\n        (t.relationParameters, previousChallenge) =\\n            generateRelationParametersChallenges(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset, previousChallenge);\\n\\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\\n\\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge);\\n\\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge);\\n\\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\\n\\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge);\\n\\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge);\\n\\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\\n\\n        return t;\\n    }\\n\\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        uint256 hi = challengeU256 >> 128;\\n        first = FrLib.fromBytes32(bytes32(lo));\\n        second = FrLib.fromBytes32(bytes32(hi));\\n    }\\n\\n    function generateRelationParametersChallenges(\\n        Honk.Proof memory proof,\\n        bytes32[] calldata publicInputs,\\n        uint256 circuitSize,\\n        uint256 publicInputsSize,\\n        uint256 pubInputsOffset,\\n        Fr previousChallenge\\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\\n            generateEtaChallenge(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset);\\n\\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\\n\\n    }\\n\\n    function generateEtaChallenge(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge)\\n    {\\n        bytes32[] memory round0 = new bytes32[](3 + publicInputsSize + 12);\\n        round0[0] = bytes32(circuitSize);\\n        round0[1] = bytes32(publicInputsSize);\\n        round0[2] = bytes32(pubInputsOffset);\\n        for (uint256 i = 0; i < publicInputsSize; i++) {\\n            round0[3 + i] = bytes32(publicInputs[i]);\\n        }\\n\\n        // Create the first challenge\\n        // Note: w4 is added to the challenge later on\\n        round0[3 + publicInputsSize] = bytes32(proof.w1.x_0);\\n        round0[3 + publicInputsSize + 1] = bytes32(proof.w1.x_1);\\n        round0[3 + publicInputsSize + 2] = bytes32(proof.w1.y_0);\\n        round0[3 + publicInputsSize + 3] = bytes32(proof.w1.y_1);\\n        round0[3 + publicInputsSize + 4] = bytes32(proof.w2.x_0);\\n        round0[3 + publicInputsSize + 5] = bytes32(proof.w2.x_1);\\n        round0[3 + publicInputsSize + 6] = bytes32(proof.w2.y_0);\\n        round0[3 + publicInputsSize + 7] = bytes32(proof.w2.y_1);\\n        round0[3 + publicInputsSize + 8] = bytes32(proof.w3.x_0);\\n        round0[3 + publicInputsSize + 9] = bytes32(proof.w3.x_1);\\n        round0[3 + publicInputsSize + 10] = bytes32(proof.w3.y_0);\\n        round0[3 + publicInputsSize + 11] = bytes32(proof.w3.y_1);\\n\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\\n        (eta, etaTwo) = splitChallenge(previousChallenge);\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n        Fr unused;\\n        (etaThree, unused) = splitChallenge(previousChallenge);\\n    }\\n\\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\\n    {\\n        bytes32[13] memory round1;\\n        round1[0] = FrLib.toBytes32(previousChallenge);\\n        round1[1] = bytes32(proof.lookupReadCounts.x_0);\\n        round1[2] = bytes32(proof.lookupReadCounts.x_1);\\n        round1[3] = bytes32(proof.lookupReadCounts.y_0);\\n        round1[4] = bytes32(proof.lookupReadCounts.y_1);\\n        round1[5] = bytes32(proof.lookupReadTags.x_0);\\n        round1[6] = bytes32(proof.lookupReadTags.x_1);\\n        round1[7] = bytes32(proof.lookupReadTags.y_0);\\n        round1[8] = bytes32(proof.lookupReadTags.y_1);\\n        round1[9] = bytes32(proof.w4.x_0);\\n        round1[10] = bytes32(proof.w4.x_1);\\n        round1[11] = bytes32(proof.w4.y_0);\\n        round1[12] = bytes32(proof.w4.y_1);\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    // Alpha challenges non-linearise the gate contributions\\n    function generateAlphaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\\n    {\\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\\n        uint256[9] memory alpha0;\\n        alpha0[0] = Fr.unwrap(previousChallenge);\\n        alpha0[1] = proof.lookupInverses.x_0;\\n        alpha0[2] = proof.lookupInverses.x_1;\\n        alpha0[3] = proof.lookupInverses.y_0;\\n        alpha0[4] = proof.lookupInverses.y_1;\\n        alpha0[5] = proof.zPerm.x_0;\\n        alpha0[6] = proof.zPerm.x_1;\\n        alpha0[7] = proof.zPerm.y_0;\\n        alpha0[8] = proof.zPerm.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\\n        (alphas[0], alphas[1]) = splitChallenge(nextPreviousChallenge);\\n\\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS / 2; i++) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            (alphas[2 * i], alphas[2 * i + 1]) = splitChallenge(nextPreviousChallenge);\\n        }\\n        if (((NUMBER_OF_ALPHAS & 1) == 1) && (NUMBER_OF_ALPHAS > 2)) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            Fr unused;\\n            (alphas[NUMBER_OF_ALPHAS - 1], unused) = splitChallenge(nextPreviousChallenge);\\n        }\\n    }\\n\\n    function generateGateChallenges(Fr previousChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n            Fr unused;\\n            (gateChallenges[i], unused) = splitChallenge(previousChallenge);\\n        }\\n        nextPreviousChallenge = previousChallenge;\\n    }\\n\\n    function generateSumcheckChallenges(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\\n            univariateChal[0] = prevChallenge;\\n\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\\n            }\\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\\n            Fr unused;\\n            (sumcheckChallenges[i], unused) = splitChallenge(prevChallenge);\\n        }\\n        nextPreviousChallenge = prevChallenge;\\n    }\\n\\n    function generateRhoChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr rho, Fr nextPreviousChallenge)\\n    {\\n        Fr[NUMBER_OF_ENTITIES + 1] memory rhoChallengeElements;\\n        rhoChallengeElements[0] = prevChallenge;\\n\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            rhoChallengeElements[i + 1] = proof.sumcheckEvaluations[i];\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\\n        Fr unused;\\n        (rho, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateGeminiRChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr geminiR, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N - 1) * 4 + 1] memory gR;\\n        gR[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            gR[1 + i * 4] = proof.geminiFoldComms[i].x_0;\\n            gR[2 + i * 4] = proof.geminiFoldComms[i].x_1;\\n            gR[3 + i * 4] = proof.geminiFoldComms[i].y_0;\\n            gR[4 + i * 4] = proof.geminiFoldComms[i].y_1;\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\\n        Fr unused;\\n        (geminiR, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkNuChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N) + 1] memory shplonkNuChallengeElements;\\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            shplonkNuChallengeElements[i + 1] = Fr.unwrap(proof.geminiAEvaluations[i]);\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\\n        Fr unused;\\n        (shplonkNu, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkZChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\\n    {\\n        uint256[5] memory shplonkZChallengeElements;\\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        shplonkZChallengeElements[1] = proof.shplonkQ.x_0;\\n        shplonkZChallengeElements[2] = proof.shplonkQ.x_1;\\n        shplonkZChallengeElements[3] = proof.shplonkQ.y_0;\\n        shplonkZChallengeElements[4] = proof.shplonkQ.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\\n        Fr unused;\\n        (shplonkZ, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function loadProof(bytes calldata proof) internal pure returns (Honk.Proof memory p) {\\n        // Commitments\\n        p.w1 = bytesToG1ProofPoint(proof[0x0:0x80]);\\n\\n        p.w2 = bytesToG1ProofPoint(proof[0x80:0x100]);\\n        p.w3 = bytesToG1ProofPoint(proof[0x100:0x180]);\\n\\n        // Lookup / Permutation Helper Commitments\\n        p.lookupReadCounts = bytesToG1ProofPoint(proof[0x180:0x200]);\\n        p.lookupReadTags = bytesToG1ProofPoint(proof[0x200:0x280]);\\n        p.w4 = bytesToG1ProofPoint(proof[0x280:0x300]);\\n        p.lookupInverses = bytesToG1ProofPoint(proof[0x300:0x380]);\\n        p.zPerm = bytesToG1ProofPoint(proof[0x380:0x400]);\\n        uint256 boundary = 0x400;\\n\\n        // Sumcheck univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + 0x20]);\\n                boundary += 0x20;\\n            }\\n        }\\n        // Sumcheck evaluations\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Gemini\\n        // Read gemini fold univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            p.geminiFoldComms[i] = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n            boundary += 0x80;\\n        }\\n\\n        // Read gemini a evaluations\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Shplonk\\n        p.shplonkQ = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n        boundary = boundary + 0x80;\\n        // KZG\\n        p.kzgQuotient = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n    }\\n}\\n\\n\\n// Fr utility\\n\\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\\n    require(proofSection.length == 0x20, \\\"invalid bytes scalar\\\");\\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\\n}\\n\\n// EC Point utilities\\nfunction convertProofPoint(Honk.G1ProofPoint memory input) pure returns (Honk.G1Point memory) {\\n    return Honk.G1Point({x: input.x_0 | (input.x_1 << 136), y: input.y_0 | (input.y_1 << 136)});\\n}\\n\\nfunction bytesToG1ProofPoint(bytes calldata proofSection) pure returns (Honk.G1ProofPoint memory point) {\\n    require(proofSection.length == 0x80, \\\"invalid bytes point\\\");\\n    point = Honk.G1ProofPoint({\\n        x_0: uint256(bytes32(proofSection[0x00:0x20])),\\n        x_1: uint256(bytes32(proofSection[0x20:0x40])),\\n        y_0: uint256(bytes32(proofSection[0x40:0x60])),\\n        y_1: uint256(bytes32(proofSection[0x60:0x80]))\\n    });\\n}\\n\\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\\n    point.y = (Q - point.y) % Q;\\n    return point;\\n}\\n\\n function pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool) {\\n        bytes memory input = abi.encodePacked(\\n            rhs.x,\\n            rhs.y,\\n            // Fixed G1 point\\n            uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\\n            uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\\n            uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\\n            uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\\n            lhs.x,\\n            lhs.y,\\n            // G1 point from VK\\n            uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\\n            uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\\n            uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\\n            uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n        );\\n\\n        (bool success, bytes memory result) = address(0x08).staticcall(input);\\n        bool decodedResult = abi.decode(result, (bool));\\n        return success && decodedResult;\\n    }\\n\\n\\nlibrary RelationsLib {\\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\\n\\n    function accumulateRelationEvaluations(\\n         Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\\n        Fr powPartialEval\\n    ) internal pure returns (Fr accumulator) {\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\\n\\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateAuxillaryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\\n    }\\n\\n    /**\\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\\n     * editors, and thus is noisy.\\n     */\\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\\n        return p[uint256(_wire)];\\n    }\\n\\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    /**\\n     * Ultra Arithmetic Relation\\n     *\\n     */\\n    function accumulateArithmeticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        // Relation 0\\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\\n        {\\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\\n\\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\\n            accum = accum + (q_arith - Fr.wrap(1)) * wire(p, WIRE.W_4_SHIFT);\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[0] = accum;\\n        }\\n\\n        // Relation 1\\n        {\\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\\n            accum = accum * (q_arith - Fr.wrap(2));\\n            accum = accum * (q_arith - Fr.wrap(1));\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[1] = accum;\\n        }\\n    }\\n\\n    function accumulatePermutationRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr grand_product_numerator;\\n        Fr grand_product_denominator;\\n\\n        {\\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\\n\\n            grand_product_numerator = num;\\n        }\\n        {\\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\\n\\n            grand_product_denominator = den;\\n        }\\n\\n        // Contribution 2\\n        {\\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\\n\\n            acc = acc\\n                - (\\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\\n                        * grand_product_denominator\\n                );\\n            acc = acc * domainSep;\\n            evals[2] = acc;\\n        }\\n\\n        // Contribution 3\\n        {\\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\\n            evals[3] = acc;\\n        }\\n    }\\n\\n    function accumulateLogDerivativeLookupRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr write_term;\\n        Fr read_term;\\n\\n        // Calculate the write term (the table accumulation)\\n        {\\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\\n        }\\n\\n        // Calculate the write term\\n        {\\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\\n\\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\\n        }\\n\\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\\n\\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\\n\\n        // Inverse calculated correctly relation\\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\\n        accumulatorNone = accumulatorNone * domainSep;\\n\\n        // Inverse\\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\\n\\n        evals[4] = accumulatorNone;\\n        evals[5] = accumulatorOne;\\n    }\\n\\n    function accumulateDeltaRangeRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr minus_one = Fr.wrap(0) - Fr.wrap(1);\\n        Fr minus_two = Fr.wrap(0) - Fr.wrap(2);\\n        Fr minus_three = Fr.wrap(0) - Fr.wrap(3);\\n\\n        // Compute wire differences\\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\\n\\n        // Contribution 6\\n        {\\n            Fr acc = delta_1;\\n            acc = acc * (delta_1 + minus_one);\\n            acc = acc * (delta_1 + minus_two);\\n            acc = acc * (delta_1 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[6] = acc;\\n        }\\n\\n        // Contribution 7\\n        {\\n            Fr acc = delta_2;\\n            acc = acc * (delta_2 + minus_one);\\n            acc = acc * (delta_2 + minus_two);\\n            acc = acc * (delta_2 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[7] = acc;\\n        }\\n\\n        // Contribution 8\\n        {\\n            Fr acc = delta_3;\\n            acc = acc * (delta_3 + minus_one);\\n            acc = acc * (delta_3 + minus_two);\\n            acc = acc * (delta_3 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[8] = acc;\\n        }\\n\\n        // Contribution 9\\n        {\\n            Fr acc = delta_4;\\n            acc = acc * (delta_4 + minus_one);\\n            acc = acc * (delta_4 + minus_two);\\n            acc = acc * (delta_4 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[9] = acc;\\n        }\\n    }\\n\\n    struct EllipticParams {\\n        // Points\\n        Fr x_1;\\n        Fr y_1;\\n        Fr x_2;\\n        Fr y_2;\\n        Fr y_3;\\n        Fr x_3;\\n        // push accumulators into memory\\n        Fr x_double_identity;\\n    }\\n\\n    function accumulateEllipticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        EllipticParams memory ep;\\n        ep.x_1 = wire(p, WIRE.W_R);\\n        ep.y_1 = wire(p, WIRE.W_O);\\n\\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\\n\\n        Fr q_sign = wire(p, WIRE.Q_L);\\n        Fr q_is_double = wire(p, WIRE.Q_M);\\n\\n        // Contribution 10 point addition, x-coordinate check\\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n        Fr x_diff = (ep.x_2 - ep.x_1);\\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\\n        {\\n            // Move to top\\n            Fr partialEval = domainSep;\\n\\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\\n            x_add_identity = x_add_identity * x_diff * x_diff;\\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\\n\\n            evals[10] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 11 point addition, x-coordinate check\\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\\n        {\\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\\n            evals[11] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 10 point doubling, x-coordinate check\\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\\n        {\\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\\n\\n            // NOTE: pushed into memory (stack >:'( )\\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\\n\\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n            evals[10] = evals[10] + acc;\\n        }\\n\\n        // Contribution 11 point doubling, y-coordinate check\\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n        {\\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\\n            evals[11] = evals[11] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n        }\\n    }\\n\\n    // Constants for the auxiliary relation\\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\\n\\n    // Parameters used within the Auxiliary Relation\\n    // A struct is used to work around stack too deep. This relation has alot of variables\\n    struct AuxParams {\\n        Fr limb_subproduct;\\n        Fr non_native_field_gate_1;\\n        Fr non_native_field_gate_2;\\n        Fr non_native_field_gate_3;\\n        Fr limb_accumulator_1;\\n        Fr limb_accumulator_2;\\n        Fr memory_record_check;\\n        Fr partial_record_check;\\n        Fr next_gate_access_type;\\n        Fr record_delta;\\n        Fr index_delta;\\n        Fr adjacent_values_match_if_adjacent_indices_match;\\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n        Fr access_check;\\n        Fr next_gate_access_type_is_boolean;\\n        Fr ROM_consistency_check_identity;\\n        Fr RAM_consistency_check_identity;\\n        Fr timestamp_delta;\\n        Fr RAM_timestamp_check_identity;\\n        Fr memory_identity;\\n        Fr index_is_monotonically_increasing;\\n        Fr auxiliary_identity;\\n    }\\n\\n    function accumulateAuxillaryRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        AuxParams memory ap;\\n\\n        /**\\n         * Contribution 12\\n         * Non native field arithmetic gate 2\\n         * deg 4\\n         *\\n         *             _                                                                               _\\n         *            /   _                   _                               _       14                \\\\\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n         *            \\\\_                                                                               _/\\n         *\\n         *\\n         */\\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\\n        ap.non_native_field_gate_2 =\\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\\n\\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\\n\\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\\n\\n        Fr non_native_field_identity =\\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\\n\\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\\n        // deg 2\\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\\n\\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\\n        // deg 2\\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\\n\\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\\n\\n        /**\\n         * MEMORY\\n         *\\n         * A RAM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\\n         *  * v: `value` of memory cell being accessed\\n         *  * a: `access` type of record. read: 0 = read, 1 = write\\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\\n         *\\n         * A ROM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\\n         *\\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\\n         *\\n         *  | gate type | i  | v2/t  |  v | a  | r  |\\n         *  | --------- | -- | ----- | -- | -- | -- |\\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\\n         *\\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\\n         * `w2` to fix its value)\\n         *\\n         *\\n         */\\n\\n        /**\\n         * Memory Record Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * A ROM/ROM access gate can be evaluated with the identity:\\n         *\\n         * qc + w1 \\\\eta + w2 \\\\eta_two + w3 \\\\eta_three - w4 = 0\\n         *\\n         * For ROM gates, qc = 0\\n         */\\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\\n\\n        /**\\n         * Contribution 13 & 14\\n         * ROM Consistency Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\\n         * records that are sorted.\\n         *\\n         * We apply the following checks for the sorted records:\\n         *\\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\\n         * 2. index values for adjacent records are monotonically increasing\\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\\n         *\\n         */\\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\\n\\n        ap.index_is_monotonically_increasing = ap.index_delta * ap.index_delta - ap.index_delta; // deg 2\\n\\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.record_delta; // deg 2\\n\\n        evals[13] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n        evals[14] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n\\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\\n\\n        /**\\n         * Contributions 15,16,17\\n         * RAM Consistency Check\\n         *\\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\\n         * This is validated by requiring `access` to be boolean\\n         *\\n         * For two adjacent entries in the sorted list if _both_\\n         *  A) index values match\\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\\n         * then\\n         *  C) both values must match.\\n         * The gate boolean check is\\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\\n         *\\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\\n         * with a WRITE operation.\\n         */\\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\\n        ap.access_check = access_type * access_type - access_type; // check value is 0 or 1; deg 2 or 8\\n\\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\\n\\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (\\n            ap.index_delta * MINUS_ONE + Fr.wrap(1)\\n        ) * value_delta * (ap.next_gate_access_type * MINUS_ONE + Fr.wrap(1)); // deg 3 or 6\\n\\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\\n        // type is  correct, to cover this edge case\\n        // deg 2 or 4\\n        ap.next_gate_access_type_is_boolean =\\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\\n\\n        // Putting it all together...\\n        evals[15] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\\n            * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5 or 8\\n        evals[16] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4\\n        evals[17] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 6\\n\\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_ARITH)); // deg 3 or 9\\n\\n        /**\\n         * RAM Timestamp Consistency Check\\n         *\\n         * | w1 | w2 | w3 | w4 |\\n         * | index | timestamp | timestamp_check | -- |\\n         *\\n         * Let delta_index = index_{i + 1} - index_{i}\\n         *\\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\\n         * Else timestamp_check = 0\\n         */\\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\\n        ap.RAM_timestamp_check_identity =\\n            (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\\n\\n        /**\\n         * Complete Contribution 12\\n         * The complete RAM/ROM memory identity\\n         * Partial degree:\\n         */\\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\\n        ap.memory_identity =\\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\\n\\n        // (deg 3 or 9) + (deg 4) + (deg 3)\\n        ap.auxiliary_identity = ap.memory_identity + non_native_field_identity + limb_accumulator_identity;\\n        ap.auxiliary_identity = ap.auxiliary_identity * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 10\\n        evals[12] = ap.auxiliary_identity;\\n    }\\n\\n    struct PoseidonExternalParams {\\n        Fr s1;\\n        Fr s2;\\n        Fr s3;\\n        Fr s4;\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr t0;\\n        Fr t1;\\n        Fr t2;\\n        Fr t3;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonExternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonExternalParams memory ep;\\n\\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\\n\\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\\n        // matrix mul v = M_E * u with 14 additions\\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\\n        ep.v4 = ep.t1 + ep.t1;\\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\\n        ep.v2 = ep.t0 + ep.t0;\\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\\n\\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\\n        evals[18] = evals[18] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        evals[19] = evals[19] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    struct PoseidonInternalParams {\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr u_sum;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr s1;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonInternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonInternalParams memory ip;\\n\\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\\n        ];\\n\\n        // add round constants\\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n\\n        // apply s-box round\\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\\n        ip.u2 = wire(p, WIRE.W_R);\\n        ip.u3 = wire(p, WIRE.W_O);\\n        ip.u4 = wire(p, WIRE.W_4);\\n\\n        // matrix mul with v = M_I * u 4 muls and 7 additions\\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\\n\\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\\n\\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\\n        evals[22] = evals[22] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\\n        evals[23] = evals[23] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    function scaleAndBatchSubrelations(\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\\n    ) internal pure returns (Fr accumulator) {\\n        accumulator = accumulator + evaluations[0];\\n\\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\\n        }\\n    }\\n}\\n\\nstruct ShpleminiIntermediates {\\n    Fr unshiftedScalar;\\n    Fr shiftedScalar;\\n    // Scalar to be multiplied by [1]\\u2081\\n    Fr constantTermAccumulator;\\n    // Accumulator for powers of rho\\n    Fr batchingChallenge;\\n    // Linear combination of multilinear (sumcheck) evaluations and powers of rho\\n    Fr batchedEvaluation;\\n    // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr posInvertedDenominator;\\n    // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr negInvertedDenominator;\\n    // v^{2i} * 1/(z - r^{2^i})\\n    Fr scalingFactorPos;\\n    // v^{2i+1} * 1/(z + r^{2^i})\\n    Fr scalingFactorNeg;\\n    // // Fold_i(r^{2^i}) reconstructed by Verifier\\n    // Fr[CONST_PROOF_SIZE_LOG_N] foldPosEvaluations;\\n}\\n\\nlibrary CommitmentSchemeLib {\\n    using FrLib for Fr;\\n\\n    function computeSquares(Fr r) internal pure returns (Fr[CONST_PROOF_SIZE_LOG_N] memory squares) {\\n        squares[0] = r;\\n        for (uint256 i = 1; i < CONST_PROOF_SIZE_LOG_N; ++i) {\\n            squares[i] = squares[i - 1].sqr();\\n        }\\n    }\\n\\n    // Compute the evaluations  A_l(r^{2^l}) for l = 0, ..., m-1\\n    function computeFoldPosEvaluations(\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\\n        Fr batchedEvalAccumulator,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvalChallengePowers,\\n        uint256 logSize\\n    ) internal view returns (Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations) {\\n        for (uint256 i = CONST_PROOF_SIZE_LOG_N; i > 0; --i) {\\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\\n            Fr u = sumcheckUChallenges[i - 1];\\n\\n            Fr batchedEvalRoundAcc = (\\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\\n                    - geminiEvaluations[i - 1] * (challengePower * (Fr.wrap(1) - u) - u)\\n            );\\n            // Divide by the denominator\\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (Fr.wrap(1) - u) + u).invert();\\n\\n            if (i <= logSize) {\\n                batchedEvalAccumulator = batchedEvalRoundAcc;\\n                foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\\n            }\\n        }\\n\\n    }\\n}\\n\\ninterface IVerifier {\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);\\n}\\n\\n\\nabstract contract BaseHonkVerifier is IVerifier {\\n    using FrLib for Fr;\\n\\n    uint256 immutable n;\\n    uint256 immutable logN;\\n    uint256 immutable numPublicInputs;\\n\\n    constructor(uint256 _n, uint256 _logN, uint256 _numPublicInputs) {\\n        n = _n;\\n        logN = _logN;\\n        numPublicInputs = _numPublicInputs;\\n    }\\n\\n    error ProofLengthWrong();\\n    error PublicInputsLengthWrong();\\n    error SumcheckFailed();\\n    error ShpleminiFailed();\\n\\n    // Number of field elements in a ultra honk zero knowledge proof\\n    uint256 constant PROOF_SIZE = 440;\\n\\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\\n\\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs) public view override returns (bool) {\\n         // Check the received proof is the expected size where each field element is 32 bytes\\n        if (proof.length != PROOF_SIZE * 32) {\\n            revert ProofLengthWrong();\\n        }\\n\\n        Honk.VerificationKey memory vk = loadVerificationKey();\\n        Honk.Proof memory p = TranscriptLib.loadProof(proof);\\n\\n        if (publicInputs.length != vk.publicInputsSize) {\\n            revert PublicInputsLengthWrong();\\n        }\\n\\n        // Generate the fiat shamir challenges for the whole protocol\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        Transcript memory t = TranscriptLib.generateTranscript(p, publicInputs, vk.circuitSize, vk.publicInputsSize, /*pubInputsOffset=*/1);\\n\\n        // Derive public input delta\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\\n            publicInputs, t.relationParameters.beta, t.relationParameters.gamma, /*pubInputsOffset=*/1\\n        );\\n\\n        // Sumcheck\\n        bool sumcheckVerified = verifySumcheck(p, t);\\n        if (!sumcheckVerified) revert SumcheckFailed();\\n\\n        bool shpleminiVerified = verifyShplemini(p, vk, t);\\n        if (!shpleminiVerified) revert ShpleminiFailed();\\n\\n        return sumcheckVerified && shpleminiVerified; // Boolean condition not required - nice for vanity :)\\n    }\\n\\n    function computePublicInputDelta(bytes32[] memory publicInputs, Fr beta, Fr gamma, uint256 offset)\\n        internal\\n        view\\n        returns (Fr publicInputDelta)\\n    {\\n        Fr numerator = Fr.wrap(1);\\n        Fr denominator = Fr.wrap(1);\\n\\n        Fr numeratorAcc = gamma + (beta * FrLib.from(n + offset));\\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\\n\\n        {\\n            for (uint256 i = 0; i < numPublicInputs; i++) {\\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\\n\\n                numerator = numerator * (numeratorAcc + pubInput);\\n                denominator = denominator * (denominatorAcc + pubInput);\\n\\n                numeratorAcc = numeratorAcc + beta;\\n                denominatorAcc = denominatorAcc - beta;\\n            }\\n        }\\n\\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\\n        publicInputDelta = FrLib.div(numerator, denominator);\\n    }\\n\\n    function verifySumcheck(Honk.Proof memory proof, Transcript memory tp) internal view returns (bool verified) {\\n        Fr roundTarget;\\n        Fr powPartialEvaluation = Fr.wrap(1);\\n\\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\\n        for (uint256 round; round < logN; ++round) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\\n            bool valid = checkSum(roundUnivariate, roundTarget);\\n            if (!valid) revert SumcheckFailed();\\n\\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\\n\\n            // Update the round target for the next rounf\\n            roundTarget = computeNextTargetSum(roundUnivariate, roundChallenge);\\n            powPartialEvaluation = partiallyEvaluatePOW(tp.gateChallenges[round], powPartialEvaluation, roundChallenge);\\n        }\\n\\n        // Last round\\n        Fr grandHonkRelationSum =\\n            RelationsLib.accumulateRelationEvaluations(proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation);\\n        verified = (grandHonkRelationSum == roundTarget);\\n    }\\n\\n    function checkSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate, Fr roundTarget)\\n        internal\\n        pure\\n        returns (bool checked)\\n    {\\n        Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\\n        checked = totalSum == roundTarget;\\n    }\\n\\n    // Return the new target sum for the next sumcheck round\\n    function computeNextTargetSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\\n        internal\\n        view\\n        returns (Fr targetSum)\\n    {\\n        // TODO: inline\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000002d0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff11),\\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000090),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff71),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000000f0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000013b0)\\n        ];\\n\\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\\n\\n        // Performing Barycentric evaluations\\n        // Compute B(x)\\n        Fr numeratorValue = Fr.wrap(1);\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\\n        }\\n\\n        // Calculate domain size N of inverses\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr inv = BARYCENTRIC_LAGRANGE_DENOMINATORS[i];\\n            inv = inv * (roundChallenge - Fr.wrap(i));\\n            inv = FrLib.invert(inv);\\n            denominatorInverses[i] = inv;\\n        }\\n\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr term = roundUnivariates[i];\\n            term = term * denominatorInverses[i];\\n            targetSum = targetSum + term;\\n        }\\n\\n        // Scale the sum by the value of B(x)\\n        targetSum = targetSum * numeratorValue;\\n    }\\n\\n    // Univariate evaluation of the monomial ((1-X_l) + X_l.B_l) at the challenge point X_l=u_l\\n    function partiallyEvaluatePOW(Fr gateChallenge, Fr currentEvaluation, Fr roundChallenge)\\n        internal\\n        pure\\n        returns (Fr newEvaluation)\\n    {\\n        Fr univariateEval = Fr.wrap(1) + (roundChallenge * (gateChallenge - Fr.wrap(1)));\\n        newEvaluation = currentEvaluation * univariateEval;\\n    }\\n\\n    function verifyShplemini(Honk.Proof memory proof, Honk.VerificationKey memory vk, Transcript memory tp)\\n        internal\\n        view\\n        returns (bool verified)\\n    {\\n        ShpleminiIntermediates memory mem; // stack\\n\\n        // - Compute vector (r, r\\u00b2, ... , r\\u00b2\\u207d\\u207f\\u207b\\u00b9\\u207e), where n = log_circuit_size\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR);\\n\\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars;\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory commitments;\\n\\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\\n\\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.shiftedScalar =\\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\\n\\n        scalars[0] = Fr.wrap(1);\\n        commitments[0] = convertProofPoint(proof.shplonkQ);\\n\\n        mem.batchingChallenge = Fr.wrap(1);\\n        mem.batchedEvaluation = Fr.wrap(0);\\n\\n        for (uint256 i = 1; i <= NUMBER_UNSHIFTED; ++i) {\\n            scalars[i] = mem.unshiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n        // g commitments are accumulated at r\\n        for (uint256 i = NUMBER_UNSHIFTED + 1; i <= NUMBER_OF_ENTITIES; ++i) {\\n            scalars[i] = mem.shiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n\\n        commitments[1] = vk.qm;\\n        commitments[2] = vk.qc;\\n        commitments[3] = vk.ql;\\n        commitments[4] = vk.qr;\\n        commitments[5] = vk.qo;\\n        commitments[6] = vk.q4;\\n        commitments[7] = vk.qLookup;\\n        commitments[8] = vk.qArith;\\n        commitments[9] = vk.qDeltaRange;\\n        commitments[10] = vk.qElliptic;\\n        commitments[11] = vk.qAux;\\n        commitments[12] = vk.qPoseidon2External;\\n        commitments[13] = vk.qPoseidon2Internal;\\n        commitments[14] = vk.s1;\\n        commitments[15] = vk.s2;\\n        commitments[16] = vk.s3;\\n        commitments[17] = vk.s4;\\n        commitments[18] = vk.id1;\\n        commitments[19] = vk.id2;\\n        commitments[20] = vk.id3;\\n        commitments[21] = vk.id4;\\n        commitments[22] = vk.t1;\\n        commitments[23] = vk.t2;\\n        commitments[24] = vk.t3;\\n        commitments[25] = vk.t4;\\n        commitments[26] = vk.lagrangeFirst;\\n        commitments[27] = vk.lagrangeLast;\\n\\n        // Accumulate proof points\\n        commitments[28] = convertProofPoint(proof.w1);\\n        commitments[29] = convertProofPoint(proof.w2);\\n        commitments[30] = convertProofPoint(proof.w3);\\n        commitments[31] = convertProofPoint(proof.w4);\\n        commitments[32] = convertProofPoint(proof.zPerm);\\n        commitments[33] = convertProofPoint(proof.lookupInverses);\\n        commitments[34] = convertProofPoint(proof.lookupReadCounts);\\n        commitments[35] = convertProofPoint(proof.lookupReadTags);\\n\\n        // to be Shifted\\n        commitments[36] = convertProofPoint(proof.w1);\\n        commitments[37] = convertProofPoint(proof.w2);\\n        commitments[38] = convertProofPoint(proof.w3);\\n        commitments[39] = convertProofPoint(proof.w4);\\n        commitments[40] = convertProofPoint(proof.zPerm);\\n\\n        // Add contributions from A\\u2080(r) and A\\u2080(-r) to constant_term_accumulator:\\n        // Compute the evaluations A_l(r^{2^l}) for l = 0, ..., logN - 1\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\\n            tp.sumCheckUChallenges,\\n            mem.batchedEvaluation,\\n            proof.geminiAEvaluations,\\n            powers_of_evaluation_challenge,\\n            logN\\n        );\\n\\n        // Compute the Shplonk constant term contributions from A\\u2080(\\u00b1r)\\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\\n        mem.constantTermAccumulator =\\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.batchingChallenge = tp.shplonkNu.sqr();\\n\\n        // Compute Shplonk constant term contributions from A\\u2097(\\u00b1r^{2\\u02e1}) for l = 1, ..., m-1;\\n        // Compute scalar multipliers for each fold commitment\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {\\n            bool dummy_round = i >= (logN - 1);\\n\\n            if (!dummy_round) {\\n                // Update inverted denominators\\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\\n\\n                // Compute the scalar multipliers for A\\u2097(\\u00b1 r^{2\\u02e1}) and [A\\u2097]\\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\\n                // [A\\u2097] is multiplied by -v^{2l}/(z-r^{2^l}) - v^{2l+1} /(z+ r^{2^l})\\n                scalars[NUMBER_OF_ENTITIES + 1 + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\\n\\n                // Accumulate the const term contribution given by\\n                // v^{2l} * A\\u2097(r^{2\\u02e1}) /(z-r^{2^l}) + v^{2l+1} * A\\u2097(-r^{2\\u02e1}) /(z+ r^{2^l})\\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\\n                // Update the running power of v\\n                mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\\n            }\\n\\n            commitments[NUMBER_OF_ENTITIES + 1 + i] = convertProofPoint(proof.geminiFoldComms[i]);\\n        }\\n\\n        // Finalise the batch opening claim\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = Honk.G1Point({x: 1, y: 2});\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = mem.constantTermAccumulator;\\n\\n        Honk.G1Point memory quotient_commitment = convertProofPoint(proof.kzgQuotient);\\n\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = quotient_commitment;\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = tp.shplonkZ; // evaluation challenge\\n\\n        Honk.G1Point memory P_0 = batchMul(commitments, scalars);\\n        Honk.G1Point memory P_1 = negateInplace(quotient_commitment);\\n\\n        return pairing(P_0, P_1);\\n    }\\n\\n    // This implementation is the same as above with different constants\\n    function batchMul(\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory base,\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars\\n    ) internal view returns (Honk.G1Point memory result) {\\n        uint256 limit = NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2;\\n        assembly {\\n            let success := 0x01\\n            let free := mload(0x40)\\n\\n            // Write the original into the accumulator\\n            // Load into memory for ecMUL, leave offset for eccAdd result\\n            // base is an array of pointers, so we have to dereference them\\n            mstore(add(free, 0x40), mload(mload(base)))\\n            mstore(add(free, 0x60), mload(add(0x20, mload(base))))\\n            // Add scalar\\n            mstore(add(free, 0x80), mload(scalars))\\n            success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, free, 0x40))\\n\\n            let count := 0x01\\n            for {} lt(count, limit) { count := add(count, 1) } {\\n                // Get loop offsets\\n                let base_base := add(base, mul(count, 0x20))\\n                let scalar_base := add(scalars, mul(count, 0x20))\\n\\n                mstore(add(free, 0x40), mload(mload(base_base)))\\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\\n                // Add scalar\\n                mstore(add(free, 0x80), mload(scalar_base))\\n\\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\\n            }\\n\\n            // Return the result - i hate this\\n            mstore(result, mload(free))\\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\\n        }\\n    }\\n}\\n\\ncontract DepositVerifier is BaseHonkVerifier(N, LOG_N, NUMBER_OF_PUBLIC_INPUTS) {\\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\\n       return HonkVerificationKey.loadVerificationKey();\\n    }\\n}\\n\",\"keccak256\":\"0xec8b7a5c481d4db36cade2cd915ba23df6712dcad5573bbc52ccb611ce8a9131\",\"license\":\"Apache-2.0\"},\"contracts/verifiers/TransferVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.21;\\n\\nuint256 constant N = 65536;\\nuint256 constant LOG_N = 16;\\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 7;\\nlibrary HonkVerificationKey {\\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\\n            circuitSize: uint256(65536),\\n            logCircuitSize: uint256(16),\\n            publicInputsSize: uint256(7),\\n            ql: Honk.G1Point({ \\n               x: uint256(0x1a1e875f42167486ac11a99835a465c7015a7b16021abe1e748b5cf6cace2b62),\\n               y: uint256(0x3045d1909b8e0fa4618f31c3138202e2699064eeca9a6d82a44b914c114850c6)\\n            }),\\n            qr: Honk.G1Point({ \\n               x: uint256(0x11b5d8797b3cecce1971263ece6a677899243a9225139178d07e775dc9b3e587),\\n               y: uint256(0x25eb6e58ffa4512e030e414a041952016b232ab04975097ac60466d0e28aa532)\\n            }),\\n            qo: Honk.G1Point({ \\n               x: uint256(0x1d59c0139207dce3c74baee590fdb35954d188f19df71489b0101bda805f742e),\\n               y: uint256(0x28c3e9db04a20f2225bde03f5ede809f2470dc56c958b6ebc043ea2f624005fd)\\n            }),\\n            q4: Honk.G1Point({ \\n               x: uint256(0x00552a80d18d80bf39b3d66403f907bf3189808127c6050781ef4a883eecd7d4),\\n               y: uint256(0x078761f1085f44b79182bde0b491bef33d9390174f2c46aa6322eb709d70e86c)\\n            }),\\n            qm: Honk.G1Point({ \\n               x: uint256(0x234c4c8b71ec9f56ab783e7d8a9ef4ac1a13580962a199a7dffb0b07cf479ea3),\\n               y: uint256(0x0e6dcee7a86b016e6060a18f35244c5d45bdbb3399f5d1105b57f7b34609c8c5)\\n            }),\\n            qc: Honk.G1Point({ \\n               x: uint256(0x02f02f0b0b9d38d3e4620f58157f413bfe6efd480aa60b40809345a45934d514),\\n               y: uint256(0x04131ae8f131cbc53e631b085e96d1adf65b7375ec0fa0e0dc371121c1e06c9f)\\n            }),\\n            qArith: Honk.G1Point({ \\n               x: uint256(0x243b4d85e4b013421aaabec5aa1a80df85cd4078997e4a46d26bda415357dd08),\\n               y: uint256(0x15f58737cb5fd512cee2483ac86ef606daf9feca529656febe4afa97c3488f74)\\n            }),\\n            qDeltaRange: Honk.G1Point({ \\n               x: uint256(0x1539680356883e585500983a2c496d6f968257c87799c0d0e597539e368add60),\\n               y: uint256(0x0f6b691986777ce8591d771fff90786c0b108e2c278921651634916dc09728ea)\\n            }),\\n            qElliptic: Honk.G1Point({ \\n               x: uint256(0x0ff6d798d89fbc0ebdcc50bad8714df0e8d322e6c5187b1dbb7e83e5975869fa),\\n               y: uint256(0x076204bc54fc91a399ee8c65aadc753c70b18cc4323fd374e7a6def9f5f174e0)\\n            }),\\n            qAux: Honk.G1Point({ \\n               x: uint256(0x228b04b575b50160e66efdf4b5ad1f7e9ce811da535020bf1c108171b6f274ec),\\n               y: uint256(0x09b05944114dd08bceef513eec6bfe03f2db3e8847c0eb30c285af443cf1e2c1)\\n            }),\\n            qLookup: Honk.G1Point({ \\n               x: uint256(0x0913b944f225bd3437dc089c770cf3078694e897165159fb022789e582c0a25b),\\n               y: uint256(0x179e3ba13edea82a7dc156f47fc3b56433b7c0f2582e8696c494a979ed50e06a)\\n            }),\\n            qPoseidon2External: Honk.G1Point({ \\n               x: uint256(0x276c5a1915aa930df9040ae34c37563d9974458ff5cfeaab37e477d2b5922dc3),\\n               y: uint256(0x2f800af2ec79287683c2452fbbd07c2ae5e731b294e76ca927cb35ed8a3258c1)\\n            }),\\n            qPoseidon2Internal: Honk.G1Point({ \\n               x: uint256(0x158f2f2113e7b648a151599ded71f3e7fd8835c390ee423358a2b4dcaaedd282),\\n               y: uint256(0x2748e38a2d397b2748071d5db86ed97579faa8e6c81264d1c5a56890df7e9b7c)\\n            }),\\n            s1: Honk.G1Point({ \\n               x: uint256(0x2195bf6308536fe46b7205b0b1b2a5cd17a8bfa3e2c1bbe3001e3beb2cab6405),\\n               y: uint256(0x042df3741f3ada62b7e7a79685d11a4bc29f128d455177351e9daca782eba58e)\\n            }),\\n            s2: Honk.G1Point({ \\n               x: uint256(0x2b990a4b66dbc143bb64c97ab48938a1cd64d7441368534ad1e8c229b8475df2),\\n               y: uint256(0x2330129b27354517657f1799e16d1870902369e439ff66ff13dd55639156e3da)\\n            }),\\n            s3: Honk.G1Point({ \\n               x: uint256(0x11b95554da4c0e77ade9239c29e36d9a4048c76af254a743a72cda94fc081949),\\n               y: uint256(0x1e47ba937a5909a12678e76e788a5d939f42bff3c1dd45d3cb7fc2c5dffcfea3)\\n            }),\\n            s4: Honk.G1Point({ \\n               x: uint256(0x2d5c139253ab560c601cb2eaf4ab9705540a66e67f6ddc67f4876b8382e2d9ea),\\n               y: uint256(0x067ab21096704579b4e40e96bd8373c4c04de9a9bbb137bec4c7d71753d2f9eb)\\n            }),\\n            t1: Honk.G1Point({ \\n               x: uint256(0x224948ddbcddb1e360efa2ac511aacd0d3258758dfa9bae9e415f6d48d990e16),\\n               y: uint256(0x1011627c159ab9f3ff0a0416a01df6f6a101330e9f928dc80a3d3b9afefb373a)\\n            }),\\n            t2: Honk.G1Point({ \\n               x: uint256(0x18dab63316305864682bfe7b586e912ec420ad50087360c152c131400547bcc6),\\n               y: uint256(0x1edb4d30542aa0ac4fe8eb31fc2ce04bd9f352c132c7ae6bed5ea997693e6300)\\n            }),\\n            t3: Honk.G1Point({ \\n               x: uint256(0x0da213c79d7e44cd308766f068a2397abc60e991844a8abade001179d144e3f6),\\n               y: uint256(0x03a6668aae5f6093de550d4d868840054dca22307d50e5beb76576afd31e250c)\\n            }),\\n            t4: Honk.G1Point({ \\n               x: uint256(0x07ea92c2de0345ded1d25b237f08456f99a40f79f14ed78a291d53d0425ddc9d),\\n               y: uint256(0x255aeaa6894472e3cb6b0a790cf290bc1328fa2c343da93cb98486d414f0a40a)\\n            }),\\n            id1: Honk.G1Point({ \\n               x: uint256(0x1e38d7324e5501215d8047e0961236178de15f08e34170be9922b3d87cf2752f),\\n               y: uint256(0x196770e1012059a88d0c7a794c9142327305fc2fa624e9c2ecbb75681db0d520)\\n            }),\\n            id2: Honk.G1Point({ \\n               x: uint256(0x20e8e4613517a140b58d0707564ff5ab1483a171cbc1374197b059ee4d98418a),\\n               y: uint256(0x06fd56317abbf3444a02db90f6f9a5083a4beae21d7dd7cbc474c797404e2759)\\n            }),\\n            id3: Honk.G1Point({ \\n               x: uint256(0x2cd0f4b7eb6e8c082db11ddede1e9065907869a28b6da7ff4cc0317d5153a233),\\n               y: uint256(0x19411c7a097265dcab1012a4373f8d89fdcde193d2d00ff61584102d65e12425)\\n            }),\\n            id4: Honk.G1Point({ \\n               x: uint256(0x1a07062fed7af7b1152e0038dd4f5a42c345a1907bb9071dcb6dbcec7c205b7c),\\n               y: uint256(0x2bdab0b217c9c90734f9f57fa0da3251ffac75447f9ed08c0d0b2aa63652f86a)\\n            }),\\n            lagrangeFirst: Honk.G1Point({ \\n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\\n            }),\\n            lagrangeLast: Honk.G1Point({ \\n               x: uint256(0x2c39629d05e19d06e9b41253b5b15cc86f801295b2a604535cfd57db983a7248),\\n               y: uint256(0x171a88a956ec45f61f5f9ea1ed16203dd3b1629065540972be76110648013598)\\n            })\\n        });\\n        return vk;\\n    }\\n}\\n\\npragma solidity ^0.8.27;\\n\\ntype Fr is uint256;\\n\\nusing { add as + } for Fr global;\\nusing { sub as - } for Fr global;\\nusing { mul as * } for Fr global;\\nusing { exp as ^ } for Fr global;\\nusing { notEqual as != } for Fr global;\\nusing { equal as == } for Fr global;\\n\\nuint256 constant MODULUS =\\n    21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\\n\\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\\n\\n// Instantiation\\nlibrary FrLib\\n{\\n    function from(uint256 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(value % MODULUS);\\n    }\\n\\n    function fromBytes32(bytes32 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(uint256(value) % MODULUS);\\n    }\\n\\n    function toBytes32(Fr value) internal pure returns(bytes32)\\n    {\\n        return bytes32(Fr.unwrap(value));\\n    }\\n\\n    function invert(Fr value) internal view returns(Fr)\\n    {\\n        uint256 v = Fr.unwrap(value);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), v)\\n            mstore(add(free, 0x80), sub(MODULUS, 2))\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function pow(Fr base, uint256 v) internal view returns(Fr)\\n    {\\n        uint256 b = Fr.unwrap(base);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), b)\\n            mstore(add(free, 0x80), v)\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function div(Fr numerator, Fr denominator) internal view returns(Fr)\\n    {\\n        return numerator * invert(denominator);\\n    }\\n\\n    function sqr(Fr value) internal pure returns (Fr) {\\n        return value * value;\\n    }\\n\\n    function unwrap(Fr value) internal pure returns (uint256) {\\n        return Fr.unwrap(value);\\n    }\\n\\n    function neg(Fr value) internal pure returns (Fr) {\\n        return Fr.wrap(MODULUS - Fr.unwrap(value));\\n    }\\n}\\n\\n// Free functions\\nfunction add(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction mul(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction sub(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction exp(Fr base, Fr exponent) pure returns(Fr)\\n{\\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\\n\\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\\n        base = base * base;\\n    }\\n    return base;\\n}\\n\\nfunction notEqual(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) != Fr.unwrap(b);\\n}\\n\\nfunction equal(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) == Fr.unwrap(b);\\n}\\n\\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\\n\\nuint256 constant NUMBER_OF_SUBRELATIONS = 26;\\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\\nuint256 constant NUMBER_OF_ENTITIES = 40;\\nuint256 constant NUMBER_UNSHIFTED = 35;\\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\\n\\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\\nuint256 constant NUMBER_OF_ALPHAS = 25;\\n\\n// Prime field order\\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\\nuint256 constant P = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order, F_r\\n\\n// ENUM FOR WIRES\\nenum WIRE {\\n    Q_M,\\n    Q_C,\\n    Q_L,\\n    Q_R,\\n    Q_O,\\n    Q_4,\\n    Q_LOOKUP,\\n    Q_ARITH,\\n    Q_RANGE,\\n    Q_ELLIPTIC,\\n    Q_AUX,\\n    Q_POSEIDON2_EXTERNAL,\\n    Q_POSEIDON2_INTERNAL,\\n    SIGMA_1,\\n    SIGMA_2,\\n    SIGMA_3,\\n    SIGMA_4,\\n    ID_1,\\n    ID_2,\\n    ID_3,\\n    ID_4,\\n    TABLE_1,\\n    TABLE_2,\\n    TABLE_3,\\n    TABLE_4,\\n    LAGRANGE_FIRST,\\n    LAGRANGE_LAST,\\n    W_L,\\n    W_R,\\n    W_O,\\n    W_4,\\n    Z_PERM,\\n    LOOKUP_INVERSES,\\n    LOOKUP_READ_COUNTS,\\n    LOOKUP_READ_TAGS,\\n    W_L_SHIFT,\\n    W_R_SHIFT,\\n    W_O_SHIFT,\\n    W_4_SHIFT,\\n    Z_PERM_SHIFT\\n}\\n\\nlibrary Honk {\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    struct G1ProofPoint {\\n        uint256 x_0;\\n        uint256 x_1;\\n        uint256 y_0;\\n        uint256 y_1;\\n    }\\n\\n    struct VerificationKey {\\n        // Misc Params\\n        uint256 circuitSize;\\n        uint256 logCircuitSize;\\n        uint256 publicInputsSize;\\n        // Selectors\\n        G1Point qm;\\n        G1Point qc;\\n        G1Point ql;\\n        G1Point qr;\\n        G1Point qo;\\n        G1Point q4;\\n        G1Point qLookup; // Lookup\\n        G1Point qArith; // Arithmetic widget\\n        G1Point qDeltaRange; // Delta Range sort\\n        G1Point qAux; // Auxillary\\n        G1Point qElliptic; // Auxillary\\n        G1Point qPoseidon2External;\\n        G1Point qPoseidon2Internal;\\n        // Copy cnstraints\\n        G1Point s1;\\n        G1Point s2;\\n        G1Point s3;\\n        G1Point s4;\\n        // Copy identity\\n        G1Point id1;\\n        G1Point id2;\\n        G1Point id3;\\n        G1Point id4;\\n        // Precomputed lookup table\\n        G1Point t1;\\n        G1Point t2;\\n        G1Point t3;\\n        G1Point t4;\\n        // Fixed first and last\\n        G1Point lagrangeFirst;\\n        G1Point lagrangeLast;\\n    }\\n\\n    struct RelationParameters {\\n        // challenges\\n        Fr eta;\\n        Fr etaTwo;\\n        Fr etaThree;\\n        Fr beta;\\n        Fr gamma;\\n        // derived\\n        Fr publicInputsDelta;\\n    }\\n\\n\\n    struct Proof {\\n        // Free wires\\n        Honk.G1ProofPoint w1;\\n        Honk.G1ProofPoint w2;\\n        Honk.G1ProofPoint w3;\\n        Honk.G1ProofPoint w4;\\n        // Lookup helpers - Permutations\\n        Honk.G1ProofPoint zPerm;\\n        // Lookup helpers - logup\\n        Honk.G1ProofPoint lookupReadCounts;\\n        Honk.G1ProofPoint lookupReadTags;\\n        Honk.G1ProofPoint lookupInverses;\\n        // Sumcheck\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\\n        // Shplemini\\n        Honk.G1ProofPoint[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\\n        Honk.G1ProofPoint shplonkQ;\\n        Honk.G1ProofPoint kzgQuotient;\\n    }\\n}\\n\\n// Transcript library to generate fiat shamir challenges\\nstruct Transcript {\\n    // Oink\\n    Honk.RelationParameters relationParameters;\\n    Fr[NUMBER_OF_ALPHAS] alphas;\\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\\n    // Sumcheck\\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\\n    // Gemini\\n    Fr rho;\\n    Fr geminiR;\\n    // Shplonk\\n    Fr shplonkNu;\\n    Fr shplonkZ;\\n}\\n\\nlibrary TranscriptLib {\\n    function generateTranscript(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Transcript memory t)\\n    {\\n        Fr previousChallenge;\\n        (t.relationParameters, previousChallenge) =\\n            generateRelationParametersChallenges(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset, previousChallenge);\\n\\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\\n\\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge);\\n\\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge);\\n\\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\\n\\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge);\\n\\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge);\\n\\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\\n\\n        return t;\\n    }\\n\\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        uint256 hi = challengeU256 >> 128;\\n        first = FrLib.fromBytes32(bytes32(lo));\\n        second = FrLib.fromBytes32(bytes32(hi));\\n    }\\n\\n    function generateRelationParametersChallenges(\\n        Honk.Proof memory proof,\\n        bytes32[] calldata publicInputs,\\n        uint256 circuitSize,\\n        uint256 publicInputsSize,\\n        uint256 pubInputsOffset,\\n        Fr previousChallenge\\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\\n            generateEtaChallenge(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset);\\n\\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\\n\\n    }\\n\\n    function generateEtaChallenge(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge)\\n    {\\n        bytes32[] memory round0 = new bytes32[](3 + publicInputsSize + 12);\\n        round0[0] = bytes32(circuitSize);\\n        round0[1] = bytes32(publicInputsSize);\\n        round0[2] = bytes32(pubInputsOffset);\\n        for (uint256 i = 0; i < publicInputsSize; i++) {\\n            round0[3 + i] = bytes32(publicInputs[i]);\\n        }\\n\\n        // Create the first challenge\\n        // Note: w4 is added to the challenge later on\\n        round0[3 + publicInputsSize] = bytes32(proof.w1.x_0);\\n        round0[3 + publicInputsSize + 1] = bytes32(proof.w1.x_1);\\n        round0[3 + publicInputsSize + 2] = bytes32(proof.w1.y_0);\\n        round0[3 + publicInputsSize + 3] = bytes32(proof.w1.y_1);\\n        round0[3 + publicInputsSize + 4] = bytes32(proof.w2.x_0);\\n        round0[3 + publicInputsSize + 5] = bytes32(proof.w2.x_1);\\n        round0[3 + publicInputsSize + 6] = bytes32(proof.w2.y_0);\\n        round0[3 + publicInputsSize + 7] = bytes32(proof.w2.y_1);\\n        round0[3 + publicInputsSize + 8] = bytes32(proof.w3.x_0);\\n        round0[3 + publicInputsSize + 9] = bytes32(proof.w3.x_1);\\n        round0[3 + publicInputsSize + 10] = bytes32(proof.w3.y_0);\\n        round0[3 + publicInputsSize + 11] = bytes32(proof.w3.y_1);\\n\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\\n        (eta, etaTwo) = splitChallenge(previousChallenge);\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n        Fr unused;\\n        (etaThree, unused) = splitChallenge(previousChallenge);\\n    }\\n\\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\\n    {\\n        bytes32[13] memory round1;\\n        round1[0] = FrLib.toBytes32(previousChallenge);\\n        round1[1] = bytes32(proof.lookupReadCounts.x_0);\\n        round1[2] = bytes32(proof.lookupReadCounts.x_1);\\n        round1[3] = bytes32(proof.lookupReadCounts.y_0);\\n        round1[4] = bytes32(proof.lookupReadCounts.y_1);\\n        round1[5] = bytes32(proof.lookupReadTags.x_0);\\n        round1[6] = bytes32(proof.lookupReadTags.x_1);\\n        round1[7] = bytes32(proof.lookupReadTags.y_0);\\n        round1[8] = bytes32(proof.lookupReadTags.y_1);\\n        round1[9] = bytes32(proof.w4.x_0);\\n        round1[10] = bytes32(proof.w4.x_1);\\n        round1[11] = bytes32(proof.w4.y_0);\\n        round1[12] = bytes32(proof.w4.y_1);\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    // Alpha challenges non-linearise the gate contributions\\n    function generateAlphaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\\n    {\\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\\n        uint256[9] memory alpha0;\\n        alpha0[0] = Fr.unwrap(previousChallenge);\\n        alpha0[1] = proof.lookupInverses.x_0;\\n        alpha0[2] = proof.lookupInverses.x_1;\\n        alpha0[3] = proof.lookupInverses.y_0;\\n        alpha0[4] = proof.lookupInverses.y_1;\\n        alpha0[5] = proof.zPerm.x_0;\\n        alpha0[6] = proof.zPerm.x_1;\\n        alpha0[7] = proof.zPerm.y_0;\\n        alpha0[8] = proof.zPerm.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\\n        (alphas[0], alphas[1]) = splitChallenge(nextPreviousChallenge);\\n\\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS / 2; i++) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            (alphas[2 * i], alphas[2 * i + 1]) = splitChallenge(nextPreviousChallenge);\\n        }\\n        if (((NUMBER_OF_ALPHAS & 1) == 1) && (NUMBER_OF_ALPHAS > 2)) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            Fr unused;\\n            (alphas[NUMBER_OF_ALPHAS - 1], unused) = splitChallenge(nextPreviousChallenge);\\n        }\\n    }\\n\\n    function generateGateChallenges(Fr previousChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n            Fr unused;\\n            (gateChallenges[i], unused) = splitChallenge(previousChallenge);\\n        }\\n        nextPreviousChallenge = previousChallenge;\\n    }\\n\\n    function generateSumcheckChallenges(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\\n            univariateChal[0] = prevChallenge;\\n\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\\n            }\\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\\n            Fr unused;\\n            (sumcheckChallenges[i], unused) = splitChallenge(prevChallenge);\\n        }\\n        nextPreviousChallenge = prevChallenge;\\n    }\\n\\n    function generateRhoChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr rho, Fr nextPreviousChallenge)\\n    {\\n        Fr[NUMBER_OF_ENTITIES + 1] memory rhoChallengeElements;\\n        rhoChallengeElements[0] = prevChallenge;\\n\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            rhoChallengeElements[i + 1] = proof.sumcheckEvaluations[i];\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\\n        Fr unused;\\n        (rho, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateGeminiRChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr geminiR, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N - 1) * 4 + 1] memory gR;\\n        gR[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            gR[1 + i * 4] = proof.geminiFoldComms[i].x_0;\\n            gR[2 + i * 4] = proof.geminiFoldComms[i].x_1;\\n            gR[3 + i * 4] = proof.geminiFoldComms[i].y_0;\\n            gR[4 + i * 4] = proof.geminiFoldComms[i].y_1;\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\\n        Fr unused;\\n        (geminiR, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkNuChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N) + 1] memory shplonkNuChallengeElements;\\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            shplonkNuChallengeElements[i + 1] = Fr.unwrap(proof.geminiAEvaluations[i]);\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\\n        Fr unused;\\n        (shplonkNu, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkZChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\\n    {\\n        uint256[5] memory shplonkZChallengeElements;\\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        shplonkZChallengeElements[1] = proof.shplonkQ.x_0;\\n        shplonkZChallengeElements[2] = proof.shplonkQ.x_1;\\n        shplonkZChallengeElements[3] = proof.shplonkQ.y_0;\\n        shplonkZChallengeElements[4] = proof.shplonkQ.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\\n        Fr unused;\\n        (shplonkZ, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function loadProof(bytes calldata proof) internal pure returns (Honk.Proof memory p) {\\n        // Commitments\\n        p.w1 = bytesToG1ProofPoint(proof[0x0:0x80]);\\n\\n        p.w2 = bytesToG1ProofPoint(proof[0x80:0x100]);\\n        p.w3 = bytesToG1ProofPoint(proof[0x100:0x180]);\\n\\n        // Lookup / Permutation Helper Commitments\\n        p.lookupReadCounts = bytesToG1ProofPoint(proof[0x180:0x200]);\\n        p.lookupReadTags = bytesToG1ProofPoint(proof[0x200:0x280]);\\n        p.w4 = bytesToG1ProofPoint(proof[0x280:0x300]);\\n        p.lookupInverses = bytesToG1ProofPoint(proof[0x300:0x380]);\\n        p.zPerm = bytesToG1ProofPoint(proof[0x380:0x400]);\\n        uint256 boundary = 0x400;\\n\\n        // Sumcheck univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + 0x20]);\\n                boundary += 0x20;\\n            }\\n        }\\n        // Sumcheck evaluations\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Gemini\\n        // Read gemini fold univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            p.geminiFoldComms[i] = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n            boundary += 0x80;\\n        }\\n\\n        // Read gemini a evaluations\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Shplonk\\n        p.shplonkQ = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n        boundary = boundary + 0x80;\\n        // KZG\\n        p.kzgQuotient = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n    }\\n}\\n\\n\\n// Fr utility\\n\\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\\n    require(proofSection.length == 0x20, \\\"invalid bytes scalar\\\");\\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\\n}\\n\\n// EC Point utilities\\nfunction convertProofPoint(Honk.G1ProofPoint memory input) pure returns (Honk.G1Point memory) {\\n    return Honk.G1Point({x: input.x_0 | (input.x_1 << 136), y: input.y_0 | (input.y_1 << 136)});\\n}\\n\\nfunction bytesToG1ProofPoint(bytes calldata proofSection) pure returns (Honk.G1ProofPoint memory point) {\\n    require(proofSection.length == 0x80, \\\"invalid bytes point\\\");\\n    point = Honk.G1ProofPoint({\\n        x_0: uint256(bytes32(proofSection[0x00:0x20])),\\n        x_1: uint256(bytes32(proofSection[0x20:0x40])),\\n        y_0: uint256(bytes32(proofSection[0x40:0x60])),\\n        y_1: uint256(bytes32(proofSection[0x60:0x80]))\\n    });\\n}\\n\\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\\n    point.y = (Q - point.y) % Q;\\n    return point;\\n}\\n\\n function pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool) {\\n        bytes memory input = abi.encodePacked(\\n            rhs.x,\\n            rhs.y,\\n            // Fixed G1 point\\n            uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\\n            uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\\n            uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\\n            uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\\n            lhs.x,\\n            lhs.y,\\n            // G1 point from VK\\n            uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\\n            uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\\n            uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\\n            uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n        );\\n\\n        (bool success, bytes memory result) = address(0x08).staticcall(input);\\n        bool decodedResult = abi.decode(result, (bool));\\n        return success && decodedResult;\\n    }\\n\\n\\nlibrary RelationsLib {\\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\\n\\n    function accumulateRelationEvaluations(\\n         Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\\n        Fr powPartialEval\\n    ) internal pure returns (Fr accumulator) {\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\\n\\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateAuxillaryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\\n    }\\n\\n    /**\\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\\n     * editors, and thus is noisy.\\n     */\\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\\n        return p[uint256(_wire)];\\n    }\\n\\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    /**\\n     * Ultra Arithmetic Relation\\n     *\\n     */\\n    function accumulateArithmeticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        // Relation 0\\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\\n        {\\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\\n\\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\\n            accum = accum + (q_arith - Fr.wrap(1)) * wire(p, WIRE.W_4_SHIFT);\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[0] = accum;\\n        }\\n\\n        // Relation 1\\n        {\\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\\n            accum = accum * (q_arith - Fr.wrap(2));\\n            accum = accum * (q_arith - Fr.wrap(1));\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[1] = accum;\\n        }\\n    }\\n\\n    function accumulatePermutationRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr grand_product_numerator;\\n        Fr grand_product_denominator;\\n\\n        {\\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\\n\\n            grand_product_numerator = num;\\n        }\\n        {\\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\\n\\n            grand_product_denominator = den;\\n        }\\n\\n        // Contribution 2\\n        {\\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\\n\\n            acc = acc\\n                - (\\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\\n                        * grand_product_denominator\\n                );\\n            acc = acc * domainSep;\\n            evals[2] = acc;\\n        }\\n\\n        // Contribution 3\\n        {\\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\\n            evals[3] = acc;\\n        }\\n    }\\n\\n    function accumulateLogDerivativeLookupRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr write_term;\\n        Fr read_term;\\n\\n        // Calculate the write term (the table accumulation)\\n        {\\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\\n        }\\n\\n        // Calculate the write term\\n        {\\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\\n\\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\\n        }\\n\\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\\n\\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\\n\\n        // Inverse calculated correctly relation\\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\\n        accumulatorNone = accumulatorNone * domainSep;\\n\\n        // Inverse\\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\\n\\n        evals[4] = accumulatorNone;\\n        evals[5] = accumulatorOne;\\n    }\\n\\n    function accumulateDeltaRangeRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr minus_one = Fr.wrap(0) - Fr.wrap(1);\\n        Fr minus_two = Fr.wrap(0) - Fr.wrap(2);\\n        Fr minus_three = Fr.wrap(0) - Fr.wrap(3);\\n\\n        // Compute wire differences\\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\\n\\n        // Contribution 6\\n        {\\n            Fr acc = delta_1;\\n            acc = acc * (delta_1 + minus_one);\\n            acc = acc * (delta_1 + minus_two);\\n            acc = acc * (delta_1 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[6] = acc;\\n        }\\n\\n        // Contribution 7\\n        {\\n            Fr acc = delta_2;\\n            acc = acc * (delta_2 + minus_one);\\n            acc = acc * (delta_2 + minus_two);\\n            acc = acc * (delta_2 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[7] = acc;\\n        }\\n\\n        // Contribution 8\\n        {\\n            Fr acc = delta_3;\\n            acc = acc * (delta_3 + minus_one);\\n            acc = acc * (delta_3 + minus_two);\\n            acc = acc * (delta_3 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[8] = acc;\\n        }\\n\\n        // Contribution 9\\n        {\\n            Fr acc = delta_4;\\n            acc = acc * (delta_4 + minus_one);\\n            acc = acc * (delta_4 + minus_two);\\n            acc = acc * (delta_4 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[9] = acc;\\n        }\\n    }\\n\\n    struct EllipticParams {\\n        // Points\\n        Fr x_1;\\n        Fr y_1;\\n        Fr x_2;\\n        Fr y_2;\\n        Fr y_3;\\n        Fr x_3;\\n        // push accumulators into memory\\n        Fr x_double_identity;\\n    }\\n\\n    function accumulateEllipticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        EllipticParams memory ep;\\n        ep.x_1 = wire(p, WIRE.W_R);\\n        ep.y_1 = wire(p, WIRE.W_O);\\n\\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\\n\\n        Fr q_sign = wire(p, WIRE.Q_L);\\n        Fr q_is_double = wire(p, WIRE.Q_M);\\n\\n        // Contribution 10 point addition, x-coordinate check\\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n        Fr x_diff = (ep.x_2 - ep.x_1);\\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\\n        {\\n            // Move to top\\n            Fr partialEval = domainSep;\\n\\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\\n            x_add_identity = x_add_identity * x_diff * x_diff;\\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\\n\\n            evals[10] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 11 point addition, x-coordinate check\\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\\n        {\\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\\n            evals[11] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 10 point doubling, x-coordinate check\\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\\n        {\\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\\n\\n            // NOTE: pushed into memory (stack >:'( )\\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\\n\\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n            evals[10] = evals[10] + acc;\\n        }\\n\\n        // Contribution 11 point doubling, y-coordinate check\\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n        {\\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\\n            evals[11] = evals[11] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n        }\\n    }\\n\\n    // Constants for the auxiliary relation\\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\\n\\n    // Parameters used within the Auxiliary Relation\\n    // A struct is used to work around stack too deep. This relation has alot of variables\\n    struct AuxParams {\\n        Fr limb_subproduct;\\n        Fr non_native_field_gate_1;\\n        Fr non_native_field_gate_2;\\n        Fr non_native_field_gate_3;\\n        Fr limb_accumulator_1;\\n        Fr limb_accumulator_2;\\n        Fr memory_record_check;\\n        Fr partial_record_check;\\n        Fr next_gate_access_type;\\n        Fr record_delta;\\n        Fr index_delta;\\n        Fr adjacent_values_match_if_adjacent_indices_match;\\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n        Fr access_check;\\n        Fr next_gate_access_type_is_boolean;\\n        Fr ROM_consistency_check_identity;\\n        Fr RAM_consistency_check_identity;\\n        Fr timestamp_delta;\\n        Fr RAM_timestamp_check_identity;\\n        Fr memory_identity;\\n        Fr index_is_monotonically_increasing;\\n        Fr auxiliary_identity;\\n    }\\n\\n    function accumulateAuxillaryRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        AuxParams memory ap;\\n\\n        /**\\n         * Contribution 12\\n         * Non native field arithmetic gate 2\\n         * deg 4\\n         *\\n         *             _                                                                               _\\n         *            /   _                   _                               _       14                \\\\\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n         *            \\\\_                                                                               _/\\n         *\\n         *\\n         */\\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\\n        ap.non_native_field_gate_2 =\\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\\n\\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\\n\\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\\n\\n        Fr non_native_field_identity =\\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\\n\\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\\n        // deg 2\\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\\n\\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\\n        // deg 2\\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\\n\\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\\n\\n        /**\\n         * MEMORY\\n         *\\n         * A RAM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\\n         *  * v: `value` of memory cell being accessed\\n         *  * a: `access` type of record. read: 0 = read, 1 = write\\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\\n         *\\n         * A ROM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\\n         *\\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\\n         *\\n         *  | gate type | i  | v2/t  |  v | a  | r  |\\n         *  | --------- | -- | ----- | -- | -- | -- |\\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\\n         *\\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\\n         * `w2` to fix its value)\\n         *\\n         *\\n         */\\n\\n        /**\\n         * Memory Record Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * A ROM/ROM access gate can be evaluated with the identity:\\n         *\\n         * qc + w1 \\\\eta + w2 \\\\eta_two + w3 \\\\eta_three - w4 = 0\\n         *\\n         * For ROM gates, qc = 0\\n         */\\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\\n\\n        /**\\n         * Contribution 13 & 14\\n         * ROM Consistency Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\\n         * records that are sorted.\\n         *\\n         * We apply the following checks for the sorted records:\\n         *\\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\\n         * 2. index values for adjacent records are monotonically increasing\\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\\n         *\\n         */\\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\\n\\n        ap.index_is_monotonically_increasing = ap.index_delta * ap.index_delta - ap.index_delta; // deg 2\\n\\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.record_delta; // deg 2\\n\\n        evals[13] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n        evals[14] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n\\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\\n\\n        /**\\n         * Contributions 15,16,17\\n         * RAM Consistency Check\\n         *\\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\\n         * This is validated by requiring `access` to be boolean\\n         *\\n         * For two adjacent entries in the sorted list if _both_\\n         *  A) index values match\\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\\n         * then\\n         *  C) both values must match.\\n         * The gate boolean check is\\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\\n         *\\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\\n         * with a WRITE operation.\\n         */\\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\\n        ap.access_check = access_type * access_type - access_type; // check value is 0 or 1; deg 2 or 8\\n\\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\\n\\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (\\n            ap.index_delta * MINUS_ONE + Fr.wrap(1)\\n        ) * value_delta * (ap.next_gate_access_type * MINUS_ONE + Fr.wrap(1)); // deg 3 or 6\\n\\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\\n        // type is  correct, to cover this edge case\\n        // deg 2 or 4\\n        ap.next_gate_access_type_is_boolean =\\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\\n\\n        // Putting it all together...\\n        evals[15] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\\n            * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5 or 8\\n        evals[16] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4\\n        evals[17] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 6\\n\\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_ARITH)); // deg 3 or 9\\n\\n        /**\\n         * RAM Timestamp Consistency Check\\n         *\\n         * | w1 | w2 | w3 | w4 |\\n         * | index | timestamp | timestamp_check | -- |\\n         *\\n         * Let delta_index = index_{i + 1} - index_{i}\\n         *\\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\\n         * Else timestamp_check = 0\\n         */\\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\\n        ap.RAM_timestamp_check_identity =\\n            (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\\n\\n        /**\\n         * Complete Contribution 12\\n         * The complete RAM/ROM memory identity\\n         * Partial degree:\\n         */\\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\\n        ap.memory_identity =\\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\\n\\n        // (deg 3 or 9) + (deg 4) + (deg 3)\\n        ap.auxiliary_identity = ap.memory_identity + non_native_field_identity + limb_accumulator_identity;\\n        ap.auxiliary_identity = ap.auxiliary_identity * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 10\\n        evals[12] = ap.auxiliary_identity;\\n    }\\n\\n    struct PoseidonExternalParams {\\n        Fr s1;\\n        Fr s2;\\n        Fr s3;\\n        Fr s4;\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr t0;\\n        Fr t1;\\n        Fr t2;\\n        Fr t3;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonExternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonExternalParams memory ep;\\n\\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\\n\\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\\n        // matrix mul v = M_E * u with 14 additions\\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\\n        ep.v4 = ep.t1 + ep.t1;\\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\\n        ep.v2 = ep.t0 + ep.t0;\\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\\n\\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\\n        evals[18] = evals[18] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        evals[19] = evals[19] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    struct PoseidonInternalParams {\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr u_sum;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr s1;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonInternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonInternalParams memory ip;\\n\\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\\n        ];\\n\\n        // add round constants\\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n\\n        // apply s-box round\\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\\n        ip.u2 = wire(p, WIRE.W_R);\\n        ip.u3 = wire(p, WIRE.W_O);\\n        ip.u4 = wire(p, WIRE.W_4);\\n\\n        // matrix mul with v = M_I * u 4 muls and 7 additions\\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\\n\\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\\n\\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\\n        evals[22] = evals[22] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\\n        evals[23] = evals[23] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    function scaleAndBatchSubrelations(\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\\n    ) internal pure returns (Fr accumulator) {\\n        accumulator = accumulator + evaluations[0];\\n\\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\\n        }\\n    }\\n}\\n\\nstruct ShpleminiIntermediates {\\n    Fr unshiftedScalar;\\n    Fr shiftedScalar;\\n    // Scalar to be multiplied by [1]\\u2081\\n    Fr constantTermAccumulator;\\n    // Accumulator for powers of rho\\n    Fr batchingChallenge;\\n    // Linear combination of multilinear (sumcheck) evaluations and powers of rho\\n    Fr batchedEvaluation;\\n    // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr posInvertedDenominator;\\n    // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr negInvertedDenominator;\\n    // v^{2i} * 1/(z - r^{2^i})\\n    Fr scalingFactorPos;\\n    // v^{2i+1} * 1/(z + r^{2^i})\\n    Fr scalingFactorNeg;\\n    // // Fold_i(r^{2^i}) reconstructed by Verifier\\n    // Fr[CONST_PROOF_SIZE_LOG_N] foldPosEvaluations;\\n}\\n\\nlibrary CommitmentSchemeLib {\\n    using FrLib for Fr;\\n\\n    function computeSquares(Fr r) internal pure returns (Fr[CONST_PROOF_SIZE_LOG_N] memory squares) {\\n        squares[0] = r;\\n        for (uint256 i = 1; i < CONST_PROOF_SIZE_LOG_N; ++i) {\\n            squares[i] = squares[i - 1].sqr();\\n        }\\n    }\\n\\n    // Compute the evaluations  A_l(r^{2^l}) for l = 0, ..., m-1\\n    function computeFoldPosEvaluations(\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\\n        Fr batchedEvalAccumulator,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvalChallengePowers,\\n        uint256 logSize\\n    ) internal view returns (Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations) {\\n        for (uint256 i = CONST_PROOF_SIZE_LOG_N; i > 0; --i) {\\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\\n            Fr u = sumcheckUChallenges[i - 1];\\n\\n            Fr batchedEvalRoundAcc = (\\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\\n                    - geminiEvaluations[i - 1] * (challengePower * (Fr.wrap(1) - u) - u)\\n            );\\n            // Divide by the denominator\\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (Fr.wrap(1) - u) + u).invert();\\n\\n            if (i <= logSize) {\\n                batchedEvalAccumulator = batchedEvalRoundAcc;\\n                foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\\n            }\\n        }\\n\\n    }\\n}\\n\\ninterface IVerifier {\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);\\n}\\n\\n\\nabstract contract BaseHonkVerifier is IVerifier {\\n    using FrLib for Fr;\\n\\n    uint256 immutable n;\\n    uint256 immutable logN;\\n    uint256 immutable numPublicInputs;\\n\\n    constructor(uint256 _n, uint256 _logN, uint256 _numPublicInputs) {\\n        n = _n;\\n        logN = _logN;\\n        numPublicInputs = _numPublicInputs;\\n    }\\n\\n    error ProofLengthWrong();\\n    error PublicInputsLengthWrong();\\n    error SumcheckFailed();\\n    error ShpleminiFailed();\\n\\n    // Number of field elements in a ultra honk zero knowledge proof\\n    uint256 constant PROOF_SIZE = 440;\\n\\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\\n\\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs) public view override returns (bool) {\\n         // Check the received proof is the expected size where each field element is 32 bytes\\n        if (proof.length != PROOF_SIZE * 32) {\\n            revert ProofLengthWrong();\\n        }\\n\\n        Honk.VerificationKey memory vk = loadVerificationKey();\\n        Honk.Proof memory p = TranscriptLib.loadProof(proof);\\n\\n        if (publicInputs.length != vk.publicInputsSize) {\\n            revert PublicInputsLengthWrong();\\n        }\\n\\n        // Generate the fiat shamir challenges for the whole protocol\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        Transcript memory t = TranscriptLib.generateTranscript(p, publicInputs, vk.circuitSize, vk.publicInputsSize, /*pubInputsOffset=*/1);\\n\\n        // Derive public input delta\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\\n            publicInputs, t.relationParameters.beta, t.relationParameters.gamma, /*pubInputsOffset=*/1\\n        );\\n\\n        // Sumcheck\\n        bool sumcheckVerified = verifySumcheck(p, t);\\n        if (!sumcheckVerified) revert SumcheckFailed();\\n\\n        bool shpleminiVerified = verifyShplemini(p, vk, t);\\n        if (!shpleminiVerified) revert ShpleminiFailed();\\n\\n        return sumcheckVerified && shpleminiVerified; // Boolean condition not required - nice for vanity :)\\n    }\\n\\n    function computePublicInputDelta(bytes32[] memory publicInputs, Fr beta, Fr gamma, uint256 offset)\\n        internal\\n        view\\n        returns (Fr publicInputDelta)\\n    {\\n        Fr numerator = Fr.wrap(1);\\n        Fr denominator = Fr.wrap(1);\\n\\n        Fr numeratorAcc = gamma + (beta * FrLib.from(n + offset));\\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\\n\\n        {\\n            for (uint256 i = 0; i < numPublicInputs; i++) {\\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\\n\\n                numerator = numerator * (numeratorAcc + pubInput);\\n                denominator = denominator * (denominatorAcc + pubInput);\\n\\n                numeratorAcc = numeratorAcc + beta;\\n                denominatorAcc = denominatorAcc - beta;\\n            }\\n        }\\n\\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\\n        publicInputDelta = FrLib.div(numerator, denominator);\\n    }\\n\\n    function verifySumcheck(Honk.Proof memory proof, Transcript memory tp) internal view returns (bool verified) {\\n        Fr roundTarget;\\n        Fr powPartialEvaluation = Fr.wrap(1);\\n\\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\\n        for (uint256 round; round < logN; ++round) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\\n            bool valid = checkSum(roundUnivariate, roundTarget);\\n            if (!valid) revert SumcheckFailed();\\n\\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\\n\\n            // Update the round target for the next rounf\\n            roundTarget = computeNextTargetSum(roundUnivariate, roundChallenge);\\n            powPartialEvaluation = partiallyEvaluatePOW(tp.gateChallenges[round], powPartialEvaluation, roundChallenge);\\n        }\\n\\n        // Last round\\n        Fr grandHonkRelationSum =\\n            RelationsLib.accumulateRelationEvaluations(proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation);\\n        verified = (grandHonkRelationSum == roundTarget);\\n    }\\n\\n    function checkSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate, Fr roundTarget)\\n        internal\\n        pure\\n        returns (bool checked)\\n    {\\n        Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\\n        checked = totalSum == roundTarget;\\n    }\\n\\n    // Return the new target sum for the next sumcheck round\\n    function computeNextTargetSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\\n        internal\\n        view\\n        returns (Fr targetSum)\\n    {\\n        // TODO: inline\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000002d0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff11),\\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000090),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff71),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000000f0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000013b0)\\n        ];\\n\\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\\n\\n        // Performing Barycentric evaluations\\n        // Compute B(x)\\n        Fr numeratorValue = Fr.wrap(1);\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\\n        }\\n\\n        // Calculate domain size N of inverses\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr inv = BARYCENTRIC_LAGRANGE_DENOMINATORS[i];\\n            inv = inv * (roundChallenge - Fr.wrap(i));\\n            inv = FrLib.invert(inv);\\n            denominatorInverses[i] = inv;\\n        }\\n\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr term = roundUnivariates[i];\\n            term = term * denominatorInverses[i];\\n            targetSum = targetSum + term;\\n        }\\n\\n        // Scale the sum by the value of B(x)\\n        targetSum = targetSum * numeratorValue;\\n    }\\n\\n    // Univariate evaluation of the monomial ((1-X_l) + X_l.B_l) at the challenge point X_l=u_l\\n    function partiallyEvaluatePOW(Fr gateChallenge, Fr currentEvaluation, Fr roundChallenge)\\n        internal\\n        pure\\n        returns (Fr newEvaluation)\\n    {\\n        Fr univariateEval = Fr.wrap(1) + (roundChallenge * (gateChallenge - Fr.wrap(1)));\\n        newEvaluation = currentEvaluation * univariateEval;\\n    }\\n\\n    function verifyShplemini(Honk.Proof memory proof, Honk.VerificationKey memory vk, Transcript memory tp)\\n        internal\\n        view\\n        returns (bool verified)\\n    {\\n        ShpleminiIntermediates memory mem; // stack\\n\\n        // - Compute vector (r, r\\u00b2, ... , r\\u00b2\\u207d\\u207f\\u207b\\u00b9\\u207e), where n = log_circuit_size\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR);\\n\\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars;\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory commitments;\\n\\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\\n\\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.shiftedScalar =\\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\\n\\n        scalars[0] = Fr.wrap(1);\\n        commitments[0] = convertProofPoint(proof.shplonkQ);\\n\\n        mem.batchingChallenge = Fr.wrap(1);\\n        mem.batchedEvaluation = Fr.wrap(0);\\n\\n        for (uint256 i = 1; i <= NUMBER_UNSHIFTED; ++i) {\\n            scalars[i] = mem.unshiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n        // g commitments are accumulated at r\\n        for (uint256 i = NUMBER_UNSHIFTED + 1; i <= NUMBER_OF_ENTITIES; ++i) {\\n            scalars[i] = mem.shiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n\\n        commitments[1] = vk.qm;\\n        commitments[2] = vk.qc;\\n        commitments[3] = vk.ql;\\n        commitments[4] = vk.qr;\\n        commitments[5] = vk.qo;\\n        commitments[6] = vk.q4;\\n        commitments[7] = vk.qLookup;\\n        commitments[8] = vk.qArith;\\n        commitments[9] = vk.qDeltaRange;\\n        commitments[10] = vk.qElliptic;\\n        commitments[11] = vk.qAux;\\n        commitments[12] = vk.qPoseidon2External;\\n        commitments[13] = vk.qPoseidon2Internal;\\n        commitments[14] = vk.s1;\\n        commitments[15] = vk.s2;\\n        commitments[16] = vk.s3;\\n        commitments[17] = vk.s4;\\n        commitments[18] = vk.id1;\\n        commitments[19] = vk.id2;\\n        commitments[20] = vk.id3;\\n        commitments[21] = vk.id4;\\n        commitments[22] = vk.t1;\\n        commitments[23] = vk.t2;\\n        commitments[24] = vk.t3;\\n        commitments[25] = vk.t4;\\n        commitments[26] = vk.lagrangeFirst;\\n        commitments[27] = vk.lagrangeLast;\\n\\n        // Accumulate proof points\\n        commitments[28] = convertProofPoint(proof.w1);\\n        commitments[29] = convertProofPoint(proof.w2);\\n        commitments[30] = convertProofPoint(proof.w3);\\n        commitments[31] = convertProofPoint(proof.w4);\\n        commitments[32] = convertProofPoint(proof.zPerm);\\n        commitments[33] = convertProofPoint(proof.lookupInverses);\\n        commitments[34] = convertProofPoint(proof.lookupReadCounts);\\n        commitments[35] = convertProofPoint(proof.lookupReadTags);\\n\\n        // to be Shifted\\n        commitments[36] = convertProofPoint(proof.w1);\\n        commitments[37] = convertProofPoint(proof.w2);\\n        commitments[38] = convertProofPoint(proof.w3);\\n        commitments[39] = convertProofPoint(proof.w4);\\n        commitments[40] = convertProofPoint(proof.zPerm);\\n\\n        // Add contributions from A\\u2080(r) and A\\u2080(-r) to constant_term_accumulator:\\n        // Compute the evaluations A_l(r^{2^l}) for l = 0, ..., logN - 1\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\\n            tp.sumCheckUChallenges,\\n            mem.batchedEvaluation,\\n            proof.geminiAEvaluations,\\n            powers_of_evaluation_challenge,\\n            logN\\n        );\\n\\n        // Compute the Shplonk constant term contributions from A\\u2080(\\u00b1r)\\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\\n        mem.constantTermAccumulator =\\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.batchingChallenge = tp.shplonkNu.sqr();\\n\\n        // Compute Shplonk constant term contributions from A\\u2097(\\u00b1r^{2\\u02e1}) for l = 1, ..., m-1;\\n        // Compute scalar multipliers for each fold commitment\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {\\n            bool dummy_round = i >= (logN - 1);\\n\\n            if (!dummy_round) {\\n                // Update inverted denominators\\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\\n\\n                // Compute the scalar multipliers for A\\u2097(\\u00b1 r^{2\\u02e1}) and [A\\u2097]\\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\\n                // [A\\u2097] is multiplied by -v^{2l}/(z-r^{2^l}) - v^{2l+1} /(z+ r^{2^l})\\n                scalars[NUMBER_OF_ENTITIES + 1 + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\\n\\n                // Accumulate the const term contribution given by\\n                // v^{2l} * A\\u2097(r^{2\\u02e1}) /(z-r^{2^l}) + v^{2l+1} * A\\u2097(-r^{2\\u02e1}) /(z+ r^{2^l})\\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\\n                // Update the running power of v\\n                mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\\n            }\\n\\n            commitments[NUMBER_OF_ENTITIES + 1 + i] = convertProofPoint(proof.geminiFoldComms[i]);\\n        }\\n\\n        // Finalise the batch opening claim\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = Honk.G1Point({x: 1, y: 2});\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = mem.constantTermAccumulator;\\n\\n        Honk.G1Point memory quotient_commitment = convertProofPoint(proof.kzgQuotient);\\n\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = quotient_commitment;\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = tp.shplonkZ; // evaluation challenge\\n\\n        Honk.G1Point memory P_0 = batchMul(commitments, scalars);\\n        Honk.G1Point memory P_1 = negateInplace(quotient_commitment);\\n\\n        return pairing(P_0, P_1);\\n    }\\n\\n    // This implementation is the same as above with different constants\\n    function batchMul(\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory base,\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars\\n    ) internal view returns (Honk.G1Point memory result) {\\n        uint256 limit = NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2;\\n        assembly {\\n            let success := 0x01\\n            let free := mload(0x40)\\n\\n            // Write the original into the accumulator\\n            // Load into memory for ecMUL, leave offset for eccAdd result\\n            // base is an array of pointers, so we have to dereference them\\n            mstore(add(free, 0x40), mload(mload(base)))\\n            mstore(add(free, 0x60), mload(add(0x20, mload(base))))\\n            // Add scalar\\n            mstore(add(free, 0x80), mload(scalars))\\n            success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, free, 0x40))\\n\\n            let count := 0x01\\n            for {} lt(count, limit) { count := add(count, 1) } {\\n                // Get loop offsets\\n                let base_base := add(base, mul(count, 0x20))\\n                let scalar_base := add(scalars, mul(count, 0x20))\\n\\n                mstore(add(free, 0x40), mload(mload(base_base)))\\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\\n                // Add scalar\\n                mstore(add(free, 0x80), mload(scalar_base))\\n\\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\\n            }\\n\\n            // Return the result - i hate this\\n            mstore(result, mload(free))\\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\\n        }\\n    }\\n}\\n\\ncontract TransferVerifier is BaseHonkVerifier(N, LOG_N, NUMBER_OF_PUBLIC_INPUTS) {\\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\\n       return HonkVerificationKey.loadVerificationKey();\\n    }\\n}\\n\",\"keccak256\":\"0x16b0620f24944e45bbee2d50caf32d2308500d3f9402e00e972581524acba331\",\"license\":\"Apache-2.0\"},\"contracts/verifiers/WarpVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.21;\\n\\nuint256 constant N = 65536;\\nuint256 constant LOG_N = 16;\\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 13;\\nlibrary HonkVerificationKey {\\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\\n            circuitSize: uint256(65536),\\n            logCircuitSize: uint256(16),\\n            publicInputsSize: uint256(13),\\n            ql: Honk.G1Point({ \\n               x: uint256(0x1ce5284e57eec1da9390f763be54c15ebcc9511c2bc8d0fe967b6471d5a49db4),\\n               y: uint256(0x17327f894a0fc388fd74f65d5a69fe840a857bb5367f0af61f844068c85cbcab)\\n            }),\\n            qr: Honk.G1Point({ \\n               x: uint256(0x01f7756c8407551613a6557a694ff4092a6d1cae5279753b0b2568059efda594),\\n               y: uint256(0x099d2de120befdfa7c86d1ac1ee7de000342948ef7e71e8c29d38ab9a4eedaae)\\n            }),\\n            qo: Honk.G1Point({ \\n               x: uint256(0x2ac0b616d4f90412247f352b2316f28190ae20ba24cfa0559430a811e74be8de),\\n               y: uint256(0x016648857a68a54a015d7d00bbf0d0bf6a883141a07df9cbf22dd71045d60584)\\n            }),\\n            q4: Honk.G1Point({ \\n               x: uint256(0x2e2bf195f49357aa0feb52d610a4be7c379a61e8e7f5ba7ff5855c87fd9587a2),\\n               y: uint256(0x1900a6abd1f46261f7420c6da1811adf4d51678f9d177b2d89b81857c2ae3bbd)\\n            }),\\n            qm: Honk.G1Point({ \\n               x: uint256(0x013b87da999be2eb27cefc2d18d8dcc23da9b6fa0f1e71ae472defac67283990),\\n               y: uint256(0x08baeb05244c55b36905d963cb2758dded02b0112ec6f7344d9d4d34b4386cb4)\\n            }),\\n            qc: Honk.G1Point({ \\n               x: uint256(0x2af0a51c1df728b06fcd22ac53b1e9b415a4559b8394b6dc3f925c3dcbe2f529),\\n               y: uint256(0x0ce5afea23c8634da3281b1f4fb5940f46ddf42ca431273fe312382c885d2aac)\\n            }),\\n            qArith: Honk.G1Point({ \\n               x: uint256(0x1a4babb4de86b7107d2f365732c011cfd25d72fee62caed957c256630aa926d6),\\n               y: uint256(0x02281a8a3a9c0e34f82b4590ac1c84ffcc9e55f8ec04dec3f7951f61ff7849d0)\\n            }),\\n            qDeltaRange: Honk.G1Point({ \\n               x: uint256(0x1e1edaecd36dd220dda81f1375f23f5a6723af391d8fbc61292a332eb808c4f6),\\n               y: uint256(0x14d9e2bb53a9f54496670f3f0dc07d64fcf2d4664e55eb76ad683ada3193306b)\\n            }),\\n            qElliptic: Honk.G1Point({ \\n               x: uint256(0x09ab42c6175cc1d611f5067f3343c3948689c7d5d34ce9c37121ee7f33e80acb),\\n               y: uint256(0x0753a5089d10651a07d908418bcca07673e4d0004cdce4a6452419ddd80a17aa)\\n            }),\\n            qAux: Honk.G1Point({ \\n               x: uint256(0x0c61853d79cba01a0051b496804eb59744477b11ef651ca7d443e1f379c3679b),\\n               y: uint256(0x264d8f182b29e97472807954cf78b2fb0aaca11d894e4377b2262946605b1207)\\n            }),\\n            qLookup: Honk.G1Point({ \\n               x: uint256(0x2ccf97777978aa36adcdd05588e03d4de649085cda7fe019d46d0ec179c56274),\\n               y: uint256(0x0973ebba2ca18abf3ad084c6fc0c7ef2dccadbc4f0cb96e4c98e950a23e2b847)\\n            }),\\n            qPoseidon2External: Honk.G1Point({ \\n               x: uint256(0x0a78d787ca41356d680e3b40d1f6abeb3875792a0161a78d60e2e656a94bfda5),\\n               y: uint256(0x0565ced95de885ae641285c4ed01ec662544640f059206940c46dc0112c3afe3)\\n            }),\\n            qPoseidon2Internal: Honk.G1Point({ \\n               x: uint256(0x11c2beff37b28a9a0ac8b4e8769654529bf2f00e835c3b06174dd10b522cf38e),\\n               y: uint256(0x116e051d3ff0e148b17bbeff87ed952d9b9f4e1805b4fdd5c094c4609a23e647)\\n            }),\\n            s1: Honk.G1Point({ \\n               x: uint256(0x2b9112266371ac3a4621c2cacdbaafa864adf13e28a6e51e51326b25c13ca927),\\n               y: uint256(0x29b23d51fd5d69736f72fb677d1984d6a8c35b3a5fa12adbde849057a5978480)\\n            }),\\n            s2: Honk.G1Point({ \\n               x: uint256(0x0a9d3125792e07136651aad0cc0ecb4fcfe409503e374ef04755bb0c4b99f5ee),\\n               y: uint256(0x2c0535a17f3985cff93643f43f23d18416eb9cbc06321096ad3e54e4e0defccf)\\n            }),\\n            s3: Honk.G1Point({ \\n               x: uint256(0x18b96748b6c6908b8600182107ed8984b7d1759804eb883eeb0d6c8a3f3cc72d),\\n               y: uint256(0x1106380602c0ad3ada9e3ba9240be442b10c73843fce276f68117d3c86f8d066)\\n            }),\\n            s4: Honk.G1Point({ \\n               x: uint256(0x1ef88d9a16d9f6c0ddb090a6ecf7f7dcc4ff93f83d0bada7c4426d545d7544ee),\\n               y: uint256(0x02f2b9d56eb9d923aa6018c79322799095ea9328906dd1a2bad6a46e1dfb32c6)\\n            }),\\n            t1: Honk.G1Point({ \\n               x: uint256(0x2556e21486b5f6bd26f6c94db4b13368c505935644a97aa5e01aef1bb48a8c9b),\\n               y: uint256(0x2c1f41f10952cec3566549ee86a528106e4441bbe766efbf0f2c5132c050ea86)\\n            }),\\n            t2: Honk.G1Point({ \\n               x: uint256(0x2ab362ed7eca1658a620dc13c7c5afc7bf6fe13868b80beca9b2da2a058ce81a),\\n               y: uint256(0x2075d4f79b05b78ab63c7c9ed02a8667658d8459dd5ed2598ea1364481f76d3a)\\n            }),\\n            t3: Honk.G1Point({ \\n               x: uint256(0x057de5b29539e1d9385cb36aec6c0999e96da37647f1dae9abb090242e86f349),\\n               y: uint256(0x0313b277a78d70906d8b77fc8429a445a7e47116d4fd881a8989ec7bc5fc9248)\\n            }),\\n            t4: Honk.G1Point({ \\n               x: uint256(0x2002681bb417184b2df070a16a38589ce1faac6f8de6ebb18f1db17372c82ad5),\\n               y: uint256(0x0be0064399c2a1efff9eb0cdcb2223161baa651a8092e0e84725594de5aba511)\\n            }),\\n            id1: Honk.G1Point({ \\n               x: uint256(0x02edc30e825dcbca9cf927da1f9d94953b907c9edbd4a59b69b69afc2da512eb),\\n               y: uint256(0x2ac7c2a7662f9e63a7306e21105e5f99d0e5ea1b99137b2c2333e532a085e737)\\n            }),\\n            id2: Honk.G1Point({ \\n               x: uint256(0x2bd34de330da6a84ab0b67f0bfe66dc28df19bc42c15cbfb69d6ff73e96d5d00),\\n               y: uint256(0x2731729f2d082cbde2d0d0cf3bbf9f29e6a6fa27ad965cd6f60556fa94d43d0e)\\n            }),\\n            id3: Honk.G1Point({ \\n               x: uint256(0x1c390ea4deec29f5dc0e42ea75fb0b2035e50802ee926ad372108546611e1c5e),\\n               y: uint256(0x23f6be6d39d419a40a4a577b7b5cf69985f37d591210a23f60facf710764b562)\\n            }),\\n            id4: Honk.G1Point({ \\n               x: uint256(0x24061c7c7ec8b047df7923cbe5a954c0b9b8af8c070711c06e5951b550ae3e12),\\n               y: uint256(0x087222c70c9e82edc154234ac3d7644e20a94b0b73a8077b86b6d71d03749b82)\\n            }),\\n            lagrangeFirst: Honk.G1Point({ \\n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\\n            }),\\n            lagrangeLast: Honk.G1Point({ \\n               x: uint256(0x0c2255ea79e0493755b109f9cdc3fdeae17b367b9db741161893501fa267c59d),\\n               y: uint256(0x192f1cdc56f383d16a0c52b09b46b578f11fc3e530e3a9224637703a59daa08a)\\n            })\\n        });\\n        return vk;\\n    }\\n}\\n\\npragma solidity ^0.8.27;\\n\\ntype Fr is uint256;\\n\\nusing { add as + } for Fr global;\\nusing { sub as - } for Fr global;\\nusing { mul as * } for Fr global;\\nusing { exp as ^ } for Fr global;\\nusing { notEqual as != } for Fr global;\\nusing { equal as == } for Fr global;\\n\\nuint256 constant MODULUS =\\n    21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\\n\\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\\n\\n// Instantiation\\nlibrary FrLib\\n{\\n    function from(uint256 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(value % MODULUS);\\n    }\\n\\n    function fromBytes32(bytes32 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(uint256(value) % MODULUS);\\n    }\\n\\n    function toBytes32(Fr value) internal pure returns(bytes32)\\n    {\\n        return bytes32(Fr.unwrap(value));\\n    }\\n\\n    function invert(Fr value) internal view returns(Fr)\\n    {\\n        uint256 v = Fr.unwrap(value);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), v)\\n            mstore(add(free, 0x80), sub(MODULUS, 2))\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function pow(Fr base, uint256 v) internal view returns(Fr)\\n    {\\n        uint256 b = Fr.unwrap(base);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), b)\\n            mstore(add(free, 0x80), v)\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function div(Fr numerator, Fr denominator) internal view returns(Fr)\\n    {\\n        return numerator * invert(denominator);\\n    }\\n\\n    function sqr(Fr value) internal pure returns (Fr) {\\n        return value * value;\\n    }\\n\\n    function unwrap(Fr value) internal pure returns (uint256) {\\n        return Fr.unwrap(value);\\n    }\\n\\n    function neg(Fr value) internal pure returns (Fr) {\\n        return Fr.wrap(MODULUS - Fr.unwrap(value));\\n    }\\n}\\n\\n// Free functions\\nfunction add(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction mul(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction sub(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction exp(Fr base, Fr exponent) pure returns(Fr)\\n{\\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\\n\\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\\n        base = base * base;\\n    }\\n    return base;\\n}\\n\\nfunction notEqual(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) != Fr.unwrap(b);\\n}\\n\\nfunction equal(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) == Fr.unwrap(b);\\n}\\n\\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\\n\\nuint256 constant NUMBER_OF_SUBRELATIONS = 26;\\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\\nuint256 constant NUMBER_OF_ENTITIES = 40;\\nuint256 constant NUMBER_UNSHIFTED = 35;\\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\\n\\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\\nuint256 constant NUMBER_OF_ALPHAS = 25;\\n\\n// Prime field order\\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\\nuint256 constant P = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order, F_r\\n\\n// ENUM FOR WIRES\\nenum WIRE {\\n    Q_M,\\n    Q_C,\\n    Q_L,\\n    Q_R,\\n    Q_O,\\n    Q_4,\\n    Q_LOOKUP,\\n    Q_ARITH,\\n    Q_RANGE,\\n    Q_ELLIPTIC,\\n    Q_AUX,\\n    Q_POSEIDON2_EXTERNAL,\\n    Q_POSEIDON2_INTERNAL,\\n    SIGMA_1,\\n    SIGMA_2,\\n    SIGMA_3,\\n    SIGMA_4,\\n    ID_1,\\n    ID_2,\\n    ID_3,\\n    ID_4,\\n    TABLE_1,\\n    TABLE_2,\\n    TABLE_3,\\n    TABLE_4,\\n    LAGRANGE_FIRST,\\n    LAGRANGE_LAST,\\n    W_L,\\n    W_R,\\n    W_O,\\n    W_4,\\n    Z_PERM,\\n    LOOKUP_INVERSES,\\n    LOOKUP_READ_COUNTS,\\n    LOOKUP_READ_TAGS,\\n    W_L_SHIFT,\\n    W_R_SHIFT,\\n    W_O_SHIFT,\\n    W_4_SHIFT,\\n    Z_PERM_SHIFT\\n}\\n\\nlibrary Honk {\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    struct G1ProofPoint {\\n        uint256 x_0;\\n        uint256 x_1;\\n        uint256 y_0;\\n        uint256 y_1;\\n    }\\n\\n    struct VerificationKey {\\n        // Misc Params\\n        uint256 circuitSize;\\n        uint256 logCircuitSize;\\n        uint256 publicInputsSize;\\n        // Selectors\\n        G1Point qm;\\n        G1Point qc;\\n        G1Point ql;\\n        G1Point qr;\\n        G1Point qo;\\n        G1Point q4;\\n        G1Point qLookup; // Lookup\\n        G1Point qArith; // Arithmetic widget\\n        G1Point qDeltaRange; // Delta Range sort\\n        G1Point qAux; // Auxillary\\n        G1Point qElliptic; // Auxillary\\n        G1Point qPoseidon2External;\\n        G1Point qPoseidon2Internal;\\n        // Copy cnstraints\\n        G1Point s1;\\n        G1Point s2;\\n        G1Point s3;\\n        G1Point s4;\\n        // Copy identity\\n        G1Point id1;\\n        G1Point id2;\\n        G1Point id3;\\n        G1Point id4;\\n        // Precomputed lookup table\\n        G1Point t1;\\n        G1Point t2;\\n        G1Point t3;\\n        G1Point t4;\\n        // Fixed first and last\\n        G1Point lagrangeFirst;\\n        G1Point lagrangeLast;\\n    }\\n\\n    struct RelationParameters {\\n        // challenges\\n        Fr eta;\\n        Fr etaTwo;\\n        Fr etaThree;\\n        Fr beta;\\n        Fr gamma;\\n        // derived\\n        Fr publicInputsDelta;\\n    }\\n\\n\\n    struct Proof {\\n        // Free wires\\n        Honk.G1ProofPoint w1;\\n        Honk.G1ProofPoint w2;\\n        Honk.G1ProofPoint w3;\\n        Honk.G1ProofPoint w4;\\n        // Lookup helpers - Permutations\\n        Honk.G1ProofPoint zPerm;\\n        // Lookup helpers - logup\\n        Honk.G1ProofPoint lookupReadCounts;\\n        Honk.G1ProofPoint lookupReadTags;\\n        Honk.G1ProofPoint lookupInverses;\\n        // Sumcheck\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\\n        // Shplemini\\n        Honk.G1ProofPoint[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\\n        Honk.G1ProofPoint shplonkQ;\\n        Honk.G1ProofPoint kzgQuotient;\\n    }\\n}\\n\\n// Transcript library to generate fiat shamir challenges\\nstruct Transcript {\\n    // Oink\\n    Honk.RelationParameters relationParameters;\\n    Fr[NUMBER_OF_ALPHAS] alphas;\\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\\n    // Sumcheck\\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\\n    // Gemini\\n    Fr rho;\\n    Fr geminiR;\\n    // Shplonk\\n    Fr shplonkNu;\\n    Fr shplonkZ;\\n}\\n\\nlibrary TranscriptLib {\\n    function generateTranscript(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Transcript memory t)\\n    {\\n        Fr previousChallenge;\\n        (t.relationParameters, previousChallenge) =\\n            generateRelationParametersChallenges(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset, previousChallenge);\\n\\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\\n\\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge);\\n\\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge);\\n\\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\\n\\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge);\\n\\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge);\\n\\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\\n\\n        return t;\\n    }\\n\\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        uint256 hi = challengeU256 >> 128;\\n        first = FrLib.fromBytes32(bytes32(lo));\\n        second = FrLib.fromBytes32(bytes32(hi));\\n    }\\n\\n    function generateRelationParametersChallenges(\\n        Honk.Proof memory proof,\\n        bytes32[] calldata publicInputs,\\n        uint256 circuitSize,\\n        uint256 publicInputsSize,\\n        uint256 pubInputsOffset,\\n        Fr previousChallenge\\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\\n            generateEtaChallenge(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset);\\n\\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\\n\\n    }\\n\\n    function generateEtaChallenge(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge)\\n    {\\n        bytes32[] memory round0 = new bytes32[](3 + publicInputsSize + 12);\\n        round0[0] = bytes32(circuitSize);\\n        round0[1] = bytes32(publicInputsSize);\\n        round0[2] = bytes32(pubInputsOffset);\\n        for (uint256 i = 0; i < publicInputsSize; i++) {\\n            round0[3 + i] = bytes32(publicInputs[i]);\\n        }\\n\\n        // Create the first challenge\\n        // Note: w4 is added to the challenge later on\\n        round0[3 + publicInputsSize] = bytes32(proof.w1.x_0);\\n        round0[3 + publicInputsSize + 1] = bytes32(proof.w1.x_1);\\n        round0[3 + publicInputsSize + 2] = bytes32(proof.w1.y_0);\\n        round0[3 + publicInputsSize + 3] = bytes32(proof.w1.y_1);\\n        round0[3 + publicInputsSize + 4] = bytes32(proof.w2.x_0);\\n        round0[3 + publicInputsSize + 5] = bytes32(proof.w2.x_1);\\n        round0[3 + publicInputsSize + 6] = bytes32(proof.w2.y_0);\\n        round0[3 + publicInputsSize + 7] = bytes32(proof.w2.y_1);\\n        round0[3 + publicInputsSize + 8] = bytes32(proof.w3.x_0);\\n        round0[3 + publicInputsSize + 9] = bytes32(proof.w3.x_1);\\n        round0[3 + publicInputsSize + 10] = bytes32(proof.w3.y_0);\\n        round0[3 + publicInputsSize + 11] = bytes32(proof.w3.y_1);\\n\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\\n        (eta, etaTwo) = splitChallenge(previousChallenge);\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n        Fr unused;\\n        (etaThree, unused) = splitChallenge(previousChallenge);\\n    }\\n\\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\\n    {\\n        bytes32[13] memory round1;\\n        round1[0] = FrLib.toBytes32(previousChallenge);\\n        round1[1] = bytes32(proof.lookupReadCounts.x_0);\\n        round1[2] = bytes32(proof.lookupReadCounts.x_1);\\n        round1[3] = bytes32(proof.lookupReadCounts.y_0);\\n        round1[4] = bytes32(proof.lookupReadCounts.y_1);\\n        round1[5] = bytes32(proof.lookupReadTags.x_0);\\n        round1[6] = bytes32(proof.lookupReadTags.x_1);\\n        round1[7] = bytes32(proof.lookupReadTags.y_0);\\n        round1[8] = bytes32(proof.lookupReadTags.y_1);\\n        round1[9] = bytes32(proof.w4.x_0);\\n        round1[10] = bytes32(proof.w4.x_1);\\n        round1[11] = bytes32(proof.w4.y_0);\\n        round1[12] = bytes32(proof.w4.y_1);\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    // Alpha challenges non-linearise the gate contributions\\n    function generateAlphaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\\n    {\\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\\n        uint256[9] memory alpha0;\\n        alpha0[0] = Fr.unwrap(previousChallenge);\\n        alpha0[1] = proof.lookupInverses.x_0;\\n        alpha0[2] = proof.lookupInverses.x_1;\\n        alpha0[3] = proof.lookupInverses.y_0;\\n        alpha0[4] = proof.lookupInverses.y_1;\\n        alpha0[5] = proof.zPerm.x_0;\\n        alpha0[6] = proof.zPerm.x_1;\\n        alpha0[7] = proof.zPerm.y_0;\\n        alpha0[8] = proof.zPerm.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\\n        (alphas[0], alphas[1]) = splitChallenge(nextPreviousChallenge);\\n\\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS / 2; i++) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            (alphas[2 * i], alphas[2 * i + 1]) = splitChallenge(nextPreviousChallenge);\\n        }\\n        if (((NUMBER_OF_ALPHAS & 1) == 1) && (NUMBER_OF_ALPHAS > 2)) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            Fr unused;\\n            (alphas[NUMBER_OF_ALPHAS - 1], unused) = splitChallenge(nextPreviousChallenge);\\n        }\\n    }\\n\\n    function generateGateChallenges(Fr previousChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n            Fr unused;\\n            (gateChallenges[i], unused) = splitChallenge(previousChallenge);\\n        }\\n        nextPreviousChallenge = previousChallenge;\\n    }\\n\\n    function generateSumcheckChallenges(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\\n            univariateChal[0] = prevChallenge;\\n\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\\n            }\\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\\n            Fr unused;\\n            (sumcheckChallenges[i], unused) = splitChallenge(prevChallenge);\\n        }\\n        nextPreviousChallenge = prevChallenge;\\n    }\\n\\n    function generateRhoChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr rho, Fr nextPreviousChallenge)\\n    {\\n        Fr[NUMBER_OF_ENTITIES + 1] memory rhoChallengeElements;\\n        rhoChallengeElements[0] = prevChallenge;\\n\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            rhoChallengeElements[i + 1] = proof.sumcheckEvaluations[i];\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\\n        Fr unused;\\n        (rho, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateGeminiRChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr geminiR, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N - 1) * 4 + 1] memory gR;\\n        gR[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            gR[1 + i * 4] = proof.geminiFoldComms[i].x_0;\\n            gR[2 + i * 4] = proof.geminiFoldComms[i].x_1;\\n            gR[3 + i * 4] = proof.geminiFoldComms[i].y_0;\\n            gR[4 + i * 4] = proof.geminiFoldComms[i].y_1;\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\\n        Fr unused;\\n        (geminiR, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkNuChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N) + 1] memory shplonkNuChallengeElements;\\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            shplonkNuChallengeElements[i + 1] = Fr.unwrap(proof.geminiAEvaluations[i]);\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\\n        Fr unused;\\n        (shplonkNu, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkZChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\\n    {\\n        uint256[5] memory shplonkZChallengeElements;\\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        shplonkZChallengeElements[1] = proof.shplonkQ.x_0;\\n        shplonkZChallengeElements[2] = proof.shplonkQ.x_1;\\n        shplonkZChallengeElements[3] = proof.shplonkQ.y_0;\\n        shplonkZChallengeElements[4] = proof.shplonkQ.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\\n        Fr unused;\\n        (shplonkZ, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function loadProof(bytes calldata proof) internal pure returns (Honk.Proof memory p) {\\n        // Commitments\\n        p.w1 = bytesToG1ProofPoint(proof[0x0:0x80]);\\n\\n        p.w2 = bytesToG1ProofPoint(proof[0x80:0x100]);\\n        p.w3 = bytesToG1ProofPoint(proof[0x100:0x180]);\\n\\n        // Lookup / Permutation Helper Commitments\\n        p.lookupReadCounts = bytesToG1ProofPoint(proof[0x180:0x200]);\\n        p.lookupReadTags = bytesToG1ProofPoint(proof[0x200:0x280]);\\n        p.w4 = bytesToG1ProofPoint(proof[0x280:0x300]);\\n        p.lookupInverses = bytesToG1ProofPoint(proof[0x300:0x380]);\\n        p.zPerm = bytesToG1ProofPoint(proof[0x380:0x400]);\\n        uint256 boundary = 0x400;\\n\\n        // Sumcheck univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + 0x20]);\\n                boundary += 0x20;\\n            }\\n        }\\n        // Sumcheck evaluations\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Gemini\\n        // Read gemini fold univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            p.geminiFoldComms[i] = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n            boundary += 0x80;\\n        }\\n\\n        // Read gemini a evaluations\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Shplonk\\n        p.shplonkQ = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n        boundary = boundary + 0x80;\\n        // KZG\\n        p.kzgQuotient = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n    }\\n}\\n\\n\\n// Fr utility\\n\\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\\n    require(proofSection.length == 0x20, \\\"invalid bytes scalar\\\");\\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\\n}\\n\\n// EC Point utilities\\nfunction convertProofPoint(Honk.G1ProofPoint memory input) pure returns (Honk.G1Point memory) {\\n    return Honk.G1Point({x: input.x_0 | (input.x_1 << 136), y: input.y_0 | (input.y_1 << 136)});\\n}\\n\\nfunction bytesToG1ProofPoint(bytes calldata proofSection) pure returns (Honk.G1ProofPoint memory point) {\\n    require(proofSection.length == 0x80, \\\"invalid bytes point\\\");\\n    point = Honk.G1ProofPoint({\\n        x_0: uint256(bytes32(proofSection[0x00:0x20])),\\n        x_1: uint256(bytes32(proofSection[0x20:0x40])),\\n        y_0: uint256(bytes32(proofSection[0x40:0x60])),\\n        y_1: uint256(bytes32(proofSection[0x60:0x80]))\\n    });\\n}\\n\\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\\n    point.y = (Q - point.y) % Q;\\n    return point;\\n}\\n\\n function pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool) {\\n        bytes memory input = abi.encodePacked(\\n            rhs.x,\\n            rhs.y,\\n            // Fixed G1 point\\n            uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\\n            uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\\n            uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\\n            uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\\n            lhs.x,\\n            lhs.y,\\n            // G1 point from VK\\n            uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\\n            uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\\n            uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\\n            uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n        );\\n\\n        (bool success, bytes memory result) = address(0x08).staticcall(input);\\n        bool decodedResult = abi.decode(result, (bool));\\n        return success && decodedResult;\\n    }\\n\\n\\nlibrary RelationsLib {\\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\\n\\n    function accumulateRelationEvaluations(\\n         Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\\n        Fr powPartialEval\\n    ) internal pure returns (Fr accumulator) {\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\\n\\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateAuxillaryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\\n    }\\n\\n    /**\\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\\n     * editors, and thus is noisy.\\n     */\\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\\n        return p[uint256(_wire)];\\n    }\\n\\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    /**\\n     * Ultra Arithmetic Relation\\n     *\\n     */\\n    function accumulateArithmeticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        // Relation 0\\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\\n        {\\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\\n\\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\\n            accum = accum + (q_arith - Fr.wrap(1)) * wire(p, WIRE.W_4_SHIFT);\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[0] = accum;\\n        }\\n\\n        // Relation 1\\n        {\\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\\n            accum = accum * (q_arith - Fr.wrap(2));\\n            accum = accum * (q_arith - Fr.wrap(1));\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[1] = accum;\\n        }\\n    }\\n\\n    function accumulatePermutationRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr grand_product_numerator;\\n        Fr grand_product_denominator;\\n\\n        {\\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\\n\\n            grand_product_numerator = num;\\n        }\\n        {\\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\\n\\n            grand_product_denominator = den;\\n        }\\n\\n        // Contribution 2\\n        {\\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\\n\\n            acc = acc\\n                - (\\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\\n                        * grand_product_denominator\\n                );\\n            acc = acc * domainSep;\\n            evals[2] = acc;\\n        }\\n\\n        // Contribution 3\\n        {\\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\\n            evals[3] = acc;\\n        }\\n    }\\n\\n    function accumulateLogDerivativeLookupRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr write_term;\\n        Fr read_term;\\n\\n        // Calculate the write term (the table accumulation)\\n        {\\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\\n        }\\n\\n        // Calculate the write term\\n        {\\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\\n\\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\\n        }\\n\\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\\n\\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\\n\\n        // Inverse calculated correctly relation\\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\\n        accumulatorNone = accumulatorNone * domainSep;\\n\\n        // Inverse\\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\\n\\n        evals[4] = accumulatorNone;\\n        evals[5] = accumulatorOne;\\n    }\\n\\n    function accumulateDeltaRangeRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr minus_one = Fr.wrap(0) - Fr.wrap(1);\\n        Fr minus_two = Fr.wrap(0) - Fr.wrap(2);\\n        Fr minus_three = Fr.wrap(0) - Fr.wrap(3);\\n\\n        // Compute wire differences\\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\\n\\n        // Contribution 6\\n        {\\n            Fr acc = delta_1;\\n            acc = acc * (delta_1 + minus_one);\\n            acc = acc * (delta_1 + minus_two);\\n            acc = acc * (delta_1 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[6] = acc;\\n        }\\n\\n        // Contribution 7\\n        {\\n            Fr acc = delta_2;\\n            acc = acc * (delta_2 + minus_one);\\n            acc = acc * (delta_2 + minus_two);\\n            acc = acc * (delta_2 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[7] = acc;\\n        }\\n\\n        // Contribution 8\\n        {\\n            Fr acc = delta_3;\\n            acc = acc * (delta_3 + minus_one);\\n            acc = acc * (delta_3 + minus_two);\\n            acc = acc * (delta_3 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[8] = acc;\\n        }\\n\\n        // Contribution 9\\n        {\\n            Fr acc = delta_4;\\n            acc = acc * (delta_4 + minus_one);\\n            acc = acc * (delta_4 + minus_two);\\n            acc = acc * (delta_4 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[9] = acc;\\n        }\\n    }\\n\\n    struct EllipticParams {\\n        // Points\\n        Fr x_1;\\n        Fr y_1;\\n        Fr x_2;\\n        Fr y_2;\\n        Fr y_3;\\n        Fr x_3;\\n        // push accumulators into memory\\n        Fr x_double_identity;\\n    }\\n\\n    function accumulateEllipticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        EllipticParams memory ep;\\n        ep.x_1 = wire(p, WIRE.W_R);\\n        ep.y_1 = wire(p, WIRE.W_O);\\n\\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\\n\\n        Fr q_sign = wire(p, WIRE.Q_L);\\n        Fr q_is_double = wire(p, WIRE.Q_M);\\n\\n        // Contribution 10 point addition, x-coordinate check\\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n        Fr x_diff = (ep.x_2 - ep.x_1);\\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\\n        {\\n            // Move to top\\n            Fr partialEval = domainSep;\\n\\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\\n            x_add_identity = x_add_identity * x_diff * x_diff;\\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\\n\\n            evals[10] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 11 point addition, x-coordinate check\\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\\n        {\\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\\n            evals[11] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 10 point doubling, x-coordinate check\\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\\n        {\\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\\n\\n            // NOTE: pushed into memory (stack >:'( )\\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\\n\\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n            evals[10] = evals[10] + acc;\\n        }\\n\\n        // Contribution 11 point doubling, y-coordinate check\\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n        {\\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\\n            evals[11] = evals[11] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n        }\\n    }\\n\\n    // Constants for the auxiliary relation\\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\\n\\n    // Parameters used within the Auxiliary Relation\\n    // A struct is used to work around stack too deep. This relation has alot of variables\\n    struct AuxParams {\\n        Fr limb_subproduct;\\n        Fr non_native_field_gate_1;\\n        Fr non_native_field_gate_2;\\n        Fr non_native_field_gate_3;\\n        Fr limb_accumulator_1;\\n        Fr limb_accumulator_2;\\n        Fr memory_record_check;\\n        Fr partial_record_check;\\n        Fr next_gate_access_type;\\n        Fr record_delta;\\n        Fr index_delta;\\n        Fr adjacent_values_match_if_adjacent_indices_match;\\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n        Fr access_check;\\n        Fr next_gate_access_type_is_boolean;\\n        Fr ROM_consistency_check_identity;\\n        Fr RAM_consistency_check_identity;\\n        Fr timestamp_delta;\\n        Fr RAM_timestamp_check_identity;\\n        Fr memory_identity;\\n        Fr index_is_monotonically_increasing;\\n        Fr auxiliary_identity;\\n    }\\n\\n    function accumulateAuxillaryRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        AuxParams memory ap;\\n\\n        /**\\n         * Contribution 12\\n         * Non native field arithmetic gate 2\\n         * deg 4\\n         *\\n         *             _                                                                               _\\n         *            /   _                   _                               _       14                \\\\\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n         *            \\\\_                                                                               _/\\n         *\\n         *\\n         */\\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\\n        ap.non_native_field_gate_2 =\\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\\n\\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\\n\\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\\n\\n        Fr non_native_field_identity =\\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\\n\\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\\n        // deg 2\\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\\n\\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\\n        // deg 2\\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\\n\\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\\n\\n        /**\\n         * MEMORY\\n         *\\n         * A RAM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\\n         *  * v: `value` of memory cell being accessed\\n         *  * a: `access` type of record. read: 0 = read, 1 = write\\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\\n         *\\n         * A ROM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\\n         *\\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\\n         *\\n         *  | gate type | i  | v2/t  |  v | a  | r  |\\n         *  | --------- | -- | ----- | -- | -- | -- |\\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\\n         *\\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\\n         * `w2` to fix its value)\\n         *\\n         *\\n         */\\n\\n        /**\\n         * Memory Record Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * A ROM/ROM access gate can be evaluated with the identity:\\n         *\\n         * qc + w1 \\\\eta + w2 \\\\eta_two + w3 \\\\eta_three - w4 = 0\\n         *\\n         * For ROM gates, qc = 0\\n         */\\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\\n\\n        /**\\n         * Contribution 13 & 14\\n         * ROM Consistency Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\\n         * records that are sorted.\\n         *\\n         * We apply the following checks for the sorted records:\\n         *\\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\\n         * 2. index values for adjacent records are monotonically increasing\\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\\n         *\\n         */\\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\\n\\n        ap.index_is_monotonically_increasing = ap.index_delta * ap.index_delta - ap.index_delta; // deg 2\\n\\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.record_delta; // deg 2\\n\\n        evals[13] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n        evals[14] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n\\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\\n\\n        /**\\n         * Contributions 15,16,17\\n         * RAM Consistency Check\\n         *\\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\\n         * This is validated by requiring `access` to be boolean\\n         *\\n         * For two adjacent entries in the sorted list if _both_\\n         *  A) index values match\\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\\n         * then\\n         *  C) both values must match.\\n         * The gate boolean check is\\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\\n         *\\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\\n         * with a WRITE operation.\\n         */\\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\\n        ap.access_check = access_type * access_type - access_type; // check value is 0 or 1; deg 2 or 8\\n\\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\\n\\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (\\n            ap.index_delta * MINUS_ONE + Fr.wrap(1)\\n        ) * value_delta * (ap.next_gate_access_type * MINUS_ONE + Fr.wrap(1)); // deg 3 or 6\\n\\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\\n        // type is  correct, to cover this edge case\\n        // deg 2 or 4\\n        ap.next_gate_access_type_is_boolean =\\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\\n\\n        // Putting it all together...\\n        evals[15] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\\n            * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5 or 8\\n        evals[16] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4\\n        evals[17] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 6\\n\\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_ARITH)); // deg 3 or 9\\n\\n        /**\\n         * RAM Timestamp Consistency Check\\n         *\\n         * | w1 | w2 | w3 | w4 |\\n         * | index | timestamp | timestamp_check | -- |\\n         *\\n         * Let delta_index = index_{i + 1} - index_{i}\\n         *\\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\\n         * Else timestamp_check = 0\\n         */\\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\\n        ap.RAM_timestamp_check_identity =\\n            (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\\n\\n        /**\\n         * Complete Contribution 12\\n         * The complete RAM/ROM memory identity\\n         * Partial degree:\\n         */\\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\\n        ap.memory_identity =\\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\\n\\n        // (deg 3 or 9) + (deg 4) + (deg 3)\\n        ap.auxiliary_identity = ap.memory_identity + non_native_field_identity + limb_accumulator_identity;\\n        ap.auxiliary_identity = ap.auxiliary_identity * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 10\\n        evals[12] = ap.auxiliary_identity;\\n    }\\n\\n    struct PoseidonExternalParams {\\n        Fr s1;\\n        Fr s2;\\n        Fr s3;\\n        Fr s4;\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr t0;\\n        Fr t1;\\n        Fr t2;\\n        Fr t3;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonExternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonExternalParams memory ep;\\n\\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\\n\\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\\n        // matrix mul v = M_E * u with 14 additions\\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\\n        ep.v4 = ep.t1 + ep.t1;\\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\\n        ep.v2 = ep.t0 + ep.t0;\\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\\n\\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\\n        evals[18] = evals[18] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        evals[19] = evals[19] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    struct PoseidonInternalParams {\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr u_sum;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr s1;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonInternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonInternalParams memory ip;\\n\\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\\n        ];\\n\\n        // add round constants\\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n\\n        // apply s-box round\\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\\n        ip.u2 = wire(p, WIRE.W_R);\\n        ip.u3 = wire(p, WIRE.W_O);\\n        ip.u4 = wire(p, WIRE.W_4);\\n\\n        // matrix mul with v = M_I * u 4 muls and 7 additions\\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\\n\\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\\n\\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\\n        evals[22] = evals[22] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\\n        evals[23] = evals[23] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    function scaleAndBatchSubrelations(\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\\n    ) internal pure returns (Fr accumulator) {\\n        accumulator = accumulator + evaluations[0];\\n\\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\\n        }\\n    }\\n}\\n\\nstruct ShpleminiIntermediates {\\n    Fr unshiftedScalar;\\n    Fr shiftedScalar;\\n    // Scalar to be multiplied by [1]\\u2081\\n    Fr constantTermAccumulator;\\n    // Accumulator for powers of rho\\n    Fr batchingChallenge;\\n    // Linear combination of multilinear (sumcheck) evaluations and powers of rho\\n    Fr batchedEvaluation;\\n    // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr posInvertedDenominator;\\n    // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr negInvertedDenominator;\\n    // v^{2i} * 1/(z - r^{2^i})\\n    Fr scalingFactorPos;\\n    // v^{2i+1} * 1/(z + r^{2^i})\\n    Fr scalingFactorNeg;\\n    // // Fold_i(r^{2^i}) reconstructed by Verifier\\n    // Fr[CONST_PROOF_SIZE_LOG_N] foldPosEvaluations;\\n}\\n\\nlibrary CommitmentSchemeLib {\\n    using FrLib for Fr;\\n\\n    function computeSquares(Fr r) internal pure returns (Fr[CONST_PROOF_SIZE_LOG_N] memory squares) {\\n        squares[0] = r;\\n        for (uint256 i = 1; i < CONST_PROOF_SIZE_LOG_N; ++i) {\\n            squares[i] = squares[i - 1].sqr();\\n        }\\n    }\\n\\n    // Compute the evaluations  A_l(r^{2^l}) for l = 0, ..., m-1\\n    function computeFoldPosEvaluations(\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\\n        Fr batchedEvalAccumulator,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvalChallengePowers,\\n        uint256 logSize\\n    ) internal view returns (Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations) {\\n        for (uint256 i = CONST_PROOF_SIZE_LOG_N; i > 0; --i) {\\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\\n            Fr u = sumcheckUChallenges[i - 1];\\n\\n            Fr batchedEvalRoundAcc = (\\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\\n                    - geminiEvaluations[i - 1] * (challengePower * (Fr.wrap(1) - u) - u)\\n            );\\n            // Divide by the denominator\\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (Fr.wrap(1) - u) + u).invert();\\n\\n            if (i <= logSize) {\\n                batchedEvalAccumulator = batchedEvalRoundAcc;\\n                foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\\n            }\\n        }\\n\\n    }\\n}\\n\\ninterface IVerifier {\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);\\n}\\n\\n\\nabstract contract BaseHonkVerifier is IVerifier {\\n    using FrLib for Fr;\\n\\n    uint256 immutable n;\\n    uint256 immutable logN;\\n    uint256 immutable numPublicInputs;\\n\\n    constructor(uint256 _n, uint256 _logN, uint256 _numPublicInputs) {\\n        n = _n;\\n        logN = _logN;\\n        numPublicInputs = _numPublicInputs;\\n    }\\n\\n    error ProofLengthWrong();\\n    error PublicInputsLengthWrong();\\n    error SumcheckFailed();\\n    error ShpleminiFailed();\\n\\n    // Number of field elements in a ultra honk zero knowledge proof\\n    uint256 constant PROOF_SIZE = 440;\\n\\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\\n\\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs) public view override returns (bool) {\\n         // Check the received proof is the expected size where each field element is 32 bytes\\n        if (proof.length != PROOF_SIZE * 32) {\\n            revert ProofLengthWrong();\\n        }\\n\\n        Honk.VerificationKey memory vk = loadVerificationKey();\\n        Honk.Proof memory p = TranscriptLib.loadProof(proof);\\n\\n        if (publicInputs.length != vk.publicInputsSize) {\\n            revert PublicInputsLengthWrong();\\n        }\\n\\n        // Generate the fiat shamir challenges for the whole protocol\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        Transcript memory t = TranscriptLib.generateTranscript(p, publicInputs, vk.circuitSize, vk.publicInputsSize, /*pubInputsOffset=*/1);\\n\\n        // Derive public input delta\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\\n            publicInputs, t.relationParameters.beta, t.relationParameters.gamma, /*pubInputsOffset=*/1\\n        );\\n\\n        // Sumcheck\\n        bool sumcheckVerified = verifySumcheck(p, t);\\n        if (!sumcheckVerified) revert SumcheckFailed();\\n\\n        bool shpleminiVerified = verifyShplemini(p, vk, t);\\n        if (!shpleminiVerified) revert ShpleminiFailed();\\n\\n        return sumcheckVerified && shpleminiVerified; // Boolean condition not required - nice for vanity :)\\n    }\\n\\n    function computePublicInputDelta(bytes32[] memory publicInputs, Fr beta, Fr gamma, uint256 offset)\\n        internal\\n        view\\n        returns (Fr publicInputDelta)\\n    {\\n        Fr numerator = Fr.wrap(1);\\n        Fr denominator = Fr.wrap(1);\\n\\n        Fr numeratorAcc = gamma + (beta * FrLib.from(n + offset));\\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\\n\\n        {\\n            for (uint256 i = 0; i < numPublicInputs; i++) {\\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\\n\\n                numerator = numerator * (numeratorAcc + pubInput);\\n                denominator = denominator * (denominatorAcc + pubInput);\\n\\n                numeratorAcc = numeratorAcc + beta;\\n                denominatorAcc = denominatorAcc - beta;\\n            }\\n        }\\n\\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\\n        publicInputDelta = FrLib.div(numerator, denominator);\\n    }\\n\\n    function verifySumcheck(Honk.Proof memory proof, Transcript memory tp) internal view returns (bool verified) {\\n        Fr roundTarget;\\n        Fr powPartialEvaluation = Fr.wrap(1);\\n\\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\\n        for (uint256 round; round < logN; ++round) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\\n            bool valid = checkSum(roundUnivariate, roundTarget);\\n            if (!valid) revert SumcheckFailed();\\n\\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\\n\\n            // Update the round target for the next rounf\\n            roundTarget = computeNextTargetSum(roundUnivariate, roundChallenge);\\n            powPartialEvaluation = partiallyEvaluatePOW(tp.gateChallenges[round], powPartialEvaluation, roundChallenge);\\n        }\\n\\n        // Last round\\n        Fr grandHonkRelationSum =\\n            RelationsLib.accumulateRelationEvaluations(proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation);\\n        verified = (grandHonkRelationSum == roundTarget);\\n    }\\n\\n    function checkSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate, Fr roundTarget)\\n        internal\\n        pure\\n        returns (bool checked)\\n    {\\n        Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\\n        checked = totalSum == roundTarget;\\n    }\\n\\n    // Return the new target sum for the next sumcheck round\\n    function computeNextTargetSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\\n        internal\\n        view\\n        returns (Fr targetSum)\\n    {\\n        // TODO: inline\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000002d0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff11),\\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000090),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff71),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000000f0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000013b0)\\n        ];\\n\\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\\n\\n        // Performing Barycentric evaluations\\n        // Compute B(x)\\n        Fr numeratorValue = Fr.wrap(1);\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\\n        }\\n\\n        // Calculate domain size N of inverses\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr inv = BARYCENTRIC_LAGRANGE_DENOMINATORS[i];\\n            inv = inv * (roundChallenge - Fr.wrap(i));\\n            inv = FrLib.invert(inv);\\n            denominatorInverses[i] = inv;\\n        }\\n\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr term = roundUnivariates[i];\\n            term = term * denominatorInverses[i];\\n            targetSum = targetSum + term;\\n        }\\n\\n        // Scale the sum by the value of B(x)\\n        targetSum = targetSum * numeratorValue;\\n    }\\n\\n    // Univariate evaluation of the monomial ((1-X_l) + X_l.B_l) at the challenge point X_l=u_l\\n    function partiallyEvaluatePOW(Fr gateChallenge, Fr currentEvaluation, Fr roundChallenge)\\n        internal\\n        pure\\n        returns (Fr newEvaluation)\\n    {\\n        Fr univariateEval = Fr.wrap(1) + (roundChallenge * (gateChallenge - Fr.wrap(1)));\\n        newEvaluation = currentEvaluation * univariateEval;\\n    }\\n\\n    function verifyShplemini(Honk.Proof memory proof, Honk.VerificationKey memory vk, Transcript memory tp)\\n        internal\\n        view\\n        returns (bool verified)\\n    {\\n        ShpleminiIntermediates memory mem; // stack\\n\\n        // - Compute vector (r, r\\u00b2, ... , r\\u00b2\\u207d\\u207f\\u207b\\u00b9\\u207e), where n = log_circuit_size\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR);\\n\\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars;\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory commitments;\\n\\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\\n\\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.shiftedScalar =\\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\\n\\n        scalars[0] = Fr.wrap(1);\\n        commitments[0] = convertProofPoint(proof.shplonkQ);\\n\\n        mem.batchingChallenge = Fr.wrap(1);\\n        mem.batchedEvaluation = Fr.wrap(0);\\n\\n        for (uint256 i = 1; i <= NUMBER_UNSHIFTED; ++i) {\\n            scalars[i] = mem.unshiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n        // g commitments are accumulated at r\\n        for (uint256 i = NUMBER_UNSHIFTED + 1; i <= NUMBER_OF_ENTITIES; ++i) {\\n            scalars[i] = mem.shiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n\\n        commitments[1] = vk.qm;\\n        commitments[2] = vk.qc;\\n        commitments[3] = vk.ql;\\n        commitments[4] = vk.qr;\\n        commitments[5] = vk.qo;\\n        commitments[6] = vk.q4;\\n        commitments[7] = vk.qLookup;\\n        commitments[8] = vk.qArith;\\n        commitments[9] = vk.qDeltaRange;\\n        commitments[10] = vk.qElliptic;\\n        commitments[11] = vk.qAux;\\n        commitments[12] = vk.qPoseidon2External;\\n        commitments[13] = vk.qPoseidon2Internal;\\n        commitments[14] = vk.s1;\\n        commitments[15] = vk.s2;\\n        commitments[16] = vk.s3;\\n        commitments[17] = vk.s4;\\n        commitments[18] = vk.id1;\\n        commitments[19] = vk.id2;\\n        commitments[20] = vk.id3;\\n        commitments[21] = vk.id4;\\n        commitments[22] = vk.t1;\\n        commitments[23] = vk.t2;\\n        commitments[24] = vk.t3;\\n        commitments[25] = vk.t4;\\n        commitments[26] = vk.lagrangeFirst;\\n        commitments[27] = vk.lagrangeLast;\\n\\n        // Accumulate proof points\\n        commitments[28] = convertProofPoint(proof.w1);\\n        commitments[29] = convertProofPoint(proof.w2);\\n        commitments[30] = convertProofPoint(proof.w3);\\n        commitments[31] = convertProofPoint(proof.w4);\\n        commitments[32] = convertProofPoint(proof.zPerm);\\n        commitments[33] = convertProofPoint(proof.lookupInverses);\\n        commitments[34] = convertProofPoint(proof.lookupReadCounts);\\n        commitments[35] = convertProofPoint(proof.lookupReadTags);\\n\\n        // to be Shifted\\n        commitments[36] = convertProofPoint(proof.w1);\\n        commitments[37] = convertProofPoint(proof.w2);\\n        commitments[38] = convertProofPoint(proof.w3);\\n        commitments[39] = convertProofPoint(proof.w4);\\n        commitments[40] = convertProofPoint(proof.zPerm);\\n\\n        // Add contributions from A\\u2080(r) and A\\u2080(-r) to constant_term_accumulator:\\n        // Compute the evaluations A_l(r^{2^l}) for l = 0, ..., logN - 1\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\\n            tp.sumCheckUChallenges,\\n            mem.batchedEvaluation,\\n            proof.geminiAEvaluations,\\n            powers_of_evaluation_challenge,\\n            logN\\n        );\\n\\n        // Compute the Shplonk constant term contributions from A\\u2080(\\u00b1r)\\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\\n        mem.constantTermAccumulator =\\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.batchingChallenge = tp.shplonkNu.sqr();\\n\\n        // Compute Shplonk constant term contributions from A\\u2097(\\u00b1r^{2\\u02e1}) for l = 1, ..., m-1;\\n        // Compute scalar multipliers for each fold commitment\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {\\n            bool dummy_round = i >= (logN - 1);\\n\\n            if (!dummy_round) {\\n                // Update inverted denominators\\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\\n\\n                // Compute the scalar multipliers for A\\u2097(\\u00b1 r^{2\\u02e1}) and [A\\u2097]\\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\\n                // [A\\u2097] is multiplied by -v^{2l}/(z-r^{2^l}) - v^{2l+1} /(z+ r^{2^l})\\n                scalars[NUMBER_OF_ENTITIES + 1 + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\\n\\n                // Accumulate the const term contribution given by\\n                // v^{2l} * A\\u2097(r^{2\\u02e1}) /(z-r^{2^l}) + v^{2l+1} * A\\u2097(-r^{2\\u02e1}) /(z+ r^{2^l})\\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\\n                // Update the running power of v\\n                mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\\n            }\\n\\n            commitments[NUMBER_OF_ENTITIES + 1 + i] = convertProofPoint(proof.geminiFoldComms[i]);\\n        }\\n\\n        // Finalise the batch opening claim\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = Honk.G1Point({x: 1, y: 2});\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = mem.constantTermAccumulator;\\n\\n        Honk.G1Point memory quotient_commitment = convertProofPoint(proof.kzgQuotient);\\n\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = quotient_commitment;\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = tp.shplonkZ; // evaluation challenge\\n\\n        Honk.G1Point memory P_0 = batchMul(commitments, scalars);\\n        Honk.G1Point memory P_1 = negateInplace(quotient_commitment);\\n\\n        return pairing(P_0, P_1);\\n    }\\n\\n    // This implementation is the same as above with different constants\\n    function batchMul(\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory base,\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars\\n    ) internal view returns (Honk.G1Point memory result) {\\n        uint256 limit = NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2;\\n        assembly {\\n            let success := 0x01\\n            let free := mload(0x40)\\n\\n            // Write the original into the accumulator\\n            // Load into memory for ecMUL, leave offset for eccAdd result\\n            // base is an array of pointers, so we have to dereference them\\n            mstore(add(free, 0x40), mload(mload(base)))\\n            mstore(add(free, 0x60), mload(add(0x20, mload(base))))\\n            // Add scalar\\n            mstore(add(free, 0x80), mload(scalars))\\n            success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, free, 0x40))\\n\\n            let count := 0x01\\n            for {} lt(count, limit) { count := add(count, 1) } {\\n                // Get loop offsets\\n                let base_base := add(base, mul(count, 0x20))\\n                let scalar_base := add(scalars, mul(count, 0x20))\\n\\n                mstore(add(free, 0x40), mload(mload(base_base)))\\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\\n                // Add scalar\\n                mstore(add(free, 0x80), mload(scalar_base))\\n\\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\\n            }\\n\\n            // Return the result - i hate this\\n            mstore(result, mload(free))\\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\\n        }\\n    }\\n}\\n\\ncontract WarpVerifier is BaseHonkVerifier(N, LOG_N, NUMBER_OF_PUBLIC_INPUTS) {\\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\\n       return HonkVerificationKey.loadVerificationKey();\\n    }\\n}\\n\",\"keccak256\":\"0x6505edc0cb6e78ed55e31655e09d3aa9ef8412d8e7931ac5d8f1b357a133999b\",\"license\":\"Apache-2.0\"},\"contracts/verifiers/WithdrawVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\n// Copyright 2022 Aztec\\npragma solidity >=0.8.21;\\n\\nuint256 constant N = 4096;\\nuint256 constant LOG_N = 12;\\nuint256 constant NUMBER_OF_PUBLIC_INPUTS = 16;\\nlibrary HonkVerificationKey {\\n    function loadVerificationKey() internal pure returns (Honk.VerificationKey memory) {\\n        Honk.VerificationKey memory vk = Honk.VerificationKey({\\n            circuitSize: uint256(4096),\\n            logCircuitSize: uint256(12),\\n            publicInputsSize: uint256(16),\\n            ql: Honk.G1Point({ \\n               x: uint256(0x1168a21bccccb62c8eba4882b480dd731a9ad07b75082b751c16033fd83fe053),\\n               y: uint256(0x289847693233333a6a62f946bfd1f9bf72ab52b7e9fec4dd7db0398623e2a22a)\\n            }),\\n            qr: Honk.G1Point({ \\n               x: uint256(0x047fa5d34be4ca099a52a5c47812daf28b7d55d64c377f4fa8158dbfc46cc5bf),\\n               y: uint256(0x19b5b52e46e881641f88909460df7404186d83c53b509170957107c5a71cf469)\\n            }),\\n            qo: Honk.G1Point({ \\n               x: uint256(0x1691734df3dc95622c71c75530885eabde66197e9193a5586f666909067fe013),\\n               y: uint256(0x196d9b453ffaa6278f4745618281aa360a10a50504b510d43e443522af6306af)\\n            }),\\n            q4: Honk.G1Point({ \\n               x: uint256(0x2935c2047daa69e60aeffa109e991d36d6c4035d3f2fab334528fc8ccf0616a3),\\n               y: uint256(0x10e07c6bd862e8b3919aaac5da715e58eeb0691d24b01ddf87d9c5659a5bc6e9)\\n            }),\\n            qm: Honk.G1Point({ \\n               x: uint256(0x118ef3e5fb359996b228f796c13331452ac585226069145196249402659ebc51),\\n               y: uint256(0x171924a585a0c305b7233029aee74892479a9025cc3fb13fb734ca828f231eb2)\\n            }),\\n            qc: Honk.G1Point({ \\n               x: uint256(0x1964f25928302ee321cbfdb0291dc5232b4b9210ba0f4e93d692709675b9b36e),\\n               y: uint256(0x047d1ff2a6c907ad97810276724d9dcc02da20e01f50d6d3a903b82e8a74bcec)\\n            }),\\n            qArith: Honk.G1Point({ \\n               x: uint256(0x1ffd1625b5f60dbc8e97d7977b1adcc647878e8049742de62b2e902c3e3abb98),\\n               y: uint256(0x034f60a0f225daad086ee07b062fd304010ac4d927b9b0824498a1508cb762ae)\\n            }),\\n            qDeltaRange: Honk.G1Point({ \\n               x: uint256(0x25ba14ed8b453eb58052d27bc923cfceb669b29e19e24fb04c19671ad8dc629b),\\n               y: uint256(0x011be1fc199e075119bd1c11b46d183ca7accea8f9eb50b2f79ef3205ab59c13)\\n            }),\\n            qElliptic: Honk.G1Point({ \\n               x: uint256(0x2c6ffadedade6bd791d05d2b288620b914328a4c5a603942ae15d8e6f92635ac),\\n               y: uint256(0x2623a92a9a47d40333cc721e8bc81d5acdb670c0a3a29b4ea036654a8fdfc30a)\\n            }),\\n            qAux: Honk.G1Point({ \\n               x: uint256(0x1b891590a063297d7436a51f725ed1e2771c2246c0e4f5a69ea0fd4e9dc534e8),\\n               y: uint256(0x2c1378d8000c7aa69dee830127818002b7f719f57da9102ee07168833e4f2d9e)\\n            }),\\n            qLookup: Honk.G1Point({ \\n               x: uint256(0x17c6d9d50e48678a2ac344538de4c7ece661d9ddf8d6ce71e63ee377b120f70f),\\n               y: uint256(0x19c51b736e4c5a7d8380246160d19aad54bcdd8f21bebc775e9dfb36b9a73d45)\\n            }),\\n            qPoseidon2External: Honk.G1Point({ \\n               x: uint256(0x0074407a779294298c588f1039481e1053f82a4b47df79f5cda5bcf16932c8b5),\\n               y: uint256(0x1296476007e165dff1edf3532a2b67f9fb71d62d272e7aebf2bafad3d590651b)\\n            }),\\n            qPoseidon2Internal: Honk.G1Point({ \\n               x: uint256(0x058cbfeffd442a8aa53c913ece8aa44261d89e0cb268d2f9bbac0ce3e05038a2),\\n               y: uint256(0x0a8cfbdc13a02c94b7d0826893e5e04fd4cfec9424b4ca902ca686d0d767c0cb)\\n            }),\\n            s1: Honk.G1Point({ \\n               x: uint256(0x224ff00bc02c0087816e66c1c1f0c048bef12f857e8a4f4eddafe97e12cc9bd8),\\n               y: uint256(0x16152a6837014c61fd55e6973eb4309317ba0d1c28f184bbc960486ec420b53e)\\n            }),\\n            s2: Honk.G1Point({ \\n               x: uint256(0x11eaf2aad2271b02fe28b0ba11a2a699f88fc0fe2942e9dd6444741de4df5549),\\n               y: uint256(0x164e8c1d562964f084a433b8b6cb90ee6dab5a5d25b152d88c5a1053164fbebb)\\n            }),\\n            s3: Honk.G1Point({ \\n               x: uint256(0x26a97ad4f31a63c21aca44b92847f6b93027dbc9521c92cd2a1e9b3dc64b8d73),\\n               y: uint256(0x1a257bdd0ee0fee68b2c5ed5703961d4667efd43026d648a9c77a5363a56cb5d)\\n            }),\\n            s4: Honk.G1Point({ \\n               x: uint256(0x2e1bebfba104ec9b5b73b085e8cfd3e4c9c6b364e18437ecd2adfe8caeed581e),\\n               y: uint256(0x0f356418ea731a572fe77b864deb1d6148d131999a602136dec90b6c1caa1e83)\\n            }),\\n            t1: Honk.G1Point({ \\n               x: uint256(0x1f1156b93b4396e0dac3bd312fdc94243cf3e0cfba606d27d5999f4927ff92b3),\\n               y: uint256(0x116a7935196d39ea9178a285c53a6b419d9961d76a65ed28914ca5cc3ffd2433)\\n            }),\\n            t2: Honk.G1Point({ \\n               x: uint256(0x23aebc5efc1d0e6d03030b242308fdf369409c76a0245d4f389193b554c30065),\\n               y: uint256(0x19f38f8e7cf18f375d75db06fca92a0cbfc1214af084c189478e34dc04c77419)\\n            }),\\n            t3: Honk.G1Point({ \\n               x: uint256(0x15642d62fc17d119ba4afb77ab424e0a771b5bbb501c75790a1a4e2906931045),\\n               y: uint256(0x21cea98314ec6efc5f8f1f648f42a7a5c1396036397af54a729801cc1c37d4e2)\\n            }),\\n            t4: Honk.G1Point({ \\n               x: uint256(0x1f3bd0ebf0709ac30745d0dafb183cdd5b4a42e59fe1e447cad24659049d13a7),\\n               y: uint256(0x05900180ddd1cec6e340c70c9bff6f16c2efd51d298fee5fce4355fc26890195)\\n            }),\\n            id1: Honk.G1Point({ \\n               x: uint256(0x29cbed7087b772afbab7b9fead491c49eb2875b379e92aed9a0bea7b29ac554b),\\n               y: uint256(0x1caccb1ac5e0b69c8f20d5b6d7719a7412ed6190783f32b5ad26237f20a7b293)\\n            }),\\n            id2: Honk.G1Point({ \\n               x: uint256(0x0976effccb6a71f22c277603aa271a5da0ce903e5ea36adb7f5e83b098b595c5),\\n               y: uint256(0x0b6a1c20ed4582b91f7a9c2015e080983d28f1771e5e51141e1ccfa5db3f6308)\\n            }),\\n            id3: Honk.G1Point({ \\n               x: uint256(0x2036cee78bdcc4b74e8c8c55681a9e7bdf01d14bbc4cae866fada1607c5da6f4),\\n               y: uint256(0x06eb876c05faf21705a9d0109057ad1758a9f36907cb738edd4e75737ca89a16)\\n            }),\\n            id4: Honk.G1Point({ \\n               x: uint256(0x1c4e769a651c395fa8b9871f215e60c73624bee2872fc732f07827b16ff50103),\\n               y: uint256(0x2446dd78e6a5b21801317528210852ada90d48316a3ed9eea3ad667f370781a5)\\n            }),\\n            lagrangeFirst: Honk.G1Point({ \\n               x: uint256(0x0000000000000000000000000000000000000000000000000000000000000001),\\n               y: uint256(0x0000000000000000000000000000000000000000000000000000000000000002)\\n            }),\\n            lagrangeLast: Honk.G1Point({ \\n               x: uint256(0x0af1e0c46a2ec7edb75410c62febfa2c8d796347d571cbeab2231a5ee822aa38),\\n               y: uint256(0x15fca0b1c078eb810392f4f315136d8c02b74d2cdc8b40e3433e6feed8cc0cb6)\\n            })\\n        });\\n        return vk;\\n    }\\n}\\n\\npragma solidity ^0.8.27;\\n\\ntype Fr is uint256;\\n\\nusing { add as + } for Fr global;\\nusing { sub as - } for Fr global;\\nusing { mul as * } for Fr global;\\nusing { exp as ^ } for Fr global;\\nusing { notEqual as != } for Fr global;\\nusing { equal as == } for Fr global;\\n\\nuint256 constant MODULUS =\\n    21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order\\n\\nFr constant MINUS_ONE = Fr.wrap(MODULUS - 1);\\n\\n// Instantiation\\nlibrary FrLib\\n{\\n    function from(uint256 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(value % MODULUS);\\n    }\\n\\n    function fromBytes32(bytes32 value) internal pure returns(Fr)\\n    {\\n        return Fr.wrap(uint256(value) % MODULUS);\\n    }\\n\\n    function toBytes32(Fr value) internal pure returns(bytes32)\\n    {\\n        return bytes32(Fr.unwrap(value));\\n    }\\n\\n    function invert(Fr value) internal view returns(Fr)\\n    {\\n        uint256 v = Fr.unwrap(value);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), v)\\n            mstore(add(free, 0x80), sub(MODULUS, 2))\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function pow(Fr base, uint256 v) internal view returns(Fr)\\n    {\\n        uint256 b = Fr.unwrap(base);\\n        uint256 result;\\n\\n        // Call the modexp precompile to invert in the field\\n        assembly\\n        {\\n            let free := mload(0x40)\\n            mstore(free, 0x20)\\n            mstore(add(free, 0x20), 0x20)\\n            mstore(add(free, 0x40), 0x20)\\n            mstore(add(free, 0x60), b)\\n            mstore(add(free, 0x80), v)\\n            mstore(add(free, 0xa0), MODULUS)\\n            let success := staticcall(gas(), 0x05, free, 0xc0, 0x00, 0x20)\\n            if iszero(success) {\\n                revert(0, 0)\\n            }\\n            result := mload(0x00)\\n        }\\n\\n        return Fr.wrap(result);\\n    }\\n\\n    function div(Fr numerator, Fr denominator) internal view returns(Fr)\\n    {\\n        return numerator * invert(denominator);\\n    }\\n\\n    function sqr(Fr value) internal pure returns (Fr) {\\n        return value * value;\\n    }\\n\\n    function unwrap(Fr value) internal pure returns (uint256) {\\n        return Fr.unwrap(value);\\n    }\\n\\n    function neg(Fr value) internal pure returns (Fr) {\\n        return Fr.wrap(MODULUS - Fr.unwrap(value));\\n    }\\n}\\n\\n// Free functions\\nfunction add(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction mul(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(mulmod(Fr.unwrap(a), Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction sub(Fr a, Fr b) pure returns(Fr)\\n{\\n    return Fr.wrap(addmod(Fr.unwrap(a), MODULUS - Fr.unwrap(b), MODULUS));\\n}\\n\\nfunction exp(Fr base, Fr exponent) pure returns(Fr)\\n{\\n    if (Fr.unwrap(exponent) == 0) return Fr.wrap(1);\\n\\n    for (uint256 i = 1; i < Fr.unwrap(exponent); i += i) {\\n        base = base * base;\\n    }\\n    return base;\\n}\\n\\nfunction notEqual(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) != Fr.unwrap(b);\\n}\\n\\nfunction equal(Fr a, Fr b) pure returns(bool)\\n{\\n    return Fr.unwrap(a) == Fr.unwrap(b);\\n}\\n\\nuint256 constant CONST_PROOF_SIZE_LOG_N = 28;\\n\\nuint256 constant NUMBER_OF_SUBRELATIONS = 26;\\nuint256 constant BATCHED_RELATION_PARTIAL_LENGTH = 8;\\nuint256 constant NUMBER_OF_ENTITIES = 40;\\nuint256 constant NUMBER_UNSHIFTED = 35;\\nuint256 constant NUMBER_TO_BE_SHIFTED = 5;\\n\\n// Alphas are used as relation separators so there should be NUMBER_OF_SUBRELATIONS - 1\\nuint256 constant NUMBER_OF_ALPHAS = 25;\\n\\n// Prime field order\\nuint256 constant Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583; // EC group order. F_q\\nuint256 constant P = 21888242871839275222246405745257275088548364400416034343698204186575808495617; // Prime field order, F_r\\n\\n// ENUM FOR WIRES\\nenum WIRE {\\n    Q_M,\\n    Q_C,\\n    Q_L,\\n    Q_R,\\n    Q_O,\\n    Q_4,\\n    Q_LOOKUP,\\n    Q_ARITH,\\n    Q_RANGE,\\n    Q_ELLIPTIC,\\n    Q_AUX,\\n    Q_POSEIDON2_EXTERNAL,\\n    Q_POSEIDON2_INTERNAL,\\n    SIGMA_1,\\n    SIGMA_2,\\n    SIGMA_3,\\n    SIGMA_4,\\n    ID_1,\\n    ID_2,\\n    ID_3,\\n    ID_4,\\n    TABLE_1,\\n    TABLE_2,\\n    TABLE_3,\\n    TABLE_4,\\n    LAGRANGE_FIRST,\\n    LAGRANGE_LAST,\\n    W_L,\\n    W_R,\\n    W_O,\\n    W_4,\\n    Z_PERM,\\n    LOOKUP_INVERSES,\\n    LOOKUP_READ_COUNTS,\\n    LOOKUP_READ_TAGS,\\n    W_L_SHIFT,\\n    W_R_SHIFT,\\n    W_O_SHIFT,\\n    W_4_SHIFT,\\n    Z_PERM_SHIFT\\n}\\n\\nlibrary Honk {\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    struct G1ProofPoint {\\n        uint256 x_0;\\n        uint256 x_1;\\n        uint256 y_0;\\n        uint256 y_1;\\n    }\\n\\n    struct VerificationKey {\\n        // Misc Params\\n        uint256 circuitSize;\\n        uint256 logCircuitSize;\\n        uint256 publicInputsSize;\\n        // Selectors\\n        G1Point qm;\\n        G1Point qc;\\n        G1Point ql;\\n        G1Point qr;\\n        G1Point qo;\\n        G1Point q4;\\n        G1Point qLookup; // Lookup\\n        G1Point qArith; // Arithmetic widget\\n        G1Point qDeltaRange; // Delta Range sort\\n        G1Point qAux; // Auxillary\\n        G1Point qElliptic; // Auxillary\\n        G1Point qPoseidon2External;\\n        G1Point qPoseidon2Internal;\\n        // Copy cnstraints\\n        G1Point s1;\\n        G1Point s2;\\n        G1Point s3;\\n        G1Point s4;\\n        // Copy identity\\n        G1Point id1;\\n        G1Point id2;\\n        G1Point id3;\\n        G1Point id4;\\n        // Precomputed lookup table\\n        G1Point t1;\\n        G1Point t2;\\n        G1Point t3;\\n        G1Point t4;\\n        // Fixed first and last\\n        G1Point lagrangeFirst;\\n        G1Point lagrangeLast;\\n    }\\n\\n    struct RelationParameters {\\n        // challenges\\n        Fr eta;\\n        Fr etaTwo;\\n        Fr etaThree;\\n        Fr beta;\\n        Fr gamma;\\n        // derived\\n        Fr publicInputsDelta;\\n    }\\n\\n\\n    struct Proof {\\n        // Free wires\\n        Honk.G1ProofPoint w1;\\n        Honk.G1ProofPoint w2;\\n        Honk.G1ProofPoint w3;\\n        Honk.G1ProofPoint w4;\\n        // Lookup helpers - Permutations\\n        Honk.G1ProofPoint zPerm;\\n        // Lookup helpers - logup\\n        Honk.G1ProofPoint lookupReadCounts;\\n        Honk.G1ProofPoint lookupReadTags;\\n        Honk.G1ProofPoint lookupInverses;\\n        // Sumcheck\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH][CONST_PROOF_SIZE_LOG_N] sumcheckUnivariates;\\n        Fr[NUMBER_OF_ENTITIES] sumcheckEvaluations;\\n        // Shplemini\\n        Honk.G1ProofPoint[CONST_PROOF_SIZE_LOG_N - 1] geminiFoldComms;\\n        Fr[CONST_PROOF_SIZE_LOG_N] geminiAEvaluations;\\n        Honk.G1ProofPoint shplonkQ;\\n        Honk.G1ProofPoint kzgQuotient;\\n    }\\n}\\n\\n// Transcript library to generate fiat shamir challenges\\nstruct Transcript {\\n    // Oink\\n    Honk.RelationParameters relationParameters;\\n    Fr[NUMBER_OF_ALPHAS] alphas;\\n    Fr[CONST_PROOF_SIZE_LOG_N] gateChallenges;\\n    // Sumcheck\\n    Fr[CONST_PROOF_SIZE_LOG_N] sumCheckUChallenges;\\n    // Gemini\\n    Fr rho;\\n    Fr geminiR;\\n    // Shplonk\\n    Fr shplonkNu;\\n    Fr shplonkZ;\\n}\\n\\nlibrary TranscriptLib {\\n    function generateTranscript(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Transcript memory t)\\n    {\\n        Fr previousChallenge;\\n        (t.relationParameters, previousChallenge) =\\n            generateRelationParametersChallenges(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset, previousChallenge);\\n\\n        (t.alphas, previousChallenge) = generateAlphaChallenges(previousChallenge, proof);\\n\\n        (t.gateChallenges, previousChallenge) = generateGateChallenges(previousChallenge);\\n\\n        (t.sumCheckUChallenges, previousChallenge) = generateSumcheckChallenges(proof, previousChallenge);\\n\\n        (t.rho, previousChallenge) = generateRhoChallenge(proof, previousChallenge);\\n\\n        (t.geminiR, previousChallenge) = generateGeminiRChallenge(proof, previousChallenge);\\n\\n        (t.shplonkNu, previousChallenge) = generateShplonkNuChallenge(proof, previousChallenge);\\n\\n        (t.shplonkZ, previousChallenge) = generateShplonkZChallenge(proof, previousChallenge);\\n\\n        return t;\\n    }\\n\\n    function splitChallenge(Fr challenge) internal pure returns (Fr first, Fr second) {\\n        uint256 challengeU256 = uint256(Fr.unwrap(challenge));\\n        uint256 lo = challengeU256 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        uint256 hi = challengeU256 >> 128;\\n        first = FrLib.fromBytes32(bytes32(lo));\\n        second = FrLib.fromBytes32(bytes32(hi));\\n    }\\n\\n    function generateRelationParametersChallenges(\\n        Honk.Proof memory proof,\\n        bytes32[] calldata publicInputs,\\n        uint256 circuitSize,\\n        uint256 publicInputsSize,\\n        uint256 pubInputsOffset,\\n        Fr previousChallenge\\n    ) internal pure returns (Honk.RelationParameters memory rp, Fr nextPreviousChallenge) {\\n        (rp.eta, rp.etaTwo, rp.etaThree, previousChallenge) =\\n            generateEtaChallenge(proof, publicInputs, circuitSize, publicInputsSize, pubInputsOffset);\\n\\n        (rp.beta, rp.gamma, nextPreviousChallenge) = generateBetaAndGammaChallenges(previousChallenge, proof);\\n\\n    }\\n\\n    function generateEtaChallenge(Honk.Proof memory proof, bytes32[] calldata publicInputs, uint256 circuitSize, uint256 publicInputsSize, uint256 pubInputsOffset)\\n        internal\\n        pure\\n        returns (Fr eta, Fr etaTwo, Fr etaThree, Fr previousChallenge)\\n    {\\n        bytes32[] memory round0 = new bytes32[](3 + publicInputsSize + 12);\\n        round0[0] = bytes32(circuitSize);\\n        round0[1] = bytes32(publicInputsSize);\\n        round0[2] = bytes32(pubInputsOffset);\\n        for (uint256 i = 0; i < publicInputsSize; i++) {\\n            round0[3 + i] = bytes32(publicInputs[i]);\\n        }\\n\\n        // Create the first challenge\\n        // Note: w4 is added to the challenge later on\\n        round0[3 + publicInputsSize] = bytes32(proof.w1.x_0);\\n        round0[3 + publicInputsSize + 1] = bytes32(proof.w1.x_1);\\n        round0[3 + publicInputsSize + 2] = bytes32(proof.w1.y_0);\\n        round0[3 + publicInputsSize + 3] = bytes32(proof.w1.y_1);\\n        round0[3 + publicInputsSize + 4] = bytes32(proof.w2.x_0);\\n        round0[3 + publicInputsSize + 5] = bytes32(proof.w2.x_1);\\n        round0[3 + publicInputsSize + 6] = bytes32(proof.w2.y_0);\\n        round0[3 + publicInputsSize + 7] = bytes32(proof.w2.y_1);\\n        round0[3 + publicInputsSize + 8] = bytes32(proof.w3.x_0);\\n        round0[3 + publicInputsSize + 9] = bytes32(proof.w3.x_1);\\n        round0[3 + publicInputsSize + 10] = bytes32(proof.w3.y_0);\\n        round0[3 + publicInputsSize + 11] = bytes32(proof.w3.y_1);\\n\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round0)));\\n        (eta, etaTwo) = splitChallenge(previousChallenge);\\n        previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n        Fr unused;\\n        (etaThree, unused) = splitChallenge(previousChallenge);\\n    }\\n\\n    function generateBetaAndGammaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr beta, Fr gamma, Fr nextPreviousChallenge)\\n    {\\n        bytes32[13] memory round1;\\n        round1[0] = FrLib.toBytes32(previousChallenge);\\n        round1[1] = bytes32(proof.lookupReadCounts.x_0);\\n        round1[2] = bytes32(proof.lookupReadCounts.x_1);\\n        round1[3] = bytes32(proof.lookupReadCounts.y_0);\\n        round1[4] = bytes32(proof.lookupReadCounts.y_1);\\n        round1[5] = bytes32(proof.lookupReadTags.x_0);\\n        round1[6] = bytes32(proof.lookupReadTags.x_1);\\n        round1[7] = bytes32(proof.lookupReadTags.y_0);\\n        round1[8] = bytes32(proof.lookupReadTags.y_1);\\n        round1[9] = bytes32(proof.w4.x_0);\\n        round1[10] = bytes32(proof.w4.x_1);\\n        round1[11] = bytes32(proof.w4.y_0);\\n        round1[12] = bytes32(proof.w4.y_1);\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(round1)));\\n        (beta, gamma) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    // Alpha challenges non-linearise the gate contributions\\n    function generateAlphaChallenges(Fr previousChallenge, Honk.Proof memory proof)\\n        internal\\n        pure\\n        returns (Fr[NUMBER_OF_ALPHAS] memory alphas, Fr nextPreviousChallenge)\\n    {\\n        // Generate the original sumcheck alpha 0 by hashing zPerm and zLookup\\n        uint256[9] memory alpha0;\\n        alpha0[0] = Fr.unwrap(previousChallenge);\\n        alpha0[1] = proof.lookupInverses.x_0;\\n        alpha0[2] = proof.lookupInverses.x_1;\\n        alpha0[3] = proof.lookupInverses.y_0;\\n        alpha0[4] = proof.lookupInverses.y_1;\\n        alpha0[5] = proof.zPerm.x_0;\\n        alpha0[6] = proof.zPerm.x_1;\\n        alpha0[7] = proof.zPerm.y_0;\\n        alpha0[8] = proof.zPerm.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(alpha0)));\\n        (alphas[0], alphas[1]) = splitChallenge(nextPreviousChallenge);\\n\\n        for (uint256 i = 1; i < NUMBER_OF_ALPHAS / 2; i++) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            (alphas[2 * i], alphas[2 * i + 1]) = splitChallenge(nextPreviousChallenge);\\n        }\\n        if (((NUMBER_OF_ALPHAS & 1) == 1) && (NUMBER_OF_ALPHAS > 2)) {\\n            nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(nextPreviousChallenge))));\\n            Fr unused;\\n            (alphas[NUMBER_OF_ALPHAS - 1], unused) = splitChallenge(nextPreviousChallenge);\\n        }\\n    }\\n\\n    function generateGateChallenges(Fr previousChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory gateChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            previousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(Fr.unwrap(previousChallenge))));\\n            Fr unused;\\n            (gateChallenges[i], unused) = splitChallenge(previousChallenge);\\n        }\\n        nextPreviousChallenge = previousChallenge;\\n    }\\n\\n    function generateSumcheckChallenges(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckChallenges, Fr nextPreviousChallenge)\\n    {\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH + 1] memory univariateChal;\\n            univariateChal[0] = prevChallenge;\\n\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                univariateChal[j + 1] = proof.sumcheckUnivariates[i][j];\\n            }\\n            prevChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(univariateChal)));\\n            Fr unused;\\n            (sumcheckChallenges[i], unused) = splitChallenge(prevChallenge);\\n        }\\n        nextPreviousChallenge = prevChallenge;\\n    }\\n\\n    function generateRhoChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr rho, Fr nextPreviousChallenge)\\n    {\\n        Fr[NUMBER_OF_ENTITIES + 1] memory rhoChallengeElements;\\n        rhoChallengeElements[0] = prevChallenge;\\n\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            rhoChallengeElements[i + 1] = proof.sumcheckEvaluations[i];\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(rhoChallengeElements)));\\n        Fr unused;\\n        (rho, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateGeminiRChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr geminiR, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N - 1) * 4 + 1] memory gR;\\n        gR[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            gR[1 + i * 4] = proof.geminiFoldComms[i].x_0;\\n            gR[2 + i * 4] = proof.geminiFoldComms[i].x_1;\\n            gR[3 + i * 4] = proof.geminiFoldComms[i].y_0;\\n            gR[4 + i * 4] = proof.geminiFoldComms[i].y_1;\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(gR)));\\n        Fr unused;\\n        (geminiR, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkNuChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkNu, Fr nextPreviousChallenge)\\n    {\\n        uint256[(CONST_PROOF_SIZE_LOG_N) + 1] memory shplonkNuChallengeElements;\\n        shplonkNuChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            shplonkNuChallengeElements[i + 1] = Fr.unwrap(proof.geminiAEvaluations[i]);\\n        }\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkNuChallengeElements)));\\n        Fr unused;\\n        (shplonkNu, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function generateShplonkZChallenge(Honk.Proof memory proof, Fr prevChallenge)\\n        internal\\n        pure\\n        returns (Fr shplonkZ, Fr nextPreviousChallenge)\\n    {\\n        uint256[5] memory shplonkZChallengeElements;\\n        shplonkZChallengeElements[0] = Fr.unwrap(prevChallenge);\\n\\n        shplonkZChallengeElements[1] = proof.shplonkQ.x_0;\\n        shplonkZChallengeElements[2] = proof.shplonkQ.x_1;\\n        shplonkZChallengeElements[3] = proof.shplonkQ.y_0;\\n        shplonkZChallengeElements[4] = proof.shplonkQ.y_1;\\n\\n        nextPreviousChallenge = FrLib.fromBytes32(keccak256(abi.encodePacked(shplonkZChallengeElements)));\\n        Fr unused;\\n        (shplonkZ, unused) = splitChallenge(nextPreviousChallenge);\\n    }\\n\\n    function loadProof(bytes calldata proof) internal pure returns (Honk.Proof memory p) {\\n        // Commitments\\n        p.w1 = bytesToG1ProofPoint(proof[0x0:0x80]);\\n\\n        p.w2 = bytesToG1ProofPoint(proof[0x80:0x100]);\\n        p.w3 = bytesToG1ProofPoint(proof[0x100:0x180]);\\n\\n        // Lookup / Permutation Helper Commitments\\n        p.lookupReadCounts = bytesToG1ProofPoint(proof[0x180:0x200]);\\n        p.lookupReadTags = bytesToG1ProofPoint(proof[0x200:0x280]);\\n        p.w4 = bytesToG1ProofPoint(proof[0x280:0x300]);\\n        p.lookupInverses = bytesToG1ProofPoint(proof[0x300:0x380]);\\n        p.zPerm = bytesToG1ProofPoint(proof[0x380:0x400]);\\n        uint256 boundary = 0x400;\\n\\n        // Sumcheck univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            for (uint256 j = 0; j < BATCHED_RELATION_PARTIAL_LENGTH; j++) {\\n                p.sumcheckUnivariates[i][j] = bytesToFr(proof[boundary:boundary + 0x20]);\\n                boundary += 0x20;\\n            }\\n        }\\n        // Sumcheck evaluations\\n        for (uint256 i = 0; i < NUMBER_OF_ENTITIES; i++) {\\n            p.sumcheckEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Gemini\\n        // Read gemini fold univariates\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; i++) {\\n            p.geminiFoldComms[i] = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n            boundary += 0x80;\\n        }\\n\\n        // Read gemini a evaluations\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N; i++) {\\n            p.geminiAEvaluations[i] = bytesToFr(proof[boundary:boundary + 0x20]);\\n            boundary += 0x20;\\n        }\\n\\n        // Shplonk\\n        p.shplonkQ = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n        boundary = boundary + 0x80;\\n        // KZG\\n        p.kzgQuotient = bytesToG1ProofPoint(proof[boundary:boundary + 0x80]);\\n    }\\n}\\n\\n\\n// Fr utility\\n\\nfunction bytesToFr(bytes calldata proofSection) pure returns (Fr scalar) {\\n    require(proofSection.length == 0x20, \\\"invalid bytes scalar\\\");\\n    scalar = FrLib.fromBytes32(bytes32(proofSection));\\n}\\n\\n// EC Point utilities\\nfunction convertProofPoint(Honk.G1ProofPoint memory input) pure returns (Honk.G1Point memory) {\\n    return Honk.G1Point({x: input.x_0 | (input.x_1 << 136), y: input.y_0 | (input.y_1 << 136)});\\n}\\n\\nfunction bytesToG1ProofPoint(bytes calldata proofSection) pure returns (Honk.G1ProofPoint memory point) {\\n    require(proofSection.length == 0x80, \\\"invalid bytes point\\\");\\n    point = Honk.G1ProofPoint({\\n        x_0: uint256(bytes32(proofSection[0x00:0x20])),\\n        x_1: uint256(bytes32(proofSection[0x20:0x40])),\\n        y_0: uint256(bytes32(proofSection[0x40:0x60])),\\n        y_1: uint256(bytes32(proofSection[0x60:0x80]))\\n    });\\n}\\n\\nfunction negateInplace(Honk.G1Point memory point) pure returns (Honk.G1Point memory) {\\n    point.y = (Q - point.y) % Q;\\n    return point;\\n}\\n\\n function pairing(Honk.G1Point memory rhs, Honk.G1Point memory lhs) view returns (bool) {\\n        bytes memory input = abi.encodePacked(\\n            rhs.x,\\n            rhs.y,\\n            // Fixed G1 point\\n            uint256(0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2),\\n            uint256(0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed),\\n            uint256(0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b),\\n            uint256(0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa),\\n            lhs.x,\\n            lhs.y,\\n            // G1 point from VK\\n            uint256(0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1),\\n            uint256(0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0),\\n            uint256(0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4),\\n            uint256(0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55)\\n        );\\n\\n        (bool success, bytes memory result) = address(0x08).staticcall(input);\\n        bool decodedResult = abi.decode(result, (bool));\\n        return success && decodedResult;\\n    }\\n\\n\\nlibrary RelationsLib {\\n    Fr internal constant GRUMPKIN_CURVE_B_PARAMETER_NEGATED = Fr.wrap(17); // -(-17)\\n\\n    function accumulateRelationEvaluations(\\n         Fr[NUMBER_OF_ENTITIES] memory purportedEvaluations,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_ALPHAS] memory alphas,\\n        Fr powPartialEval\\n    ) internal pure returns (Fr accumulator) {\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations;\\n\\n        // Accumulate all relations in Ultra Honk - each with varying number of subrelations\\n        accumulateArithmeticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePermutationRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateLogDerivativeLookupRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulateDeltaRangeRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateEllipticRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulateAuxillaryRelation(purportedEvaluations, rp, evaluations, powPartialEval);\\n        accumulatePoseidonExternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        accumulatePoseidonInternalRelation(purportedEvaluations, evaluations, powPartialEval);\\n        // batch the subrelations with the alpha challenges to obtain the full honk relation\\n        accumulator = scaleAndBatchSubrelations(evaluations, alphas);\\n    }\\n\\n    /**\\n     * Aesthetic helper function that is used to index by enum into proof.sumcheckEvaluations, it avoids\\n     * the relation checking code being cluttered with uint256 type casting, which is often a different colour in code\\n     * editors, and thus is noisy.\\n     */\\n    function wire(Fr[NUMBER_OF_ENTITIES] memory p, WIRE _wire) internal pure returns (Fr) {\\n        return p[uint256(_wire)];\\n    }\\n\\n    uint256 internal constant NEG_HALF_MODULO_P = 0x183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f8000000;\\n    /**\\n     * Ultra Arithmetic Relation\\n     *\\n     */\\n    function accumulateArithmeticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        // Relation 0\\n        Fr q_arith = wire(p, WIRE.Q_ARITH);\\n        {\\n            Fr neg_half = Fr.wrap(NEG_HALF_MODULO_P);\\n\\n            Fr accum = (q_arith - Fr.wrap(3)) * (wire(p, WIRE.Q_M) * wire(p, WIRE.W_R) * wire(p, WIRE.W_L)) * neg_half;\\n            accum = accum + (wire(p, WIRE.Q_L) * wire(p, WIRE.W_L)) + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_R))\\n                + (wire(p, WIRE.Q_O) * wire(p, WIRE.W_O)) + (wire(p, WIRE.Q_4) * wire(p, WIRE.W_4)) + wire(p, WIRE.Q_C);\\n            accum = accum + (q_arith - Fr.wrap(1)) * wire(p, WIRE.W_4_SHIFT);\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[0] = accum;\\n        }\\n\\n        // Relation 1\\n        {\\n            Fr accum = wire(p, WIRE.W_L) + wire(p, WIRE.W_4) - wire(p, WIRE.W_L_SHIFT) + wire(p, WIRE.Q_M);\\n            accum = accum * (q_arith - Fr.wrap(2));\\n            accum = accum * (q_arith - Fr.wrap(1));\\n            accum = accum * q_arith;\\n            accum = accum * domainSep;\\n            evals[1] = accum;\\n        }\\n    }\\n\\n    function accumulatePermutationRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr grand_product_numerator;\\n        Fr grand_product_denominator;\\n\\n        {\\n            Fr num = wire(p, WIRE.W_L) + wire(p, WIRE.ID_1) * rp.beta + rp.gamma;\\n            num = num * (wire(p, WIRE.W_R) + wire(p, WIRE.ID_2) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_O) + wire(p, WIRE.ID_3) * rp.beta + rp.gamma);\\n            num = num * (wire(p, WIRE.W_4) + wire(p, WIRE.ID_4) * rp.beta + rp.gamma);\\n\\n            grand_product_numerator = num;\\n        }\\n        {\\n            Fr den = wire(p, WIRE.W_L) + wire(p, WIRE.SIGMA_1) * rp.beta + rp.gamma;\\n            den = den * (wire(p, WIRE.W_R) + wire(p, WIRE.SIGMA_2) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_O) + wire(p, WIRE.SIGMA_3) * rp.beta + rp.gamma);\\n            den = den * (wire(p, WIRE.W_4) + wire(p, WIRE.SIGMA_4) * rp.beta + rp.gamma);\\n\\n            grand_product_denominator = den;\\n        }\\n\\n        // Contribution 2\\n        {\\n            Fr acc = (wire(p, WIRE.Z_PERM) + wire(p, WIRE.LAGRANGE_FIRST)) * grand_product_numerator;\\n\\n            acc = acc\\n                - (\\n                    (wire(p, WIRE.Z_PERM_SHIFT) + (wire(p, WIRE.LAGRANGE_LAST) * rp.publicInputsDelta))\\n                        * grand_product_denominator\\n                );\\n            acc = acc * domainSep;\\n            evals[2] = acc;\\n        }\\n\\n        // Contribution 3\\n        {\\n            Fr acc = (wire(p, WIRE.LAGRANGE_LAST) * wire(p, WIRE.Z_PERM_SHIFT)) * domainSep;\\n            evals[3] = acc;\\n        }\\n    }\\n\\n    function accumulateLogDerivativeLookupRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr write_term;\\n        Fr read_term;\\n\\n        // Calculate the write term (the table accumulation)\\n        {\\n            write_term = wire(p, WIRE.TABLE_1) + rp.gamma + (wire(p, WIRE.TABLE_2) * rp.eta)\\n                + (wire(p, WIRE.TABLE_3) * rp.etaTwo) + (wire(p, WIRE.TABLE_4) * rp.etaThree);\\n        }\\n\\n        // Calculate the write term\\n        {\\n            Fr derived_entry_1 = wire(p, WIRE.W_L) + rp.gamma + (wire(p, WIRE.Q_R) * wire(p, WIRE.W_L_SHIFT));\\n            Fr derived_entry_2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_M) * wire(p, WIRE.W_R_SHIFT);\\n            Fr derived_entry_3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_C) * wire(p, WIRE.W_O_SHIFT);\\n\\n            read_term = derived_entry_1 + (derived_entry_2 * rp.eta) + (derived_entry_3 * rp.etaTwo)\\n                + (wire(p, WIRE.Q_O) * rp.etaThree);\\n        }\\n\\n        Fr read_inverse = wire(p, WIRE.LOOKUP_INVERSES) * write_term;\\n        Fr write_inverse = wire(p, WIRE.LOOKUP_INVERSES) * read_term;\\n\\n        Fr inverse_exists_xor = wire(p, WIRE.LOOKUP_READ_TAGS) + wire(p, WIRE.Q_LOOKUP)\\n            - (wire(p, WIRE.LOOKUP_READ_TAGS) * wire(p, WIRE.Q_LOOKUP));\\n\\n        // Inverse calculated correctly relation\\n        Fr accumulatorNone = read_term * write_term * wire(p, WIRE.LOOKUP_INVERSES) - inverse_exists_xor;\\n        accumulatorNone = accumulatorNone * domainSep;\\n\\n        // Inverse\\n        Fr accumulatorOne = wire(p, WIRE.Q_LOOKUP) * read_inverse - wire(p, WIRE.LOOKUP_READ_COUNTS) * write_inverse;\\n\\n        evals[4] = accumulatorNone;\\n        evals[5] = accumulatorOne;\\n    }\\n\\n    function accumulateDeltaRangeRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        Fr minus_one = Fr.wrap(0) - Fr.wrap(1);\\n        Fr minus_two = Fr.wrap(0) - Fr.wrap(2);\\n        Fr minus_three = Fr.wrap(0) - Fr.wrap(3);\\n\\n        // Compute wire differences\\n        Fr delta_1 = wire(p, WIRE.W_R) - wire(p, WIRE.W_L);\\n        Fr delta_2 = wire(p, WIRE.W_O) - wire(p, WIRE.W_R);\\n        Fr delta_3 = wire(p, WIRE.W_4) - wire(p, WIRE.W_O);\\n        Fr delta_4 = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_4);\\n\\n        // Contribution 6\\n        {\\n            Fr acc = delta_1;\\n            acc = acc * (delta_1 + minus_one);\\n            acc = acc * (delta_1 + minus_two);\\n            acc = acc * (delta_1 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[6] = acc;\\n        }\\n\\n        // Contribution 7\\n        {\\n            Fr acc = delta_2;\\n            acc = acc * (delta_2 + minus_one);\\n            acc = acc * (delta_2 + minus_two);\\n            acc = acc * (delta_2 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[7] = acc;\\n        }\\n\\n        // Contribution 8\\n        {\\n            Fr acc = delta_3;\\n            acc = acc * (delta_3 + minus_one);\\n            acc = acc * (delta_3 + minus_two);\\n            acc = acc * (delta_3 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[8] = acc;\\n        }\\n\\n        // Contribution 9\\n        {\\n            Fr acc = delta_4;\\n            acc = acc * (delta_4 + minus_one);\\n            acc = acc * (delta_4 + minus_two);\\n            acc = acc * (delta_4 + minus_three);\\n            acc = acc * wire(p, WIRE.Q_RANGE);\\n            acc = acc * domainSep;\\n            evals[9] = acc;\\n        }\\n    }\\n\\n    struct EllipticParams {\\n        // Points\\n        Fr x_1;\\n        Fr y_1;\\n        Fr x_2;\\n        Fr y_2;\\n        Fr y_3;\\n        Fr x_3;\\n        // push accumulators into memory\\n        Fr x_double_identity;\\n    }\\n\\n    function accumulateEllipticRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        EllipticParams memory ep;\\n        ep.x_1 = wire(p, WIRE.W_R);\\n        ep.y_1 = wire(p, WIRE.W_O);\\n\\n        ep.x_2 = wire(p, WIRE.W_L_SHIFT);\\n        ep.y_2 = wire(p, WIRE.W_4_SHIFT);\\n        ep.y_3 = wire(p, WIRE.W_O_SHIFT);\\n        ep.x_3 = wire(p, WIRE.W_R_SHIFT);\\n\\n        Fr q_sign = wire(p, WIRE.Q_L);\\n        Fr q_is_double = wire(p, WIRE.Q_M);\\n\\n        // Contribution 10 point addition, x-coordinate check\\n        // q_elliptic * (x3 + x2 + x1)(x2 - x1)(x2 - x1) - y2^2 - y1^2 + 2(y2y1)*q_sign = 0\\n        Fr x_diff = (ep.x_2 - ep.x_1);\\n        Fr y1_sqr = (ep.y_1 * ep.y_1);\\n        {\\n            // Move to top\\n            Fr partialEval = domainSep;\\n\\n            Fr y2_sqr = (ep.y_2 * ep.y_2);\\n            Fr y1y2 = ep.y_1 * ep.y_2 * q_sign;\\n            Fr x_add_identity = (ep.x_3 + ep.x_2 + ep.x_1);\\n            x_add_identity = x_add_identity * x_diff * x_diff;\\n            x_add_identity = x_add_identity - y2_sqr - y1_sqr + y1y2 + y1y2;\\n\\n            evals[10] = x_add_identity * partialEval * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 11 point addition, x-coordinate check\\n        // q_elliptic * (q_sign * y1 + y3)(x2 - x1) + (x3 - x1)(y2 - q_sign * y1) = 0\\n        {\\n            Fr y1_plus_y3 = ep.y_1 + ep.y_3;\\n            Fr y_diff = ep.y_2 * q_sign - ep.y_1;\\n            Fr y_add_identity = y1_plus_y3 * x_diff + (ep.x_3 - ep.x_1) * y_diff;\\n            evals[11] = y_add_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * (Fr.wrap(1) - q_is_double);\\n        }\\n\\n        // Contribution 10 point doubling, x-coordinate check\\n        // (x3 + x1 + x1) (4y1*y1) - 9 * x1 * x1 * x1 * x1 = 0\\n        // N.B. we're using the equivalence x1*x1*x1 === y1*y1 - curve_b to reduce degree by 1\\n        {\\n            Fr x_pow_4 = (y1_sqr + GRUMPKIN_CURVE_B_PARAMETER_NEGATED) * ep.x_1;\\n            Fr y1_sqr_mul_4 = y1_sqr + y1_sqr;\\n            y1_sqr_mul_4 = y1_sqr_mul_4 + y1_sqr_mul_4;\\n            Fr x1_pow_4_mul_9 = x_pow_4 * Fr.wrap(9);\\n\\n            // NOTE: pushed into memory (stack >:'( )\\n            ep.x_double_identity = (ep.x_3 + ep.x_1 + ep.x_1) * y1_sqr_mul_4 - x1_pow_4_mul_9;\\n\\n            Fr acc = ep.x_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n            evals[10] = evals[10] + acc;\\n        }\\n\\n        // Contribution 11 point doubling, y-coordinate check\\n        // (y1 + y1) (2y1) - (3 * x1 * x1)(x1 - x3) = 0\\n        {\\n            Fr x1_sqr_mul_3 = (ep.x_1 + ep.x_1 + ep.x_1) * ep.x_1;\\n            Fr y_double_identity = x1_sqr_mul_3 * (ep.x_1 - ep.x_3) - (ep.y_1 + ep.y_1) * (ep.y_1 + ep.y_3);\\n            evals[11] = evals[11] + y_double_identity * domainSep * wire(p, WIRE.Q_ELLIPTIC) * q_is_double;\\n        }\\n    }\\n\\n    // Constants for the auxiliary relation\\n    Fr constant LIMB_SIZE = Fr.wrap(uint256(1) << 68);\\n    Fr constant SUBLIMB_SHIFT = Fr.wrap(uint256(1) << 14);\\n\\n    // Parameters used within the Auxiliary Relation\\n    // A struct is used to work around stack too deep. This relation has alot of variables\\n    struct AuxParams {\\n        Fr limb_subproduct;\\n        Fr non_native_field_gate_1;\\n        Fr non_native_field_gate_2;\\n        Fr non_native_field_gate_3;\\n        Fr limb_accumulator_1;\\n        Fr limb_accumulator_2;\\n        Fr memory_record_check;\\n        Fr partial_record_check;\\n        Fr next_gate_access_type;\\n        Fr record_delta;\\n        Fr index_delta;\\n        Fr adjacent_values_match_if_adjacent_indices_match;\\n        Fr adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation;\\n        Fr access_check;\\n        Fr next_gate_access_type_is_boolean;\\n        Fr ROM_consistency_check_identity;\\n        Fr RAM_consistency_check_identity;\\n        Fr timestamp_delta;\\n        Fr RAM_timestamp_check_identity;\\n        Fr memory_identity;\\n        Fr index_is_monotonically_increasing;\\n        Fr auxiliary_identity;\\n    }\\n\\n    function accumulateAuxillaryRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Honk.RelationParameters memory rp,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        AuxParams memory ap;\\n\\n        /**\\n         * Contribution 12\\n         * Non native field arithmetic gate 2\\n         * deg 4\\n         *\\n         *             _                                                                               _\\n         *            /   _                   _                               _       14                \\\\\\n         * q_2 . q_4 |   (w_1 . w_2) + (w_1 . w_2) + (w_1 . w_4 + w_2 . w_3 - w_3) . 2    - w_3 - w_4   |\\n         *            \\\\_                                                                               _/\\n         *\\n         *\\n         */\\n        ap.limb_subproduct = wire(p, WIRE.W_L) * wire(p, WIRE.W_R_SHIFT) + wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R);\\n        ap.non_native_field_gate_2 =\\n            (wire(p, WIRE.W_L) * wire(p, WIRE.W_4) + wire(p, WIRE.W_R) * wire(p, WIRE.W_O) - wire(p, WIRE.W_O_SHIFT));\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * LIMB_SIZE;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 + ap.limb_subproduct;\\n        ap.non_native_field_gate_2 = ap.non_native_field_gate_2 * wire(p, WIRE.Q_4);\\n\\n        ap.limb_subproduct = ap.limb_subproduct * LIMB_SIZE;\\n        ap.limb_subproduct = ap.limb_subproduct + (wire(p, WIRE.W_L_SHIFT) * wire(p, WIRE.W_R_SHIFT));\\n        ap.non_native_field_gate_1 = ap.limb_subproduct;\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 - (wire(p, WIRE.W_O) + wire(p, WIRE.W_4));\\n        ap.non_native_field_gate_1 = ap.non_native_field_gate_1 * wire(p, WIRE.Q_O);\\n\\n        ap.non_native_field_gate_3 = ap.limb_subproduct;\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 + wire(p, WIRE.W_4);\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 - (wire(p, WIRE.W_O_SHIFT) + wire(p, WIRE.W_4_SHIFT));\\n        ap.non_native_field_gate_3 = ap.non_native_field_gate_3 * wire(p, WIRE.Q_M);\\n\\n        Fr non_native_field_identity =\\n            ap.non_native_field_gate_1 + ap.non_native_field_gate_2 + ap.non_native_field_gate_3;\\n        non_native_field_identity = non_native_field_identity * wire(p, WIRE.Q_R);\\n\\n        // ((((w2' * 2^14 + w1') * 2^14 + w3) * 2^14 + w2) * 2^14 + w1 - w4) * qm\\n        // deg 2\\n        ap.limb_accumulator_1 = wire(p, WIRE.W_R_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_R);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 + wire(p, WIRE.W_L);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 - wire(p, WIRE.W_4);\\n        ap.limb_accumulator_1 = ap.limb_accumulator_1 * wire(p, WIRE.Q_4);\\n\\n        // ((((w3' * 2^14 + w2') * 2^14 + w1') * 2^14 + w4) * 2^14 + w3 - w4') * qm\\n        // deg 2\\n        ap.limb_accumulator_2 = wire(p, WIRE.W_O_SHIFT) * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_R_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_L_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_4);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * SUBLIMB_SHIFT;\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 + wire(p, WIRE.W_O);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 - wire(p, WIRE.W_4_SHIFT);\\n        ap.limb_accumulator_2 = ap.limb_accumulator_2 * wire(p, WIRE.Q_M);\\n\\n        Fr limb_accumulator_identity = ap.limb_accumulator_1 + ap.limb_accumulator_2;\\n        limb_accumulator_identity = limb_accumulator_identity * wire(p, WIRE.Q_O); //  deg 3\\n\\n        /**\\n         * MEMORY\\n         *\\n         * A RAM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * t: `timestamp` of memory cell being accessed (used for RAM, set to 0 for ROM)\\n         *  * v: `value` of memory cell being accessed\\n         *  * a: `access` type of record. read: 0 = read, 1 = write\\n         *  * r: `record` of memory cell. record = access + index * eta + timestamp * eta_two + value * eta_three\\n         *\\n         * A ROM memory record contains a tuple of the following fields:\\n         *  * i: `index` of memory cell being accessed\\n         *  * v: `value1` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * v2:`value2` of memory cell being accessed (ROM tables can store up to 2 values per index)\\n         *  * r: `record` of memory cell. record = index * eta + value2 * eta_two + value1 * eta_three\\n         *\\n         *  When performing a read/write access, the values of i, t, v, v2, a, r are stored in the following wires +\\n         * selectors, depending on whether the gate is a RAM read/write or a ROM read\\n         *\\n         *  | gate type | i  | v2/t  |  v | a  | r  |\\n         *  | --------- | -- | ----- | -- | -- | -- |\\n         *  | ROM       | w1 | w2    | w3 | -- | w4 |\\n         *  | RAM       | w1 | w2    | w3 | qc | w4 |\\n         *\\n         * (for accesses where `index` is a circuit constant, it is assumed the circuit will apply a copy constraint on\\n         * `w2` to fix its value)\\n         *\\n         *\\n         */\\n\\n        /**\\n         * Memory Record Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * A ROM/ROM access gate can be evaluated with the identity:\\n         *\\n         * qc + w1 \\\\eta + w2 \\\\eta_two + w3 \\\\eta_three - w4 = 0\\n         *\\n         * For ROM gates, qc = 0\\n         */\\n        ap.memory_record_check = wire(p, WIRE.W_O) * rp.etaThree;\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_R) * rp.etaTwo);\\n        ap.memory_record_check = ap.memory_record_check + (wire(p, WIRE.W_L) * rp.eta);\\n        ap.memory_record_check = ap.memory_record_check + wire(p, WIRE.Q_C);\\n        ap.partial_record_check = ap.memory_record_check; // used in RAM consistency check; deg 1 or 4\\n        ap.memory_record_check = ap.memory_record_check - wire(p, WIRE.W_4);\\n\\n        /**\\n         * Contribution 13 & 14\\n         * ROM Consistency Check\\n         * Partial degree: 1\\n         * Total degree: 4\\n         *\\n         * For every ROM read, a set equivalence check is applied between the record witnesses, and a second set of\\n         * records that are sorted.\\n         *\\n         * We apply the following checks for the sorted records:\\n         *\\n         * 1. w1, w2, w3 correctly map to 'index', 'v1, 'v2' for a given record value at w4\\n         * 2. index values for adjacent records are monotonically increasing\\n         * 3. if, at gate i, index_i == index_{i + 1}, then value1_i == value1_{i + 1} and value2_i == value2_{i + 1}\\n         *\\n         */\\n        ap.index_delta = wire(p, WIRE.W_L_SHIFT) - wire(p, WIRE.W_L);\\n        ap.record_delta = wire(p, WIRE.W_4_SHIFT) - wire(p, WIRE.W_4);\\n\\n        ap.index_is_monotonically_increasing = ap.index_delta * ap.index_delta - ap.index_delta; // deg 2\\n\\n        ap.adjacent_values_match_if_adjacent_indices_match = (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.record_delta; // deg 2\\n\\n        evals[13] = ap.adjacent_values_match_if_adjacent_indices_match * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n        evals[14] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R))\\n            * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5\\n\\n        ap.ROM_consistency_check_identity = ap.memory_record_check * (wire(p, WIRE.Q_L) * wire(p, WIRE.Q_R)); // deg 3 or 7\\n\\n        /**\\n         * Contributions 15,16,17\\n         * RAM Consistency Check\\n         *\\n         * The 'access' type of the record is extracted with the expression `w_4 - ap.partial_record_check`\\n         * (i.e. for an honest Prover `w1 * eta + w2 * eta^2 + w3 * eta^3 - w4 = access`.\\n         * This is validated by requiring `access` to be boolean\\n         *\\n         * For two adjacent entries in the sorted list if _both_\\n         *  A) index values match\\n         *  B) adjacent access value is 0 (i.e. next gate is a READ)\\n         * then\\n         *  C) both values must match.\\n         * The gate boolean check is\\n         * (A && B) => C  === !(A && B) || C ===  !A || !B || C\\n         *\\n         * N.B. it is the responsibility of the circuit writer to ensure that every RAM cell is initialized\\n         * with a WRITE operation.\\n         */\\n        Fr access_type = (wire(p, WIRE.W_4) - ap.partial_record_check); // will be 0 or 1 for honest Prover; deg 1 or 4\\n        ap.access_check = access_type * access_type - access_type; // check value is 0 or 1; deg 2 or 8\\n\\n        ap.next_gate_access_type = wire(p, WIRE.W_O_SHIFT) * rp.etaThree;\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_R_SHIFT) * rp.etaTwo);\\n        ap.next_gate_access_type = ap.next_gate_access_type + (wire(p, WIRE.W_L_SHIFT) * rp.eta);\\n        ap.next_gate_access_type = wire(p, WIRE.W_4_SHIFT) - ap.next_gate_access_type;\\n\\n        Fr value_delta = wire(p, WIRE.W_O_SHIFT) - wire(p, WIRE.W_O);\\n        ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation = (\\n            ap.index_delta * MINUS_ONE + Fr.wrap(1)\\n        ) * value_delta * (ap.next_gate_access_type * MINUS_ONE + Fr.wrap(1)); // deg 3 or 6\\n\\n        // We can't apply the RAM consistency check identity on the final entry in the sorted list (the wires in the\\n        // next gate would make the identity fail).  We need to validate that its 'access type' bool is correct. Can't\\n        // do  with an arithmetic gate because of the  `eta` factors. We need to check that the *next* gate's access\\n        // type is  correct, to cover this edge case\\n        // deg 2 or 4\\n        ap.next_gate_access_type_is_boolean =\\n            ap.next_gate_access_type * ap.next_gate_access_type - ap.next_gate_access_type;\\n\\n        // Putting it all together...\\n        evals[15] = ap.adjacent_values_match_if_adjacent_indices_match_and_next_access_is_a_read_operation\\n            * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 5 or 8\\n        evals[16] = ap.index_is_monotonically_increasing * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4\\n        evals[17] = ap.next_gate_access_type_is_boolean * (wire(p, WIRE.Q_ARITH)) * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 6\\n\\n        ap.RAM_consistency_check_identity = ap.access_check * (wire(p, WIRE.Q_ARITH)); // deg 3 or 9\\n\\n        /**\\n         * RAM Timestamp Consistency Check\\n         *\\n         * | w1 | w2 | w3 | w4 |\\n         * | index | timestamp | timestamp_check | -- |\\n         *\\n         * Let delta_index = index_{i + 1} - index_{i}\\n         *\\n         * Iff delta_index == 0, timestamp_check = timestamp_{i + 1} - timestamp_i\\n         * Else timestamp_check = 0\\n         */\\n        ap.timestamp_delta = wire(p, WIRE.W_R_SHIFT) - wire(p, WIRE.W_R);\\n        ap.RAM_timestamp_check_identity =\\n            (ap.index_delta * MINUS_ONE + Fr.wrap(1)) * ap.timestamp_delta - wire(p, WIRE.W_O); // deg 3\\n\\n        /**\\n         * Complete Contribution 12\\n         * The complete RAM/ROM memory identity\\n         * Partial degree:\\n         */\\n        ap.memory_identity = ap.ROM_consistency_check_identity; // deg 3 or 6\\n        ap.memory_identity =\\n            ap.memory_identity + ap.RAM_timestamp_check_identity * (wire(p, WIRE.Q_4) * wire(p, WIRE.Q_L)); // deg 4\\n        ap.memory_identity = ap.memory_identity + ap.memory_record_check * (wire(p, WIRE.Q_M) * wire(p, WIRE.Q_L)); // deg 3 or 6\\n        ap.memory_identity = ap.memory_identity + ap.RAM_consistency_check_identity; // deg 3 or 9\\n\\n        // (deg 3 or 9) + (deg 4) + (deg 3)\\n        ap.auxiliary_identity = ap.memory_identity + non_native_field_identity + limb_accumulator_identity;\\n        ap.auxiliary_identity = ap.auxiliary_identity * (wire(p, WIRE.Q_AUX) * domainSep); // deg 4 or 10\\n        evals[12] = ap.auxiliary_identity;\\n    }\\n\\n    struct PoseidonExternalParams {\\n        Fr s1;\\n        Fr s2;\\n        Fr s3;\\n        Fr s4;\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr t0;\\n        Fr t1;\\n        Fr t2;\\n        Fr t3;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonExternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonExternalParams memory ep;\\n\\n        ep.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n        ep.s2 = wire(p, WIRE.W_R) + wire(p, WIRE.Q_R);\\n        ep.s3 = wire(p, WIRE.W_O) + wire(p, WIRE.Q_O);\\n        ep.s4 = wire(p, WIRE.W_4) + wire(p, WIRE.Q_4);\\n\\n        ep.u1 = ep.s1 * ep.s1 * ep.s1 * ep.s1 * ep.s1;\\n        ep.u2 = ep.s2 * ep.s2 * ep.s2 * ep.s2 * ep.s2;\\n        ep.u3 = ep.s3 * ep.s3 * ep.s3 * ep.s3 * ep.s3;\\n        ep.u4 = ep.s4 * ep.s4 * ep.s4 * ep.s4 * ep.s4;\\n        // matrix mul v = M_E * u with 14 additions\\n        ep.t0 = ep.u1 + ep.u2; // u_1 + u_2\\n        ep.t1 = ep.u3 + ep.u4; // u_3 + u_4\\n        ep.t2 = ep.u2 + ep.u2 + ep.t1; // 2u_2\\n        // ep.t2 += ep.t1; // 2u_2 + u_3 + u_4\\n        ep.t3 = ep.u4 + ep.u4 + ep.t0; // 2u_4\\n        // ep.t3 += ep.t0; // u_1 + u_2 + 2u_4\\n        ep.v4 = ep.t1 + ep.t1;\\n        ep.v4 = ep.v4 + ep.v4 + ep.t3;\\n        // ep.v4 += ep.t3; // u_1 + u_2 + 4u_3 + 6u_4\\n        ep.v2 = ep.t0 + ep.t0;\\n        ep.v2 = ep.v2 + ep.v2 + ep.t2;\\n        // ep.v2 += ep.t2; // 4u_1 + 6u_2 + u_3 + u_4\\n        ep.v1 = ep.t3 + ep.v2; // 5u_1 + 7u_2 + u_3 + 3u_4\\n        ep.v3 = ep.t2 + ep.v4; // u_1 + 3u_2 + 5u_3 + 7u_4\\n\\n        ep.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_EXTERNAL) * domainSep;\\n        evals[18] = evals[18] + ep.q_pos_by_scaling * (ep.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        evals[19] = evals[19] + ep.q_pos_by_scaling * (ep.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        evals[20] = evals[20] + ep.q_pos_by_scaling * (ep.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        evals[21] = evals[21] + ep.q_pos_by_scaling * (ep.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    struct PoseidonInternalParams {\\n        Fr u1;\\n        Fr u2;\\n        Fr u3;\\n        Fr u4;\\n        Fr u_sum;\\n        Fr v1;\\n        Fr v2;\\n        Fr v3;\\n        Fr v4;\\n        Fr s1;\\n        Fr q_pos_by_scaling;\\n    }\\n\\n    function accumulatePoseidonInternalRelation(\\n        Fr[NUMBER_OF_ENTITIES] memory p,\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evals,\\n        Fr domainSep\\n    ) internal pure {\\n        PoseidonInternalParams memory ip;\\n\\n        Fr[4] memory INTERNAL_MATRIX_DIAGONAL = [\\n            FrLib.from(0x10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e7),\\n            FrLib.from(0x0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b),\\n            FrLib.from(0x00544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac15),\\n            FrLib.from(0x222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b)\\n        ];\\n\\n        // add round constants\\n        ip.s1 = wire(p, WIRE.W_L) + wire(p, WIRE.Q_L);\\n\\n        // apply s-box round\\n        ip.u1 = ip.s1 * ip.s1 * ip.s1 * ip.s1 * ip.s1;\\n        ip.u2 = wire(p, WIRE.W_R);\\n        ip.u3 = wire(p, WIRE.W_O);\\n        ip.u4 = wire(p, WIRE.W_4);\\n\\n        // matrix mul with v = M_I * u 4 muls and 7 additions\\n        ip.u_sum = ip.u1 + ip.u2 + ip.u3 + ip.u4;\\n\\n        ip.q_pos_by_scaling = wire(p, WIRE.Q_POSEIDON2_INTERNAL) * domainSep;\\n\\n        ip.v1 = ip.u1 * INTERNAL_MATRIX_DIAGONAL[0] + ip.u_sum;\\n        evals[22] = evals[22] + ip.q_pos_by_scaling * (ip.v1 - wire(p, WIRE.W_L_SHIFT));\\n\\n        ip.v2 = ip.u2 * INTERNAL_MATRIX_DIAGONAL[1] + ip.u_sum;\\n        evals[23] = evals[23] + ip.q_pos_by_scaling * (ip.v2 - wire(p, WIRE.W_R_SHIFT));\\n\\n        ip.v3 = ip.u3 * INTERNAL_MATRIX_DIAGONAL[2] + ip.u_sum;\\n        evals[24] = evals[24] + ip.q_pos_by_scaling * (ip.v3 - wire(p, WIRE.W_O_SHIFT));\\n\\n        ip.v4 = ip.u4 * INTERNAL_MATRIX_DIAGONAL[3] + ip.u_sum;\\n        evals[25] = evals[25] + ip.q_pos_by_scaling * (ip.v4 - wire(p, WIRE.W_4_SHIFT));\\n    }\\n\\n    function scaleAndBatchSubrelations(\\n        Fr[NUMBER_OF_SUBRELATIONS] memory evaluations,\\n        Fr[NUMBER_OF_ALPHAS] memory subrelationChallenges\\n    ) internal pure returns (Fr accumulator) {\\n        accumulator = accumulator + evaluations[0];\\n\\n        for (uint256 i = 1; i < NUMBER_OF_SUBRELATIONS; ++i) {\\n            accumulator = accumulator + evaluations[i] * subrelationChallenges[i - 1];\\n        }\\n    }\\n}\\n\\nstruct ShpleminiIntermediates {\\n    Fr unshiftedScalar;\\n    Fr shiftedScalar;\\n    // Scalar to be multiplied by [1]\\u2081\\n    Fr constantTermAccumulator;\\n    // Accumulator for powers of rho\\n    Fr batchingChallenge;\\n    // Linear combination of multilinear (sumcheck) evaluations and powers of rho\\n    Fr batchedEvaluation;\\n    // 1/(z - r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr posInvertedDenominator;\\n    // 1/(z + r^{2^i}) for i = 0, ..., logSize, dynamically updated\\n    Fr negInvertedDenominator;\\n    // v^{2i} * 1/(z - r^{2^i})\\n    Fr scalingFactorPos;\\n    // v^{2i+1} * 1/(z + r^{2^i})\\n    Fr scalingFactorNeg;\\n    // // Fold_i(r^{2^i}) reconstructed by Verifier\\n    // Fr[CONST_PROOF_SIZE_LOG_N] foldPosEvaluations;\\n}\\n\\nlibrary CommitmentSchemeLib {\\n    using FrLib for Fr;\\n\\n    function computeSquares(Fr r) internal pure returns (Fr[CONST_PROOF_SIZE_LOG_N] memory squares) {\\n        squares[0] = r;\\n        for (uint256 i = 1; i < CONST_PROOF_SIZE_LOG_N; ++i) {\\n            squares[i] = squares[i - 1].sqr();\\n        }\\n    }\\n\\n    // Compute the evaluations  A_l(r^{2^l}) for l = 0, ..., m-1\\n    function computeFoldPosEvaluations(\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory sumcheckUChallenges,\\n        Fr batchedEvalAccumulator,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvaluations,\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory geminiEvalChallengePowers,\\n        uint256 logSize\\n    ) internal view returns (Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations) {\\n        for (uint256 i = CONST_PROOF_SIZE_LOG_N; i > 0; --i) {\\n            Fr challengePower = geminiEvalChallengePowers[i - 1];\\n            Fr u = sumcheckUChallenges[i - 1];\\n\\n            Fr batchedEvalRoundAcc = (\\n                (challengePower * batchedEvalAccumulator * Fr.wrap(2))\\n                    - geminiEvaluations[i - 1] * (challengePower * (Fr.wrap(1) - u) - u)\\n            );\\n            // Divide by the denominator\\n            batchedEvalRoundAcc = batchedEvalRoundAcc * (challengePower * (Fr.wrap(1) - u) + u).invert();\\n\\n            if (i <= logSize) {\\n                batchedEvalAccumulator = batchedEvalRoundAcc;\\n                foldPosEvaluations[i - 1] = batchedEvalRoundAcc;\\n            }\\n        }\\n\\n    }\\n}\\n\\ninterface IVerifier {\\n    function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool);\\n}\\n\\n\\nabstract contract BaseHonkVerifier is IVerifier {\\n    using FrLib for Fr;\\n\\n    uint256 immutable n;\\n    uint256 immutable logN;\\n    uint256 immutable numPublicInputs;\\n\\n    constructor(uint256 _n, uint256 _logN, uint256 _numPublicInputs) {\\n        n = _n;\\n        logN = _logN;\\n        numPublicInputs = _numPublicInputs;\\n    }\\n\\n    error ProofLengthWrong();\\n    error PublicInputsLengthWrong();\\n    error SumcheckFailed();\\n    error ShpleminiFailed();\\n\\n    // Number of field elements in a ultra honk zero knowledge proof\\n    uint256 constant PROOF_SIZE = 440;\\n\\n    function loadVerificationKey() internal pure virtual returns (Honk.VerificationKey memory);\\n\\n    function verify(bytes calldata proof, bytes32[] calldata publicInputs) public view override returns (bool) {\\n         // Check the received proof is the expected size where each field element is 32 bytes\\n        if (proof.length != PROOF_SIZE * 32) {\\n            revert ProofLengthWrong();\\n        }\\n\\n        Honk.VerificationKey memory vk = loadVerificationKey();\\n        Honk.Proof memory p = TranscriptLib.loadProof(proof);\\n\\n        if (publicInputs.length != vk.publicInputsSize) {\\n            revert PublicInputsLengthWrong();\\n        }\\n\\n        // Generate the fiat shamir challenges for the whole protocol\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        Transcript memory t = TranscriptLib.generateTranscript(p, publicInputs, vk.circuitSize, vk.publicInputsSize, /*pubInputsOffset=*/1);\\n\\n        // Derive public input delta\\n        // TODO(https://github.com/AztecProtocol/barretenberg/issues/1281): Add pubInputsOffset to VK or remove entirely.\\n        t.relationParameters.publicInputsDelta = computePublicInputDelta(\\n            publicInputs, t.relationParameters.beta, t.relationParameters.gamma, /*pubInputsOffset=*/1\\n        );\\n\\n        // Sumcheck\\n        bool sumcheckVerified = verifySumcheck(p, t);\\n        if (!sumcheckVerified) revert SumcheckFailed();\\n\\n        bool shpleminiVerified = verifyShplemini(p, vk, t);\\n        if (!shpleminiVerified) revert ShpleminiFailed();\\n\\n        return sumcheckVerified && shpleminiVerified; // Boolean condition not required - nice for vanity :)\\n    }\\n\\n    function computePublicInputDelta(bytes32[] memory publicInputs, Fr beta, Fr gamma, uint256 offset)\\n        internal\\n        view\\n        returns (Fr publicInputDelta)\\n    {\\n        Fr numerator = Fr.wrap(1);\\n        Fr denominator = Fr.wrap(1);\\n\\n        Fr numeratorAcc = gamma + (beta * FrLib.from(n + offset));\\n        Fr denominatorAcc = gamma - (beta * FrLib.from(offset + 1));\\n\\n        {\\n            for (uint256 i = 0; i < numPublicInputs; i++) {\\n                Fr pubInput = FrLib.fromBytes32(publicInputs[i]);\\n\\n                numerator = numerator * (numeratorAcc + pubInput);\\n                denominator = denominator * (denominatorAcc + pubInput);\\n\\n                numeratorAcc = numeratorAcc + beta;\\n                denominatorAcc = denominatorAcc - beta;\\n            }\\n        }\\n\\n        // Fr delta = numerator / denominator; // TOOO: batch invert later?\\n        publicInputDelta = FrLib.div(numerator, denominator);\\n    }\\n\\n    function verifySumcheck(Honk.Proof memory proof, Transcript memory tp) internal view returns (bool verified) {\\n        Fr roundTarget;\\n        Fr powPartialEvaluation = Fr.wrap(1);\\n\\n        // We perform sumcheck reductions over log n rounds ( the multivariate degree )\\n        for (uint256 round; round < logN; ++round) {\\n            Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate = proof.sumcheckUnivariates[round];\\n            bool valid = checkSum(roundUnivariate, roundTarget);\\n            if (!valid) revert SumcheckFailed();\\n\\n            Fr roundChallenge = tp.sumCheckUChallenges[round];\\n\\n            // Update the round target for the next rounf\\n            roundTarget = computeNextTargetSum(roundUnivariate, roundChallenge);\\n            powPartialEvaluation = partiallyEvaluatePOW(tp.gateChallenges[round], powPartialEvaluation, roundChallenge);\\n        }\\n\\n        // Last round\\n        Fr grandHonkRelationSum =\\n            RelationsLib.accumulateRelationEvaluations(proof.sumcheckEvaluations, tp.relationParameters, tp.alphas, powPartialEvaluation);\\n        verified = (grandHonkRelationSum == roundTarget);\\n    }\\n\\n    function checkSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariate, Fr roundTarget)\\n        internal\\n        pure\\n        returns (bool checked)\\n    {\\n        Fr totalSum = roundUnivariate[0] + roundUnivariate[1];\\n        checked = totalSum == roundTarget;\\n    }\\n\\n    // Return the new target sum for the next sumcheck round\\n    function computeNextTargetSum(Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory roundUnivariates, Fr roundChallenge)\\n        internal\\n        view\\n        returns (Fr targetSum)\\n    {\\n        // TODO: inline\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory BARYCENTRIC_LAGRANGE_DENOMINATORS = [\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffec51),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000002d0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff11),\\n            Fr.wrap(0x0000000000000000000000000000000000000000000000000000000000000090),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efffff71),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000000f0),\\n            Fr.wrap(0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effffd31),\\n            Fr.wrap(0x00000000000000000000000000000000000000000000000000000000000013b0)\\n        ];\\n\\n        // To compute the next target sum, we evaluate the given univariate at a point u (challenge).\\n\\n        // Performing Barycentric evaluations\\n        // Compute B(x)\\n        Fr numeratorValue = Fr.wrap(1);\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            numeratorValue = numeratorValue * (roundChallenge - Fr.wrap(i));\\n        }\\n\\n        // Calculate domain size N of inverses\\n        Fr[BATCHED_RELATION_PARTIAL_LENGTH] memory denominatorInverses;\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr inv = BARYCENTRIC_LAGRANGE_DENOMINATORS[i];\\n            inv = inv * (roundChallenge - Fr.wrap(i));\\n            inv = FrLib.invert(inv);\\n            denominatorInverses[i] = inv;\\n        }\\n\\n        for (uint256 i = 0; i < BATCHED_RELATION_PARTIAL_LENGTH; ++i) {\\n            Fr term = roundUnivariates[i];\\n            term = term * denominatorInverses[i];\\n            targetSum = targetSum + term;\\n        }\\n\\n        // Scale the sum by the value of B(x)\\n        targetSum = targetSum * numeratorValue;\\n    }\\n\\n    // Univariate evaluation of the monomial ((1-X_l) + X_l.B_l) at the challenge point X_l=u_l\\n    function partiallyEvaluatePOW(Fr gateChallenge, Fr currentEvaluation, Fr roundChallenge)\\n        internal\\n        pure\\n        returns (Fr newEvaluation)\\n    {\\n        Fr univariateEval = Fr.wrap(1) + (roundChallenge * (gateChallenge - Fr.wrap(1)));\\n        newEvaluation = currentEvaluation * univariateEval;\\n    }\\n\\n    function verifyShplemini(Honk.Proof memory proof, Honk.VerificationKey memory vk, Transcript memory tp)\\n        internal\\n        view\\n        returns (bool verified)\\n    {\\n        ShpleminiIntermediates memory mem; // stack\\n\\n        // - Compute vector (r, r\\u00b2, ... , r\\u00b2\\u207d\\u207f\\u207b\\u00b9\\u207e), where n = log_circuit_size\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory powers_of_evaluation_challenge = CommitmentSchemeLib.computeSquares(tp.geminiR);\\n\\n        // Arrays hold values that will be linearly combined for the gemini and shplonk batch openings\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars;\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory commitments;\\n\\n        mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[0]).invert();\\n        mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[0]).invert();\\n\\n        mem.unshiftedScalar = mem.posInvertedDenominator + (tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.shiftedScalar =\\n            tp.geminiR.invert() * (mem.posInvertedDenominator - (tp.shplonkNu * mem.negInvertedDenominator));\\n\\n        scalars[0] = Fr.wrap(1);\\n        commitments[0] = convertProofPoint(proof.shplonkQ);\\n\\n        mem.batchingChallenge = Fr.wrap(1);\\n        mem.batchedEvaluation = Fr.wrap(0);\\n\\n        for (uint256 i = 1; i <= NUMBER_UNSHIFTED; ++i) {\\n            scalars[i] = mem.unshiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n        // g commitments are accumulated at r\\n        for (uint256 i = NUMBER_UNSHIFTED + 1; i <= NUMBER_OF_ENTITIES; ++i) {\\n            scalars[i] = mem.shiftedScalar.neg() * mem.batchingChallenge;\\n            mem.batchedEvaluation = mem.batchedEvaluation + (proof.sumcheckEvaluations[i - 1] * mem.batchingChallenge);\\n            mem.batchingChallenge = mem.batchingChallenge * tp.rho;\\n        }\\n\\n        commitments[1] = vk.qm;\\n        commitments[2] = vk.qc;\\n        commitments[3] = vk.ql;\\n        commitments[4] = vk.qr;\\n        commitments[5] = vk.qo;\\n        commitments[6] = vk.q4;\\n        commitments[7] = vk.qLookup;\\n        commitments[8] = vk.qArith;\\n        commitments[9] = vk.qDeltaRange;\\n        commitments[10] = vk.qElliptic;\\n        commitments[11] = vk.qAux;\\n        commitments[12] = vk.qPoseidon2External;\\n        commitments[13] = vk.qPoseidon2Internal;\\n        commitments[14] = vk.s1;\\n        commitments[15] = vk.s2;\\n        commitments[16] = vk.s3;\\n        commitments[17] = vk.s4;\\n        commitments[18] = vk.id1;\\n        commitments[19] = vk.id2;\\n        commitments[20] = vk.id3;\\n        commitments[21] = vk.id4;\\n        commitments[22] = vk.t1;\\n        commitments[23] = vk.t2;\\n        commitments[24] = vk.t3;\\n        commitments[25] = vk.t4;\\n        commitments[26] = vk.lagrangeFirst;\\n        commitments[27] = vk.lagrangeLast;\\n\\n        // Accumulate proof points\\n        commitments[28] = convertProofPoint(proof.w1);\\n        commitments[29] = convertProofPoint(proof.w2);\\n        commitments[30] = convertProofPoint(proof.w3);\\n        commitments[31] = convertProofPoint(proof.w4);\\n        commitments[32] = convertProofPoint(proof.zPerm);\\n        commitments[33] = convertProofPoint(proof.lookupInverses);\\n        commitments[34] = convertProofPoint(proof.lookupReadCounts);\\n        commitments[35] = convertProofPoint(proof.lookupReadTags);\\n\\n        // to be Shifted\\n        commitments[36] = convertProofPoint(proof.w1);\\n        commitments[37] = convertProofPoint(proof.w2);\\n        commitments[38] = convertProofPoint(proof.w3);\\n        commitments[39] = convertProofPoint(proof.w4);\\n        commitments[40] = convertProofPoint(proof.zPerm);\\n\\n        // Add contributions from A\\u2080(r) and A\\u2080(-r) to constant_term_accumulator:\\n        // Compute the evaluations A_l(r^{2^l}) for l = 0, ..., logN - 1\\n        Fr[CONST_PROOF_SIZE_LOG_N] memory foldPosEvaluations = CommitmentSchemeLib.computeFoldPosEvaluations(\\n            tp.sumCheckUChallenges,\\n            mem.batchedEvaluation,\\n            proof.geminiAEvaluations,\\n            powers_of_evaluation_challenge,\\n            logN\\n        );\\n\\n        // Compute the Shplonk constant term contributions from A\\u2080(\\u00b1r)\\n        mem.constantTermAccumulator = foldPosEvaluations[0] * mem.posInvertedDenominator;\\n        mem.constantTermAccumulator =\\n            mem.constantTermAccumulator + (proof.geminiAEvaluations[0] * tp.shplonkNu * mem.negInvertedDenominator);\\n        mem.batchingChallenge = tp.shplonkNu.sqr();\\n\\n        // Compute Shplonk constant term contributions from A\\u2097(\\u00b1r^{2\\u02e1}) for l = 1, ..., m-1;\\n        // Compute scalar multipliers for each fold commitment\\n        for (uint256 i = 0; i < CONST_PROOF_SIZE_LOG_N - 1; ++i) {\\n            bool dummy_round = i >= (logN - 1);\\n\\n            if (!dummy_round) {\\n                // Update inverted denominators\\n                mem.posInvertedDenominator = (tp.shplonkZ - powers_of_evaluation_challenge[i + 1]).invert();\\n                mem.negInvertedDenominator = (tp.shplonkZ + powers_of_evaluation_challenge[i + 1]).invert();\\n\\n                // Compute the scalar multipliers for A\\u2097(\\u00b1 r^{2\\u02e1}) and [A\\u2097]\\n                mem.scalingFactorPos = mem.batchingChallenge * mem.posInvertedDenominator;\\n                mem.scalingFactorNeg = mem.batchingChallenge * tp.shplonkNu * mem.negInvertedDenominator;\\n                // [A\\u2097] is multiplied by -v^{2l}/(z-r^{2^l}) - v^{2l+1} /(z+ r^{2^l})\\n                scalars[NUMBER_OF_ENTITIES + 1 + i] = mem.scalingFactorNeg.neg() + mem.scalingFactorPos.neg();\\n\\n                // Accumulate the const term contribution given by\\n                // v^{2l} * A\\u2097(r^{2\\u02e1}) /(z-r^{2^l}) + v^{2l+1} * A\\u2097(-r^{2\\u02e1}) /(z+ r^{2^l})\\n                Fr accumContribution = mem.scalingFactorNeg * proof.geminiAEvaluations[i + 1];\\n                accumContribution = accumContribution + mem.scalingFactorPos * foldPosEvaluations[i + 1];\\n                mem.constantTermAccumulator = mem.constantTermAccumulator + accumContribution;\\n                // Update the running power of v\\n                mem.batchingChallenge = mem.batchingChallenge * tp.shplonkNu * tp.shplonkNu;\\n            }\\n\\n            commitments[NUMBER_OF_ENTITIES + 1 + i] = convertProofPoint(proof.geminiFoldComms[i]);\\n        }\\n\\n        // Finalise the batch opening claim\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = Honk.G1Point({x: 1, y: 2});\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N] = mem.constantTermAccumulator;\\n\\n        Honk.G1Point memory quotient_commitment = convertProofPoint(proof.kzgQuotient);\\n\\n        commitments[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = quotient_commitment;\\n        scalars[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 1] = tp.shplonkZ; // evaluation challenge\\n\\n        Honk.G1Point memory P_0 = batchMul(commitments, scalars);\\n        Honk.G1Point memory P_1 = negateInplace(quotient_commitment);\\n\\n        return pairing(P_0, P_1);\\n    }\\n\\n    // This implementation is the same as above with different constants\\n    function batchMul(\\n        Honk.G1Point[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory base,\\n        Fr[NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2] memory scalars\\n    ) internal view returns (Honk.G1Point memory result) {\\n        uint256 limit = NUMBER_OF_ENTITIES + CONST_PROOF_SIZE_LOG_N + 2;\\n        assembly {\\n            let success := 0x01\\n            let free := mload(0x40)\\n\\n            // Write the original into the accumulator\\n            // Load into memory for ecMUL, leave offset for eccAdd result\\n            // base is an array of pointers, so we have to dereference them\\n            mstore(add(free, 0x40), mload(mload(base)))\\n            mstore(add(free, 0x60), mload(add(0x20, mload(base))))\\n            // Add scalar\\n            mstore(add(free, 0x80), mload(scalars))\\n            success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, free, 0x40))\\n\\n            let count := 0x01\\n            for {} lt(count, limit) { count := add(count, 1) } {\\n                // Get loop offsets\\n                let base_base := add(base, mul(count, 0x20))\\n                let scalar_base := add(scalars, mul(count, 0x20))\\n\\n                mstore(add(free, 0x40), mload(mload(base_base)))\\n                mstore(add(free, 0x60), mload(add(0x20, mload(base_base))))\\n                // Add scalar\\n                mstore(add(free, 0x80), mload(scalar_base))\\n\\n                success := and(success, staticcall(gas(), 7, add(free, 0x40), 0x60, add(free, 0x40), 0x40))\\n                // accumulator = accumulator + accumulator_2\\n                success := and(success, staticcall(gas(), 6, free, 0x80, free, 0x40))\\n            }\\n\\n            // Return the result - i hate this\\n            mstore(result, mload(free))\\n            mstore(add(result, 0x20), mload(add(free, 0x20)))\\n        }\\n    }\\n}\\n\\ncontract WithdrawVerifier is BaseHonkVerifier(N, LOG_N, NUMBER_OF_PUBLIC_INPUTS) {\\n     function loadVerificationKey() internal pure override returns (Honk.VerificationKey memory) {\\n       return HonkVerificationKey.loadVerificationKey();\\n    }\\n}\\n\",\"keccak256\":\"0xe3a847298bf36185dbb775b2068dc26c7c972e7f0c9515012fc6a61697e2eacd\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60c06040526002805463ffffffff1916905560006003557f2561bf26f818282a3be40719542054d2173eb0d38539e8a8d3cff22f29fd2384600d5534801561004657600080fd5b5060405161659e38038061659e83398101604081905261006591610384565b8585818181818a600c8060808181525050600181610083919061040e565b61008e906002610508565b60045560405161009d9061035b565b604051809103906000f0801580156100b9573d6000803e3d6000fd5b50600580546001600160a01b0319166001600160a01b039283161790556000805260016020527f124005ad54174bbcb8c2dd053ea318daa80106cdcc518731504b771d6006123f7fa6eef7e35abe7026729641147f7915573c7e97b47efa546f5f6e3230263bcb49558216905061014a57604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b61015381610259565b506001600160a01b0380831660a052811661018157604051632d618d8160e21b815260040160405180910390fd5b60a05160405163ca5eb5e160e01b81526001600160a01b0383811660048301529091169063ca5eb5e190602401600060405180830381600087803b1580156101c857600080fd5b505af11580156101dc573d6000803e3d6000fd5b5050600980546001600160a01b03808f166001600160a01b031992831617909255600a80548e8416908316179055600b80548d8416908316179055600c8054928c16929091169190911790555061023f965060009550339450506102ab92505050565b50600d5461024d90336102ab565b5050505050505061051b565b600680546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60008281526008602090815260408083206001600160a01b038516845290915281205460ff166103515760008381526008602090815260408083206001600160a01b03861684529091529020805460ff191660011790556103093390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a4506001610355565b5060005b92915050565b6125d280613fcc83390190565b80516001600160a01b038116811461037f57600080fd5b919050565b60008060008060008060c0878903121561039d57600080fd5b6103a687610368565b95506103b460208801610368565b94506103c260408801610368565b93506103d060608801610368565b92506103de60808801610368565b91506103ec60a08801610368565b90509295509295509295565b634e487b7160e01b600052601160045260246000fd5b81810381811115610355576103556103f8565b6001815b600184111561045c57808504811115610440576104406103f8565b600184161561044e57908102905b60019390931c928002610425565b935093915050565b60008261047357506001610355565b8161048057506000610355565b816001811461049657600281146104a0576104bc565b6001915050610355565b60ff8411156104b1576104b16103f8565b50506001821b610355565b5060208310610133831016604e8410600b84101617156104df575081810a610355565b6104ec6000198484610421565b8060001904821115610500576105006103f8565b029392505050565b60006105148383610464565b9392505050565b60805160a051613a5b61057160003960008181610477015281816108e701528181611bcc0152818161249d01528181612653015281816127f201526128ab0152600081816102dd01526120070152613a5b6000f3fe6080604052600436106102525760003560e01c806382413eac11610138578063b906a418116100b0578063d547741f11610077578063d547741f146107eb578063e82955881461080b578063f178e47c1461082b578063f2fde38b14610858578063fc7e9c6f14610878578063ff7bd03d1461088e57005b8063b906a4181461073c578063bb0b6a531461075c578063c2b40ae414610789578063ca5eb5e1146107b6578063cd87a3b4146107d657005b806390eeb02b116100ff57806390eeb02b1461066157806391d1485414610693578063a217fddf146106b3578063a38a8a8c146106c8578063a6232a93146106e8578063b42147cd1461070857005b806382413eac146105b457806384746900146105e3578063864eb164146106035780638da5cb5b146106235780638daed5281461064157005b806336568abe116101cb578063715018a611610192578063715018a6146104b957806375c3c0ce146104ce5780637bb10071146105035780637d25a05e146105335780637ecf686d1461056e57806380fc74981461059e57005b806336568abe146104125780635bb93995146104325780635cd233f7146104525780635e280f111461046557806367843a5b1461049957005b806317442b701161021a57806317442b7014610332578063248a9ca31461035457806326120c88146103845780632f2ff15d146103bc5780633400288b146103dc578063353efdcf146103fc57005b806301ffc9a714610254578063063bde24146102895780630ef26743146102cb57806313137d65146102ff57806313425efa14610312575b005b34801561026057600080fd5b5061027461026f366004612bd8565b6108ae565b60405190151581526020015b60405180910390f35b34801561029557600080fd5b506102bd7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000181565b604051908152602001610280565b3480156102d757600080fd5b506102bd7f000000000000000000000000000000000000000000000000000000000000000081565b61025261030d366004612c77565b6108e5565b34801561031e57600080fd5b5061025261032d366004612d71565b6109a5565b34801561033e57600080fd5b5060408051600181526002602082015201610280565b34801561036057600080fd5b506102bd61036f366004612e39565b60009081526008602052604090206001015490565b34801561039057600080fd5b506009546103a4906001600160a01b031681565b6040516001600160a01b039091168152602001610280565b3480156103c857600080fd5b506102526103d7366004612e52565b610da8565b3480156103e857600080fd5b506102526103f7366004612e96565b610dd3565b34801561040857600080fd5b506102bd600d5481565b34801561041e57600080fd5b5061025261042d366004612e52565b610de9565b34801561043e57600080fd5b506102bd61044d366004612ec0565b610e21565b610252610460366004612ee2565b610eba565b34801561047157600080fd5b506103a47f000000000000000000000000000000000000000000000000000000000000000081565b3480156104a557600080fd5b506102526104b4366004612fc8565b6112f4565b3480156104c557600080fd5b506102526116fa565b3480156104da57600080fd5b506104ee6104e936600461310d565b61170e565b60408051928352602083019190915201610280565b34801561050f57600080fd5b5061027461051e36600461319f565b600f6020526000908152604090205460ff1681565b34801561053f57600080fd5b5061055661054e366004612e96565b600092915050565b6040516001600160401b039091168152602001610280565b34801561057a57600080fd5b50610274610589366004612e39565b600e6020526000908152604090205460ff1681565b3480156105aa57600080fd5b506102bd60045481565b3480156105c057600080fd5b506102746105cf3660046131bc565b6001600160a01b0381163014949350505050565b3480156105ef57600080fd5b506102526105fe366004613222565b61178d565b34801561060f57600080fd5b50600b546103a4906001600160a01b031681565b34801561062f57600080fd5b506006546001600160a01b03166103a4565b34801561064d57600080fd5b50600a546103a4906001600160a01b031681565b34801561066d57600080fd5b5060025461067e9063ffffffff1681565b60405163ffffffff9091168152602001610280565b34801561069f57600080fd5b506102746106ae366004612e52565b611ac4565b3480156106bf57600080fd5b506102bd600081565b3480156106d457600080fd5b50600c546103a4906001600160a01b031681565b3480156106f457600080fd5b50610274610703366004612e39565b611aef565b34801561071457600080fd5b506102bd7f124005ad54174bbcb8c2dd053ea318daa80106cdcc518731504b771d6006123f81565b34801561074857600080fd5b506102526107573660046132c5565b611b6e565b34801561076857600080fd5b506102bd6107773660046132f3565b60076020526000908152604090205481565b34801561079557600080fd5b506102bd6107a4366004612e39565b60016020526000908152604090205481565b3480156107c257600080fd5b506102526107d136600461319f565b611ba5565b3480156107e257600080fd5b5061067e606481565b3480156107f757600080fd5b50610252610806366004612e52565b611c2b565b34801561081757600080fd5b506102bd610826366004612e39565b611c50565b34801561083757600080fd5b506102bd610846366004612e39565b60006020819052908152604090205481565b34801561086457600080fd5b5061025261087336600461319f565b611e9a565b34801561088457600080fd5b506102bd60035481565b34801561089a57600080fd5b506102746108a936600461330e565b611ed8565b60006001600160e01b03198216637965db0b60e01b14806108df57506301ffc9a760e01b6001600160e01b03198316145b92915050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163314610935576040516391ac5e4f60e01b81523360048201526024015b60405180910390fd5b6020870180359061094f9061094a908a6132f3565b611f0e565b1461098d5761096160208801886132f3565b60405163309afaf360e21b815263ffffffff90911660048201526020880135602482015260440161092c565b61099c87878787878787611f4a565b50505050505050565b600d546109b181611f9c565b6000896001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109f1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a15919061332a565b905060006001600160a01b038b166323b872dd3330610a3586600a61344a565b8e6001600160401b0316610a499190613459565b6040516001600160e01b031960e086901b1681526001600160a01b03938416600482015292909116602483015260448201526064016020604051808303816000875af1158015610a9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac19190613470565b905080610b105760405162461bcd60e51b815260206004820152601a60248201527f6661696c656420746f207472616e73666572206465706f736974000000000000604482015260640161092c565b600954604051633a94343960e21b81526000916001600160a01b03169063ea50d0e490610b47908d908d908d908d906004016134b6565b602060405180830381865afa158015610b64573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b889190613470565b905080610bd05760405162461bcd60e51b8152602060048201526016602482015275496e76616c6964206465706f7369742070726f6f662160501b604482015260640161092c565b87876001818110610be357610be3613502565b9050602002013560001c6001600160a01b03168c6001600160a01b031614610c465760405162461bcd60e51b815260206004820152601660248201527508aa486646040c2c8c8e4cae6e640dad2e6dac2e8c6d60531b604482015260640161092c565b87876002818110610c5957610c59613502565b9050602002013560001c6001600160401b03168b6001600160401b031614610cc35760405162461bcd60e51b815260206004820152601860248201527f4164647265737320616d6f756e7420696e636f72726563740000000000000000604482015260640161092c565b610ce888886000818110610cd957610cd9613502565b9050602002013560001c611fa6565b5060005b600381108015610cfb57508581105b15610d9957868682818110610d1257610d12613502565b9050602002810190610d249190613518565b159050610d87577f1350ba861189904691f5a79791c8b0eb3c5ea51a8954ae413a167e05c66ca1e0878783818110610d5e57610d5e613502565b9050602002810190610d709190613518565b604051610d7e92919061355e565b60405180910390a15b80610d918161357a565b915050610cec565b50505050505050505050505050565b600082815260086020526040902060010154610dc381611f9c565b610dcd8383612196565b50505050565b610ddb61222a565b610de58282612257565b5050565b6001600160a01b0381163314610e125760405163334bd91960e11b815260040160405180910390fd5b610e1c82826122ac565b505050565b600554600090610eb3906001600160a01b031663055d8d54610e4286612319565b610e4b86612319565b6040516001600160e01b031960e085901b16815260048101929092526024820152604401602060405180830381865afa158015610e8c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb09190613593565b90565b9392505050565b610edf86866000818110610ed057610ed0613502565b9050602002013560001c611aef565b610efb5760405162461bcd60e51b815260040161092c906135ac565b600c54604051633a94343960e21b81526000916001600160a01b03169063ea50d0e490610f32908c908c908c908c906004016134b6565b602060405180830381865afa158015610f4f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f739190613470565b905080610fb75760405162461bcd60e51b815260206004820152601260248201527124b73b30b634b2103bb0b93810383937b7b360711b604482015260640161092c565b60075b600981101561106e576000888883818110610fd757610fd7613502565b9050602002013514611066576000888883818110610ff757610ff7613502565b6001600160a01b03602091820293909301359283166000908152600f90915260409020549192505060ff166110645760405162461bcd60e51b8152602060048201526013602482015272139bdd0818481cdd5c1c1bdc9d19590813d195606a1b604482015260640161092c565b505b600101610fba565b5060015b6003811161118957600088888381811061108e5761108e613502565b905060200201351461117757600e60008989848181106110b0576110b0613502565b602090810292909201358352508101919091526040016000205460ff16156110ea5760405162461bcd60e51b815260040161092c906135d3565b6001600e60008a8a8581811061110257611102613502565b90506020020135815260200190815260200160002060006101000a81548160ff02191690831515021790555087878281811061114057611140613502565b9050602002013560001c7f49dad0e89c31a259d3e177fa5c4bb23dfb7bfbc2afce873328262a97dd39277860405160405180910390a25b806111818161357a565b915050611072565b5060006111968888612323565b90506000816040516020016111ab919061360a565b60408051601f198184030181526020601f8a01819004810284018101909252888352925061120f918e918491908b908b90819084018382808284376000920182905250604080518082019091523481526020810191909152925030915061246a9050565b5063ffffffff8c166000908152600760205260409020546112348d828c8c8c8c612575565b60005b60038110801561124657508581105b156112e45786868281811061125d5761125d613502565b905060200281019061126f9190613518565b1590506112d2577f1350ba861189904691f5a79791c8b0eb3c5ea51a8954ae413a167e05c66ca1e08787838181106112a9576112a9613502565b90506020028101906112bb9190613518565b6040516112c992919061355e565b60405180910390a15b806112dc8161357a565b915050611237565b5050505050505050505050505050565b61130a82826000818110610ed057610ed0613502565b6113265760405162461bcd60e51b815260040161092c906135ac565b600b54604051633a94343960e21b81526000916001600160a01b03169063ea50d0e49061135d9088908890889088906004016134b6565b602060405180830381865afa15801561137a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061139e9190613470565b9050806113e65760405162461bcd60e51b815260206004820152601660248201527524b73b30b634b2103bb4ba34323930bb90383937b7b360511b604482015260640161092c565b60015b6003811161150057600084848381811061140557611405613502565b90506020020135146114ee57600e600085858481811061142757611427613502565b602090810292909201358352508101919091526040016000205460ff16156114615760405162461bcd60e51b815260040161092c906135d3565b6001600e600086868581811061147957611479613502565b90506020020135815260200190815260200160002060006101000a81548160ff0219169083151502179055508383828181106114b7576114b7613502565b9050602002013560001c7f49dad0e89c31a259d3e177fa5c4bb23dfb7bfbc2afce873328262a97dd39277860405160405180910390a25b806114f88161357a565b9150506113e9565b5060005b60038110156116f257600061151a82600461364d565b9050600061152983600761364d565b9050600061153884600a61364d565b9050600087878581811061154e5761154e613502565b9050602002013560001c9050600088888581811061156e5761156e613502565b9050602002013560001c9050600089898581811061158e5761158e613502565b602002919091013591505081156116e0576000836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156115df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611603919061332a565b9050600061161282600a61344a565b61161c9085613459565b60405163a9059cbb60e01b81526001600160a01b0385811660048301526024820183905291925060009187169063a9059cbb906044016020604051808303816000875af1158015611671573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116959190613470565b9050806116dc5760405162461bcd60e51b8152602060048201526015602482015274151bdad95b881d1c985b9cd9995c8819985a5b1959605a1b604482015260640161092c565b5050505b50506001909401935061150492505050565b505050505050565b61170261222a565b61170c60006125eb565b565b600080600086604051602001611724919061360a565b60408051601f198184030181526020601f89018190048102840181019092528783529250600091611775918b9185918b908b90819084018382808284376000920191909152508b925061263d915050565b8051602090910151909a909950975050505050505050565b6117a384846000818110610ed057610ed0613502565b6117bf5760405162461bcd60e51b815260040161092c906135ac565b600a54604051633a94343960e21b81526000916001600160a01b03169063ea50d0e4906117f6908a908a908a908a906004016134b6565b602060405180830381865afa158015611813573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118379190613470565b90508061187f5760405162461bcd60e51b815260206004820152601660248201527524b73b30b634b2103a3930b739b332b910383937b7b360511b604482015260640161092c565b60015b61188e6003600161364d565b81101561199a5760008686838181106118a9576118a9613502565b905060200201351461199257600e60008787848181106118cb576118cb613502565b602090810292909201358352508101919091526040016000205460ff16156119055760405162461bcd60e51b815260040161092c906135d3565b6001600e600088888581811061191d5761191d613502565b90506020020135815260200190815260200160002060006101000a81548160ff02191690831515021790555085858281811061195b5761195b613502565b9050602002013560001c7f49dad0e89c31a259d3e177fa5c4bb23dfb7bfbc2afce873328262a97dd39277860405160405180910390a25b600101611882565b5060006119a96003600161364d565b90505b60036119b981600161364d565b6119c3919061364d565b811015611a095760008686838181106119de576119de613502565b9050602002013514611a01576119ff868683818110610cd957610cd9613502565b505b6001016119ac565b5060005b600381108015611a1c57508281105b15611aba57838382818110611a3357611a33613502565b9050602002810190611a459190613518565b159050611aa8577f1350ba861189904691f5a79791c8b0eb3c5ea51a8954ae413a167e05c66ca1e0848483818110611a7f57611a7f613502565b9050602002810190611a919190613518565b604051611a9f92919061355e565b60405180910390a15b80611ab28161357a565b915050611a0d565b5050505050505050565b60009182526008602090815260408084206001600160a01b0393909316845291905290205460ff1690565b600081600003611b0157506000919050565b60025463ffffffff16805b63ffffffff81166000908152600160205260409020548403611b32575060019392505050565b8063ffffffff16600003611b44575060645b80611b4e81613660565b9150508163ffffffff168163ffffffff1603611b0c575060009392505050565b6000611b7981611f9c565b506001600160a01b03919091166000908152600f60205260409020805460ff1916911515919091179055565b611bad61222a565b60405163ca5eb5e160e01b81526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063ca5eb5e190602401600060405180830381600087803b158015611c1057600080fd5b505af1158015611c24573d6000803e3d6000fd5b5050505050565b600082815260086020526040902060010154611c4681611f9c565b610dcd83836122ac565b600081600003611c8157507f1e2856f9f722631c878a92dc1d84283d04b76df3e1831492bdf7098c1e65e478919050565b81600103611cb057507f2c2eecb1b14035bfd9765e84195684b401a84fdb58c3c03f1bcea86dcf0c8105919050565b81600203611cdf57507f237e412a71db31e5769f63d92346a09dd0f30b9c335e9d9aa96b6625eb537445919050565b81600303611d0e57507f0b3ff120d61a7de2da3d80ff99d393796805c74be5c39e8a4c7436d1c65dad4c919050565b81600403611d3d57507f0fc58e21665302678bef68714d9e5889583071f7bd3cf018b64fafc51b0a9cf3919050565b81600503611d6c57507f235df7c585524ed8a26aea20a0fb168038f10df71d84720c9a8c1b3e78e3b6cd919050565b81600603611d9b57507f1c6cabee394ea24dc09eab1788f7f62b367e95789f883e33690d94215d819264919050565b81600703611dca57507f09bec327ab2c8dda5d2d435cd267cb21e71f21371a01739885817eb1625d8976919050565b81600803611df957507f2d35519ad7061578be50cbbfe040327843f6b4cdf1458e01b5f9737dbaf82b18919050565b81600903611e2857507f0f86c9e9c9e689394a4944bb87291a3f55cc930b21432fccf41b8267f1a98d6f919050565b81600a03611e5757507f181c9ba70900093b180c96f55cc2b1d73d60b8ab613344cbba83b33cbcc94e2b919050565b60405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b604482015260640161092c565b919050565b611ea261222a565b6001600160a01b038116611ecc57604051631e4fbdf760e01b81526000600482015260240161092c565b611ed5816125eb565b50565b6000602082018035906007908390611ef090866132f3565b63ffffffff1681526020810191909152604001600020541492915050565b63ffffffff8116600090815260076020526040812054806108df5760405163f6ff4fb760e01b815263ffffffff8416600482015260240161092c565b6000611f5885870187613680565b905060005b8151811015611f9157611f88828281518110611f7b57611f7b613502565b6020026020010151611fa6565b50600101611f5d565b505050505050505050565b611ed5813361271e565b600354600454600091908103611fea5760405162461bcd60e51b8152602060048201526009602482015268151c995948119d5b1b60ba1b604482015260640161092c565b6000818152602081905260408120849055819084905b61202b60017f00000000000000000000000000000000000000000000000000000000000000006136b4565b8110156120fd57600061203f6002856136dd565b159050600081612059576120546001866136b4565b612064565b61206485600161364d565b602084811b8217600081815291829052604082205492935091908190036120915761208e85611c50565b90505b83156120a8576120a18682610e21565b95506120b5565b6120b28187610e21565b95505b6120c06002886136f1565b9650856000806120dc6120d489600161364d565b60201b8b1790565b81526020810191909152604001600020555050600190920191506120009050565b506002546000906064906121189063ffffffff166001613705565b6121229190613721565b6002805463ffffffff191663ffffffff8316908117909155600090815260016020819052604090912084905590915061215c90859061364d565b600355604051869085907f604f5a492f8c1622a2e239876074a13b33ec11384fe2b310339ece35e8eecac790600090a35091949350505050565b60006121a28383611ac4565b6122225760008381526008602090815260408083206001600160a01b03861684529091529020805460ff191660011790556121da3390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45060016108df565b5060006108df565b6006546001600160a01b0316331461170c5760405163118cdaa760e01b815233600482015260240161092c565b63ffffffff8216600081815260076020908152604091829020849055815192835282018390527f238399d427b947898edb290f5ff0f9109849b1c3ba196a42e35f00c50a54b98b910160405180910390a15050565b60006122b88383611ac4565b156122225760008381526008602090815260408083206001600160a01b0386168085529252808320805460ff1916905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45060016108df565b80611e9581612757565b6040805160038082526080820190925260609160009190602082018480368337019050509050600060045b600681116123cf57600086868381811061236a5761236a613502565b90506020020135146123bd5785858281811061238857612388613502565b9050602002013560001c8383815181106123a4576123a4613502565b6020908102919091010152816123b98161357a565b9250505b806123c78161357a565b91505061234e565b506000816001600160401b038111156123ea576123ea613037565b604051908082528060200260200182016040528015612413578160200160208202803683370190505b50905060005b828110156124605783818151811061243357612433613502565b602002602001015182828151811061244d5761244d613502565b6020908102919091010152600101612419565b5095945050505050565b612472612b91565b600061248184600001516127c6565b60208501519091501561249b5761249b84602001516127ee565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632637a450826040518060a001604052808b63ffffffff1681526020016124eb8c611f0e565b81526020018a815260200189815260200160008960200151111515815250866040518463ffffffff1660e01b815260040161252792919061378f565b60806040518083038185885af1158015612545573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061256a91906138c2565b979650505050505050565b60075b600a81101561099c57600085858381811061259557612595613502565b60200291909101359150506001600160a01b038116156125e2576125e288888389896125c288600361364d565b8181106125d1576125d1613502565b9050602002013560001c88886128d0565b50600101612578565b600680546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60408051808201909152600080825260208201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ddc28c586040518060a001604052808863ffffffff1681526020016126a089611f0e565b8152602001878152602001868152602001851515815250306040518363ffffffff1660e01b81526004016126d592919061378f565b6040805180830381865afa1580156126f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061271591906138de565b95945050505050565b6127288282611ac4565b610de55760405163e2517d3f60e01b81526001600160a01b03821660048201526024810183905260440161092c565b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018110611ed55760405162461bcd60e51b815260206004820152601960248201527f4669656c643a20696e70757420697320746f6f206c6172676500000000000000604482015260640161092c565b60008134146127ea576040516304fb820960e51b815234600482015260240161092c565b5090565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e4fe1d946040518163ffffffff1660e01b8152600401602060405180830381865afa15801561284e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061287291906138fa565b90506001600160a01b03811661289b576040516329b99a9560e11b815260040160405180910390fd5b610de56001600160a01b038216337f000000000000000000000000000000000000000000000000000000000000000085612acb565b6000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015612910573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612934919061332a565b61293f90600a61344a565b6129499085613459565b905060006040518060e001604052808963ffffffff16815260200188815260200183815260200183815260200185858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525093855250506040805160208181018352848252808601919091528151908101825283815293810193909352509051633b6f743b60e01b8152919250906001600160a01b03881690633b6f743b90612a05908590859060040161398d565b6040805180830381865afa158015612a21573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a4591906138de565b805160405163c7c7f5b360e01b81529192506001600160a01b0389169163c7c7f5b39190612a7b908690869033906004016139b1565b60c06040518083038185885af1158015612a99573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190612abe91906139f0565b5050505050505050505050565b604080516001600160a01b038581166024830152841660448201526064808201849052825180830390910181526084909101909152602080820180516001600160e01b03166323b872dd60e01b1781528251610dcd938893909260009283929183919082885af180612b43576040513d6000823e3d81fd5b50506000513d91508115612b5b578060011415612b68565b6001600160a01b0384163b155b15610dcd57604051635274afe760e01b81526001600160a01b038516600482015260240161092c565b60405180606001604052806000801916815260200160006001600160401b03168152602001612bd3604051806040016040528060008152602001600081525090565b905290565b600060208284031215612bea57600080fd5b81356001600160e01b031981168114610eb357600080fd5b600060608284031215612c1457600080fd5b50919050565b60008083601f840112612c2c57600080fd5b5081356001600160401b03811115612c4357600080fd5b602083019150836020828501011115612c5b57600080fd5b9250929050565b6001600160a01b0381168114611ed557600080fd5b600080600080600080600060e0888a031215612c9257600080fd5b612c9c8989612c02565b96506060880135955060808801356001600160401b03811115612cbe57600080fd5b612cca8a828b01612c1a565b90965094505060a0880135612cde81612c62565b925060c08801356001600160401b03811115612cf957600080fd5b612d058a828b01612c1a565b989b979a50959850939692959293505050565b6001600160401b0381168114611ed557600080fd5b60008083601f840112612d3f57600080fd5b5081356001600160401b03811115612d5657600080fd5b6020830191508360208260051b8501011115612c5b57600080fd5b60008060008060008060008060a0898b031215612d8d57600080fd5b8835612d9881612c62565b97506020890135612da881612d18565b965060408901356001600160401b03811115612dc357600080fd5b612dcf8b828c01612c1a565b90975095505060608901356001600160401b03811115612dee57600080fd5b612dfa8b828c01612d2d565b90955093505060808901356001600160401b03811115612e1957600080fd5b612e258b828c01612d2d565b999c989b5096995094979396929594505050565b600060208284031215612e4b57600080fd5b5035919050565b60008060408385031215612e6557600080fd5b823591506020830135612e7781612c62565b809150509250929050565b803563ffffffff81168114611e9557600080fd5b60008060408385031215612ea957600080fd5b612eb283612e82565b946020939093013593505050565b60008060408385031215612ed357600080fd5b50508035926020909101359150565b600080600080600080600080600060a08a8c031215612f0057600080fd5b612f098a612e82565b985060208a01356001600160401b03811115612f2457600080fd5b612f308c828d01612c1a565b90995097505060408a01356001600160401b03811115612f4f57600080fd5b612f5b8c828d01612d2d565b90975095505060608a01356001600160401b03811115612f7a57600080fd5b612f868c828d01612c1a565b90955093505060808a01356001600160401b03811115612fa557600080fd5b612fb18c828d01612d2d565b915080935050809150509295985092959850929598565b60008060008060408587031215612fde57600080fd5b84356001600160401b03811115612ff457600080fd5b61300087828801612c1a565b90955093505060208501356001600160401b0381111561301f57600080fd5b61302b87828801612d2d565b95989497509550505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b038111828210171561307557613075613037565b604052919050565b600082601f83011261308e57600080fd5b81356001600160401b038111156130a7576130a7613037565b8060051b6130b76020820161304d565b918252602081850181019290810190868411156130d357600080fd5b6020860192505b838310156130f55782358252602092830192909101906130da565b9695505050505050565b8015158114611ed557600080fd5b60008060008060006080868803121561312557600080fd5b61312e86612e82565b945060208601356001600160401b0381111561314957600080fd5b6131558882890161307d565b94505060408601356001600160401b0381111561317157600080fd5b61317d88828901612c1a565b9094509250506060860135613191816130ff565b809150509295509295909350565b6000602082840312156131b157600080fd5b8135610eb381612c62565b60008060008060a085870312156131d257600080fd5b6131dc8686612c02565b935060608501356001600160401b038111156131f757600080fd5b61320387828801612c1a565b909450925050608085013561321781612c62565b939692955090935050565b6000806000806000806060878903121561323b57600080fd5b86356001600160401b0381111561325157600080fd5b61325d89828a01612c1a565b90975095505060208701356001600160401b0381111561327c57600080fd5b61328889828a01612d2d565b90955093505060408701356001600160401b038111156132a757600080fd5b6132b389828a01612d2d565b979a9699509497509295939492505050565b600080604083850312156132d857600080fd5b82356132e381612c62565b91506020830135612e77816130ff565b60006020828403121561330557600080fd5b610eb382612e82565b60006060828403121561332057600080fd5b610eb38383612c02565b60006020828403121561333c57600080fd5b815160ff81168114610eb357600080fd5b634e487b7160e01b600052601160045260246000fd5b6001815b600184111561339e578085048111156133825761338261334d565b600184161561339057908102905b60019390931c928002613367565b935093915050565b6000826133b5575060016108df565b816133c2575060006108df565b81600181146133d857600281146133e2576133fe565b60019150506108df565b60ff8411156133f3576133f361334d565b50506001821b6108df565b5060208310610133831016604e8410600b8410161715613421575081810a6108df565b61342e6000198484613363565b80600019048211156134425761344261334d565b029392505050565b6000610eb360ff8416836133a6565b80820281158282048414176108df576108df61334d565b60006020828403121561348257600080fd5b8151610eb3816130ff565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6040815260006134ca60408301868861348d565b82810360208401528381526001600160fb1b038411156134e957600080fd5b8360051b80866020840137016020019695505050505050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261352f57600080fd5b8301803591506001600160401b0382111561354957600080fd5b602001915036819003821315612c5b57600080fd5b60208152600061357260208301848661348d565b949350505050565b60006001820161358c5761358c61334d565b5060010190565b6000602082840312156135a557600080fd5b5051919050565b6020808252600d908201526c496e76616c696420526f6f742160981b604082015260600190565b60208082526017908201527f4e756c6c696669657220616c7265616479207370656e74000000000000000000604082015260600190565b602080825282518282018190526000918401906040840190835b81811015613642578351835260209384019390920191600101613624565b509095945050505050565b808201808211156108df576108df61334d565b600063ffffffff8216806136765761367661334d565b6000190192915050565b60006020828403121561369257600080fd5b81356001600160401b038111156136a857600080fd5b6135728482850161307d565b818103818111156108df576108df61334d565b634e487b7160e01b600052601260045260246000fd5b6000826136ec576136ec6136c7565b500690565b600082613700576137006136c7565b500490565b63ffffffff81811683821601908111156108df576108df61334d565b600063ffffffff831680613737576137376136c7565b8063ffffffff84160691505092915050565b6000815180845260005b8181101561376f57602081850181015186830182015201613753565b506000602082860101526020601f19601f83011685010191505092915050565b6040815263ffffffff8351166040820152602083015160608201526000604084015160a060808401526137c560e0840182613749565b90506060850151603f198483030160a08501526137e28282613749565b60809690960151151560c08501525050506001600160a01b039190911660209091015290565b60006040828403121561381a57600080fd5b604080519081016001600160401b038111828210171561383c5761383c613037565b604052825181526020928301519281019290925250919050565b60006080828403121561386857600080fd5b604051606081016001600160401b038111828210171561388a5761388a613037565b80604052508091508251815260208301516138a481612d18565b60208201526138b68460408501613808565b60408201525092915050565b6000608082840312156138d457600080fd5b610eb38383613856565b6000604082840312156138f057600080fd5b610eb38383613808565b60006020828403121561390c57600080fd5b8151610eb381612c62565b63ffffffff81511682526020810151602083015260408101516040830152606081015160608301526000608082015160e0608085015261395a60e0850182613749565b905060a083015184820360a08601526139738282613749565b91505060c083015184820360c08601526127158282613749565b6040815260006139a06040830185613917565b905082151560208301529392505050565b6080815260006139c46080830186613917565b8451602084810191909152909401516040830152506001600160a01b0391909116606090910152919050565b60008060c08385031215613a0357600080fd5b613a0d8484613856565b9150613a1c8460808501613808565b9050925092905056fea2646970667358221220c62b9a4ea0930f4e831270dc953dc2846a48cad862ce4efd41014f2dbb4f452464736f6c634300081b00336080604052348015600f57600080fd5b506125b38061001f6000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063055d8d541461005c57806340ec6e4914610081578063664db65a146100945780636bdcae5c146100a7578063e16f6200146100ba575b600080fd5b61006f61006a366004612358565b6100cd565b60405190815260200160405180910390f35b61006f61008f36600461242f565b6100e2565b61006f6100a2366004612464565b6100f1565b61006f6100b53660046124c4565b610106565b61006f6100c83660046124dd565b610111565b60006100d9838361011e565b90505b92915050565b60006100dc8283516000610198565b60006100fe848484610198565b949350505050565b60006100dc826101ad565b60006100fe84848461020e565b60408051600280825260608201835260009283929190602083019080368337019050509050838160008151811061015757610157612509565b602002602001018181525050828160018151811061017757610177612509565b6020026020010181815250506100fe61018e6102b2565b82600260006118a2565b60006100fe6101a56102b2565b8585856118a2565b6040805160018082528183019092526000918291906020808301908036833701905050905082816000815181106101e6576101e6612509565b6020026020010181815250506102076101fd6102b2565b82600160006118a2565b9392505050565b6040805160038082526080820190925260009182919060208201606080368337019050509050848160008151811061024857610248612509565b602002602001018181525050838160018151811061026857610268612509565b602002602001018181525050828160028151811061028857610288612509565b6020026020010181815250506102a961029f6102b2565b82600360006118a2565b95945050505050565b6102ba612287565b604051806040016040528060405180608001604052807f10dc6e9c006ea38b04b1e03b4bd9490c0d03f98929ca1d7fb56821fd19d3b6e781526020017f0c28145b6a44df3e0149b3d0a30b3bb599df9756d4dd9b84a86b38cfb45a740b81526020017e544b8338791518b2c7645a50392798b21f75bb60e3596170067d00141cac1581526020017f222c01175718386f2e2e82eb122789e352e105a3b8fa852613bc534433ee428b815250815260200160405180610800016040528060405180608001604052807f19b849f69450b06848da1d39bd5e4a4302bb86744edc26238b0878e269ed23e581526020017f265ddfe127dd51bd7239347b758f0a1320eb2cc7450acc1dad47f80c8dcf34d681526020017f199750ec472f1809e0f66a545e1e51624108ac845015c2aa3dfc36bab497d8aa81526020017f157ff3fe65ac7208110f06a5f74302b14d743ea25067f0ffd032f787c7f1cdf8815250815260200160405180608001604052807f2e49c43c4569dd9c5fd35ac45fca33f10b15c590692f8beefe18f4896ac9490281526020017f0e35fb89981890520d4aef2b6d6506c3cb2f0b6973c24fa82731345ffa2d1f1e81526020017f251ad47cb15c4f1105f109ae5e944f1ba9d9e7806d667ffec6fe723002e0b99681526020017f13da07dc64d428369873e97160234641f8beb56fdd05e5f3563fa39d9c22df4e815250815260200160405180608001604052807f0c009b84e650e6d23dc00c7dccef7483a553939689d350cd46e7b89055fd473881526020017f011f16b1c63a854f01992e3956f42d8b04eb650c6d535eb0203dec74befdca0681526020017f0ed69e5e383a688f209d9a561daa79612f3f78d0467ad45485df07093f36754981526020017f04dba94a7b0ce9e221acad41472b6bbe3aec507f5eb3d33f463672264c9f789b815250815260200160405180608001604052807f0a3f2637d840f3a16eb094271c9d237b6036757d4bb50bf7ce732ff1d4fa28e881526020017f259a666f129eea198f8a1c502fdb38fa39b1f075569564b6e54a485d1182323f81526020017f28bf7459c9b2f4c6d8e7d06a4ee3a47f7745d4271038e5157a32fdf7ede0d6a181526020017f0a1ca941f057037526ea200f489be8d4c37c85bbcce6a2aeec91bd6941432447815250815260200160405180608001604052807f0c6f8f958be0e93053d7fd4fc54512855535ed1539f051dcb43a26fd926361cf815260200160008152602001600081526020016000815250815260200160405180608001604052807f123106a93cd17578d426e8128ac9d90aa9e8a00708e296e084dd57e69caaf811815260200160008152602001600081526020016000815250815260200160405180608001604052807f26e1ba52ad9285d97dd3ab52f8e840085e8fa83ff1e8f1877b074867cd2dee75815260200160008152602001600081526020016000815250815260200160405180608001604052807f1cb55cad7bd133de18a64c5c47b9c97cbe4d8b7bf9e095864471537e6a4ae2c5815260200160008152602001600081526020016000815250815260200160405180608001604052807f1dcd73e46acd8f8e0e2c7ce04bde7f6d2a53043d5060a41c7143f08e6e9055d0815260200160008152602001600081526020016000815250815260200160405180608001604052807f011003e32f6d9c66f5852f05474a4def0cda294a0eb4e9b9b12b9bb4512e5574815260200160008152602001600081526020016000815250815260200160405180608001604052807f2b1e809ac1d10ab29ad5f20d03a57dfebadfe5903f58bafed7c508dd2287ae8c815260200160008152602001600081526020016000815250815260200160405180608001604052807f2539de1785b735999fb4dac35ee17ed0ef995d05ab2fc5faeaa69ae87bcec0a5815260200160008152602001600081526020016000815250815260200160405180608001604052807f0c246c5a2ef8ee0126497f222b3e0a0ef4e1c3d41c86d46e43982cb11d77951d815260200160008152602001600081526020016000815250815260200160405180608001604052807f192089c4974f68e95408148f7c0632edbb09e6a6ad1a1c2f3f0305f5d03b527b815260200160008152602001600081526020016000815250815260200160405180608001604052807f1eae0ad8ab68b2f06a0ee36eeb0d0c058529097d91096b756d8fdc2fb5a60d85815260200160008152602001600081526020016000815250815260200160405180608001604052807f179190e5d0e22179e46f8282872abc88db6e2fdc0dee99e69768bd98c5d06bfb815260200160008152602001600081526020016000815250815260200160405180608001604052807f29bb9e2c9076732576e9a81c7ac4b83214528f7db00f31bf6cafe794a9b3cd1c815260200160008152602001600081526020016000815250815260200160405180608001604052807f225d394e42207599403efd0c2464a90d52652645882aac35b10e590e6e691e08815260200160008152602001600081526020016000815250815260200160405180608001604052807f064760623c25c8cf753d238055b444532be13557451c087de09efd454b23fd59815260200160008152602001600081526020016000815250815260200160405180608001604052807f10ba3a0e01df92e87f301c4b716d8a394d67f4bf42a75c10922910a78f6b5b87815260200160008152602001600081526020016000815250815260200160405180608001604052807f0e070bf53f8451b24f9c6e96b0c2a801cb511bc0c242eb9d361b77693f21471c815260200160008152602001600081526020016000815250815260200160405180608001604052807f1b94cd61b051b04dd39755ff93821a73ccd6cb11d2491d8aa7f921014de252fb815260200160008152602001600081526020016000815250815260200160405180608001604052807f1d7cb39bafb8c744e148787a2e70230f9d4e917d5713bb050487b5aa7d74070b815260200160008152602001600081526020016000815250815260200160405180608001604052807f2ec93189bd1ab4f69117d0fe980c80ff8785c2961829f701bb74ac1f303b17db815260200160008152602001600081526020016000815250815260200160405180608001604052807f2db366bfdd36d277a692bb825b86275beac404a19ae07a9082ea46bd83517926815260200160008152602001600081526020016000815250815260200160405180608001604052807f062100eb485db06269655cf186a68532985275428450359adc99cec6960711b8815260200160008152602001600081526020016000815250815260200160405180608001604052807f0761d33c66614aaa570e7f1e8244ca1120243f92fa59e4f900c567bf41f5a59b815260200160008152602001600081526020016000815250815260200160405180608001604052807f20fc411a114d13992c2705aa034e3f315d78608a0f7de4ccf7a72e494855ad0d815260200160008152602001600081526020016000815250815260200160405180608001604052807f25b5c004a4bdfcb5add9ec4e9ab219ba102c67e8b3effb5fc3a30f317250bc5a815260200160008152602001600081526020016000815250815260200160405180608001604052807f23b1822d278ed632a494e58f6df6f5ed038b186d8474155ad87e7dff62b37f4b815260200160008152602001600081526020016000815250815260200160405180608001604052807f22734b4c5c3f9493606c4ba9012499bf0f14d13bfcfcccaa16102a29cc2f69e0815260200160008152602001600081526020016000815250815260200160405180608001604052807f26c0c8fe09eb30b7e27a74dc33492347e5bdff409aa3610254413d3fad795ce5815260200160008152602001600081526020016000815250815260200160405180608001604052807f070dd0ccb6bd7bbae88eac03fa1fbb26196be3083a809829bbd626df348ccad9815260200160008152602001600081526020016000815250815260200160405180608001604052807f12b6595bdb329b6fb043ba78bb28c3bec2c0a6de46d8c5ad6067c4ebfd4250da815260200160008152602001600081526020016000815250815260200160405180608001604052807f248d97d7f76283d63bec30e7a5876c11c06fca9b275c671c5e33d95bb7e8d729815260200160008152602001600081526020016000815250815260200160405180608001604052807f1a306d439d463b0816fc6fd64cc939318b45eb759ddde4aa106d15d9bd9baaaa815260200160008152602001600081526020016000815250815260200160405180608001604052807f28a8f8372e3c38daced7c00421cb4621f4f1b54ddc27821b0d62d3d6ec7c56cf815260200160008152602001600081526020016000815250815260200160405180608001604052807e94975717f9a8a8bb35152f24d43294071ce320c829f388bc852183e1e2ce7e815260200160008152602001600081526020016000815250815260200160405180608001604052807f04d5ee4c3aa78f7d80fde60d716480d3593f74d4f653ae83f4103246db2e8d65815260200160008152602001600081526020016000815250815260200160405180608001604052807f2a6cf5e9aa03d4336349ad6fb8ed2269c7bef54b8822cc76d08495c12efde187815260200160008152602001600081526020016000815250815260200160405180608001604052807f2304d31eaab960ba9274da43e19ddeb7f792180808fd6e43baae48d7efcba3f3815260200160008152602001600081526020016000815250815260200160405180608001604052807f03fd9ac865a4b2a6d5e7009785817249bff08a7e0726fcb4e1c11d39d199f0b0815260200160008152602001600081526020016000815250815260200160405180608001604052807eb7258ded52bbda2248404d55ee5044798afc3a209193073f7954d4d63b0b64815260200160008152602001600081526020016000815250815260200160405180608001604052807f159f81ada0771799ec38fca2d4bf65ebb13d3a74f3298db36272c5ca65e92d9a815260200160008152602001600081526020016000815250815260200160405180608001604052807f1ef90e67437fbc8550237a75bc28e3bb9000130ea25f0c5471e144cf4264431f815260200160008152602001600081526020016000815250815260200160405180608001604052807f1e65f838515e5ff0196b49aa41a2d2568df739bc176b08ec95a79ed82932e30d815260200160008152602001600081526020016000815250815260200160405180608001604052807f2b1b045def3a166cec6ce768d079ba74b18c844e570e1f826575c1068c94c33f815260200160008152602001600081526020016000815250815260200160405180608001604052807f0832e5753ceb0ff6402543b1109229c165dc2d73bef715e3f1c6e07c168bb173815260200160008152602001600081526020016000815250815260200160405180608001604052807f02f614e9cedfb3dc6b762ae0a37d41bab1b841c2e8b6451bc5a8e3c390b6ad16815260200160008152602001600081526020016000815250815260200160405180608001604052807f0e2427d38bd46a60dd640b8e362cad967370ebb777bedff40f6a0be27e7ed705815260200160008152602001600081526020016000815250815260200160405180608001604052807f0493630b7c670b6deb7c84d414e7ce79049f0ec098c3c7c50768bbe29214a53a815260200160008152602001600081526020016000815250815260200160405180608001604052807f22ead100e8e482674decdab17066c5a26bb1515355d5461a3dc06cc85327cea9815260200160008152602001600081526020016000815250815260200160405180608001604052807f25b3e56e655b42cdaae2626ed2554d48583f1ae35626d04de5084e0b6d2a6f16815260200160008152602001600081526020016000815250815260200160405180608001604052807f1e32752ada8836ef5837a6cde8ff13dbb599c336349e4c584b4fdc0a0cf6f9d0815260200160008152602001600081526020016000815250815260200160405180608001604052807f2fa2a871c15a387cc50f68f6f3c3455b23c00995f05078f672a9864074d412e5815260200160008152602001600081526020016000815250815260200160405180608001604052807f2f569b8a9a4424c9278e1db7311e889f54ccbf10661bab7fcd18e7c7a7d83505815260200160008152602001600081526020016000815250815260200160405180608001604052807f044cb455110a8fdd531ade530234c518a7df93f7332ffd2144165374b246b43d815260200160008152602001600081526020016000815250815260200160405180608001604052807f227808de93906d5d420246157f2e42b191fe8c90adfe118178ddc723a5319025815260200160008152602001600081526020016000815250815260200160405180608001604052807f02fcca2934e046bc623adead873579865d03781ae090ad4a8579d2e7a6800355815260200160008152602001600081526020016000815250815260200160405180608001604052807f0ef915f0ac120b876abccceb344a1d36bad3f3c5ab91a8ddcbec2e060d8befac815260200160008152602001600081526020016000815250815260200160405180608001604052807f1797130f4b7a3e1777eb757bc6f287f6ab0fb85f6be63b09f3b16ef2b1405d3881526020017f0a76225dc04170ae3306c85abab59e608c7f497c20156d4d36c668555decc6e581526020017f1fffb9ec1992d66ba1e77a7b93209af6f8fa76d48acb664796174b5326a31a5c81526020017f25721c4fc15a3f2853b57c338fa538d85f8fbba6c6b9c6090611889b797b9c5f815250815260200160405180608001604052807f0c817fd42d5f7a41215e3d07ba197216adb4c3790705da95eb63b982bfcaf75a81526020017f13abe3f5239915d39f7e13c2c24970b6df8cf86ce00a22002bc15866e52b5a9681526020017f2106feea546224ea12ef7f39987a46c85c1bc3dc29bdbd7a92cd60acb4d391ce81526020017f21ca859468a746b6aaa79474a37dab49f1ca5a28c748bc7157e1b3345bb0f959815250815260200160405180608001604052807f05ccd6255c1e6f0c5cf1f0df934194c62911d14d0321662a8f1a48999e34185b81526020017f0f0e34a64b70a626e464d846674c4c8816c4fb267fe44fe6ea28678cb09490a481526020017f0558531a4e25470c6157794ca36d0e9647dbfcfe350d64838f5b1a8a2de0d4bf81526020017f09d3dca9173ed2faceea125157683d18924cadad3f655a60b72f5864961f1455815250815260200160405180608001604052807f0328cbd54e8c0913493f866ed03d218bf23f92d68aaec48617d4c722e5bd433581526020017f2bf07216e2aff0a223a487b1a7094e07e79e7bcc9798c648ee3347dd5329d34b81526020017f1daf345a58006b736499c583cb76c316d6f78ed6a6dffc82111e11a63fe412df81526020017f176563472456aaa746b694c60e1823611ef39039b2edc7ff391e6f2293d2c404815250815250815250905090565b6000806118b96118b3865160401b90565b87611928565b905060005b855181101561190357848110156118fb576118fb8682815181106118e4576118e4612509565b6020026020010151836119ca90919063ffffffff16565b6001016118be565b508215611915576119158160016119ca565b61191e81611a58565b9695505050505050565b6119306122ac565b60006040518060c001604052808581526020016040518060600160405280600081526020016000815260200160008152508152602001604051806080016040528060008152602001600081526020016000815260200160008152508152602001600081526020016000151581526020018481525090508381604001516003600481106119be576119be612509565b60200201529392505050565b81608001511580156119e0575060038260600151145b156119ff576119ee82611b70565b506020820151526001606090910152565b8160800151158015611a1657506003826060015114155b15611a5457808260200151836060015160038110611a3657611a36612509565b602002015260608201805160019190611a50908390612535565b9052505b5050565b60008160800151611ac7576000611a6e83611b70565b60016080850152905060005b6003811015611abd57818160038110611a9557611a95612509565b602002015184602001518260038110611ab057611ab0612509565b6020020152600101611a7a565b5050600360608301525b60208201515160015b6003811015611b30578360600151811015611b285783602001518160038110611afb57611afb612509565b60200201518460200151600183611b129190612548565b60038110611b2257611b22612509565b60200201525b600101611ad0565b50600183606001818151611b449190612548565b905250602083015160608401516000919060038110611b6557611b65612509565b602002015292915050565b611b786122ee565b60005b6003811015611bb55782606001518110611bad57600083602001518260038110611ba757611ba7612509565b60200201525b600101611b7b565b5060005b6003811015611c2457611c0183602001518260038110611bdb57611bdb612509565b602002015184604001518360048110611bf657611bf6612509565b602002015190611cb3565b83604001518260048110611c1757611c17612509565b6020020152600101611bb9565b50611c4482604001518360a00151600001518460a0015160200151611ce0565b6040808401919091528051606081018252600080825260208201819052918101829052905b6003811015611cac5783604001518160048110611c8857611c88612509565b6020020151828260038110611c9f57611c9f612509565b6020020152600101611c69565b5092915050565b60007f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018284089392505050565b611ce861230c565b600060405180608001604052806000815260200160008152602001600081526020016000815250905060005b6004811015611d5357858160048110611d2f57611d2f612509565b6020020151828260048110611d4657611d46612509565b6020020152600101611d14565b50611d85816040518060400160405280600d81526020016c496e697469616c20737461746560981b8152506000611f99565b611d8e81611fc8565b611dcf816040518060400160405280601b81526020017f4166746572206d6174726978206d756c7469706c69636174696f6e00000000008152506000611f99565b6000611ddd6002600861255b565b905060005b81811015611e0f57611df58386836120c2565b611dfe8361212f565b611e0783611fc8565b600101611de2565b50611e3f826040518060400160405280600b81526020016a18599d195c88199a5c9cdd60aa1b8152506000611f99565b6000611e4c603883612535565b9050815b81811015611edb57611e7b868260408110611e6d57611e6d612509565b602002015151856000611bf6565b8452611e8e8460005b602002015161216f565b8452611e9a8488612192565b611ed38460405180604001604052806016815260200175666f72206c6f6f7020616674657220696e7465726e6d60501b81525083611f99565b600101611e50565b50611f0c836040518060400160405280600c81526020016b18599d195c881cd958dbdb9960a21b8152506000611f99565b6000611f1a60386008612535565b9050815b81811015611f4b57611f318588836120c2565b611f3a8561212f565b611f4385611fc8565b600101611f1e565b50611f8d846040518060400160405280601c81526020017f66696e616c20746869726420616674657220616c6c20726f756e6473000000008152506000611f99565b50919695505050505050565b60005b6004811015611fc257611fba848260048110611a5457611a54612509565b600101611f9c565b50505050565b6000611fdd8260016020020151836000611bf6565b90506000611ff48360036020020151846002611bf6565b9050600061200b8460016020020151856001611bf6565b90506120178183611cb3565b9050600061202e8560036020020151866003611bf6565b905061203a8185611cb3565b905060006120488480611cb3565b90506120548180611cb3565b90506120608183611cb3565b9050600061206e8680611cb3565b905061207a8180611cb3565b90506120868185611cb3565b905060006120948483611cb3565b905060006120a28685611cb3565b918952506020880191909152604087015260609095019490945250505050565b60005b6004811015611fc2576121108383604081106120e3576120e3612509565b602002015182600481106120f9576120f9612509565b6020020151858360048110611bf657611bf6612509565b84826004811061212257612122612509565b60200201526001016120c5565b60005b6004811015611a5457612150828260048110611e8457611e84612509565b82826004811061216257612162612509565b6020020152600101612132565b60008061217c838061225a565b90506102078361218c838061225a565b9061225a565b6000805b60048110156121ca576121c08482600481106121b4576121b4612509565b60200201518390611cb3565b9150600101612196565b5060005b6004811015611fc25761220e8382600481106121ec576121ec612509565b602002015185836004811061220357612203612509565b60200201519061225a565b84826004811061222057612220612509565b602002015261223b82858360048110611bf657611bf6612509565b84826004811061224d5761224d612509565b60200201526001016121ce565b60007f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018284099392505050565b604051806040016040528061229a61230c565b81526020016122a761232a565b905290565b6040518060c00160405280600081526020016122c66122ee565b81526020016122d361230c565b815260006020820181905260408201526060016122a7612287565b60405180606001604052806003906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b6040518061080001604052806040905b61234261230c565b81526020019060019003908161233a5790505090565b6000806040838503121561236b57600080fd5b50508035926020909101359150565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126123a157600080fd5b813567ffffffffffffffff8111156123bb576123bb61237a565b8060051b604051601f19603f830116810181811067ffffffffffffffff821117156123e8576123e861237a565b60405291825260208185018101929081018684111561240657600080fd5b6020860192505b8383101561242557823581526020928301920161240d565b5095945050505050565b60006020828403121561244157600080fd5b813567ffffffffffffffff81111561245857600080fd5b6100fe84828501612390565b60008060006060848603121561247957600080fd5b833567ffffffffffffffff81111561249057600080fd5b61249c86828701612390565b93505060208401359150604084013580151581146124b957600080fd5b809150509250925092565b6000602082840312156124d657600080fd5b5035919050565b6000806000606084860312156124f257600080fd5b505081359360208301359350604090920135919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b808201808211156100dc576100dc61251f565b818103818111156100dc576100dc61251f565b60008261257857634e487b7160e01b600052601260045260246000fd5b50049056fea2646970667358221220c31b67890858b12d5223c44625869c556bc54cd8915ab35b0468309781fb26d964736f6c634300081b0033",
  "deployedBytecode": "0x6080604052600436106102525760003560e01c806382413eac11610138578063b906a418116100b0578063d547741f11610077578063d547741f146107eb578063e82955881461080b578063f178e47c1461082b578063f2fde38b14610858578063fc7e9c6f14610878578063ff7bd03d1461088e57005b8063b906a4181461073c578063bb0b6a531461075c578063c2b40ae414610789578063ca5eb5e1146107b6578063cd87a3b4146107d657005b806390eeb02b116100ff57806390eeb02b1461066157806391d1485414610693578063a217fddf146106b3578063a38a8a8c146106c8578063a6232a93146106e8578063b42147cd1461070857005b806382413eac146105b457806384746900146105e3578063864eb164146106035780638da5cb5b146106235780638daed5281461064157005b806336568abe116101cb578063715018a611610192578063715018a6146104b957806375c3c0ce146104ce5780637bb10071146105035780637d25a05e146105335780637ecf686d1461056e57806380fc74981461059e57005b806336568abe146104125780635bb93995146104325780635cd233f7146104525780635e280f111461046557806367843a5b1461049957005b806317442b701161021a57806317442b7014610332578063248a9ca31461035457806326120c88146103845780632f2ff15d146103bc5780633400288b146103dc578063353efdcf146103fc57005b806301ffc9a714610254578063063bde24146102895780630ef26743146102cb57806313137d65146102ff57806313425efa14610312575b005b34801561026057600080fd5b5061027461026f366004612bd8565b6108ae565b60405190151581526020015b60405180910390f35b34801561029557600080fd5b506102bd7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000181565b604051908152602001610280565b3480156102d757600080fd5b506102bd7f000000000000000000000000000000000000000000000000000000000000000081565b61025261030d366004612c77565b6108e5565b34801561031e57600080fd5b5061025261032d366004612d71565b6109a5565b34801561033e57600080fd5b5060408051600181526002602082015201610280565b34801561036057600080fd5b506102bd61036f366004612e39565b60009081526008602052604090206001015490565b34801561039057600080fd5b506009546103a4906001600160a01b031681565b6040516001600160a01b039091168152602001610280565b3480156103c857600080fd5b506102526103d7366004612e52565b610da8565b3480156103e857600080fd5b506102526103f7366004612e96565b610dd3565b34801561040857600080fd5b506102bd600d5481565b34801561041e57600080fd5b5061025261042d366004612e52565b610de9565b34801561043e57600080fd5b506102bd61044d366004612ec0565b610e21565b610252610460366004612ee2565b610eba565b34801561047157600080fd5b506103a47f000000000000000000000000000000000000000000000000000000000000000081565b3480156104a557600080fd5b506102526104b4366004612fc8565b6112f4565b3480156104c557600080fd5b506102526116fa565b3480156104da57600080fd5b506104ee6104e936600461310d565b61170e565b60408051928352602083019190915201610280565b34801561050f57600080fd5b5061027461051e36600461319f565b600f6020526000908152604090205460ff1681565b34801561053f57600080fd5b5061055661054e366004612e96565b600092915050565b6040516001600160401b039091168152602001610280565b34801561057a57600080fd5b50610274610589366004612e39565b600e6020526000908152604090205460ff1681565b3480156105aa57600080fd5b506102bd60045481565b3480156105c057600080fd5b506102746105cf3660046131bc565b6001600160a01b0381163014949350505050565b3480156105ef57600080fd5b506102526105fe366004613222565b61178d565b34801561060f57600080fd5b50600b546103a4906001600160a01b031681565b34801561062f57600080fd5b506006546001600160a01b03166103a4565b34801561064d57600080fd5b50600a546103a4906001600160a01b031681565b34801561066d57600080fd5b5060025461067e9063ffffffff1681565b60405163ffffffff9091168152602001610280565b34801561069f57600080fd5b506102746106ae366004612e52565b611ac4565b3480156106bf57600080fd5b506102bd600081565b3480156106d457600080fd5b50600c546103a4906001600160a01b031681565b3480156106f457600080fd5b50610274610703366004612e39565b611aef565b34801561071457600080fd5b506102bd7f124005ad54174bbcb8c2dd053ea318daa80106cdcc518731504b771d6006123f81565b34801561074857600080fd5b506102526107573660046132c5565b611b6e565b34801561076857600080fd5b506102bd6107773660046132f3565b60076020526000908152604090205481565b34801561079557600080fd5b506102bd6107a4366004612e39565b60016020526000908152604090205481565b3480156107c257600080fd5b506102526107d136600461319f565b611ba5565b3480156107e257600080fd5b5061067e606481565b3480156107f757600080fd5b50610252610806366004612e52565b611c2b565b34801561081757600080fd5b506102bd610826366004612e39565b611c50565b34801561083757600080fd5b506102bd610846366004612e39565b60006020819052908152604090205481565b34801561086457600080fd5b5061025261087336600461319f565b611e9a565b34801561088457600080fd5b506102bd60035481565b34801561089a57600080fd5b506102746108a936600461330e565b611ed8565b60006001600160e01b03198216637965db0b60e01b14806108df57506301ffc9a760e01b6001600160e01b03198316145b92915050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163314610935576040516391ac5e4f60e01b81523360048201526024015b60405180910390fd5b6020870180359061094f9061094a908a6132f3565b611f0e565b1461098d5761096160208801886132f3565b60405163309afaf360e21b815263ffffffff90911660048201526020880135602482015260440161092c565b61099c87878787878787611f4a565b50505050505050565b600d546109b181611f9c565b6000896001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109f1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a15919061332a565b905060006001600160a01b038b166323b872dd3330610a3586600a61344a565b8e6001600160401b0316610a499190613459565b6040516001600160e01b031960e086901b1681526001600160a01b03938416600482015292909116602483015260448201526064016020604051808303816000875af1158015610a9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ac19190613470565b905080610b105760405162461bcd60e51b815260206004820152601a60248201527f6661696c656420746f207472616e73666572206465706f736974000000000000604482015260640161092c565b600954604051633a94343960e21b81526000916001600160a01b03169063ea50d0e490610b47908d908d908d908d906004016134b6565b602060405180830381865afa158015610b64573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b889190613470565b905080610bd05760405162461bcd60e51b8152602060048201526016602482015275496e76616c6964206465706f7369742070726f6f662160501b604482015260640161092c565b87876001818110610be357610be3613502565b9050602002013560001c6001600160a01b03168c6001600160a01b031614610c465760405162461bcd60e51b815260206004820152601660248201527508aa486646040c2c8c8e4cae6e640dad2e6dac2e8c6d60531b604482015260640161092c565b87876002818110610c5957610c59613502565b9050602002013560001c6001600160401b03168b6001600160401b031614610cc35760405162461bcd60e51b815260206004820152601860248201527f4164647265737320616d6f756e7420696e636f72726563740000000000000000604482015260640161092c565b610ce888886000818110610cd957610cd9613502565b9050602002013560001c611fa6565b5060005b600381108015610cfb57508581105b15610d9957868682818110610d1257610d12613502565b9050602002810190610d249190613518565b159050610d87577f1350ba861189904691f5a79791c8b0eb3c5ea51a8954ae413a167e05c66ca1e0878783818110610d5e57610d5e613502565b9050602002810190610d709190613518565b604051610d7e92919061355e565b60405180910390a15b80610d918161357a565b915050610cec565b50505050505050505050505050565b600082815260086020526040902060010154610dc381611f9c565b610dcd8383612196565b50505050565b610ddb61222a565b610de58282612257565b5050565b6001600160a01b0381163314610e125760405163334bd91960e11b815260040160405180910390fd5b610e1c82826122ac565b505050565b600554600090610eb3906001600160a01b031663055d8d54610e4286612319565b610e4b86612319565b6040516001600160e01b031960e085901b16815260048101929092526024820152604401602060405180830381865afa158015610e8c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb09190613593565b90565b9392505050565b610edf86866000818110610ed057610ed0613502565b9050602002013560001c611aef565b610efb5760405162461bcd60e51b815260040161092c906135ac565b600c54604051633a94343960e21b81526000916001600160a01b03169063ea50d0e490610f32908c908c908c908c906004016134b6565b602060405180830381865afa158015610f4f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f739190613470565b905080610fb75760405162461bcd60e51b815260206004820152601260248201527124b73b30b634b2103bb0b93810383937b7b360711b604482015260640161092c565b60075b600981101561106e576000888883818110610fd757610fd7613502565b9050602002013514611066576000888883818110610ff757610ff7613502565b6001600160a01b03602091820293909301359283166000908152600f90915260409020549192505060ff166110645760405162461bcd60e51b8152602060048201526013602482015272139bdd0818481cdd5c1c1bdc9d19590813d195606a1b604482015260640161092c565b505b600101610fba565b5060015b6003811161118957600088888381811061108e5761108e613502565b905060200201351461117757600e60008989848181106110b0576110b0613502565b602090810292909201358352508101919091526040016000205460ff16156110ea5760405162461bcd60e51b815260040161092c906135d3565b6001600e60008a8a8581811061110257611102613502565b90506020020135815260200190815260200160002060006101000a81548160ff02191690831515021790555087878281811061114057611140613502565b9050602002013560001c7f49dad0e89c31a259d3e177fa5c4bb23dfb7bfbc2afce873328262a97dd39277860405160405180910390a25b806111818161357a565b915050611072565b5060006111968888612323565b90506000816040516020016111ab919061360a565b60408051601f198184030181526020601f8a01819004810284018101909252888352925061120f918e918491908b908b90819084018382808284376000920182905250604080518082019091523481526020810191909152925030915061246a9050565b5063ffffffff8c166000908152600760205260409020546112348d828c8c8c8c612575565b60005b60038110801561124657508581105b156112e45786868281811061125d5761125d613502565b905060200281019061126f9190613518565b1590506112d2577f1350ba861189904691f5a79791c8b0eb3c5ea51a8954ae413a167e05c66ca1e08787838181106112a9576112a9613502565b90506020028101906112bb9190613518565b6040516112c992919061355e565b60405180910390a15b806112dc8161357a565b915050611237565b5050505050505050505050505050565b61130a82826000818110610ed057610ed0613502565b6113265760405162461bcd60e51b815260040161092c906135ac565b600b54604051633a94343960e21b81526000916001600160a01b03169063ea50d0e49061135d9088908890889088906004016134b6565b602060405180830381865afa15801561137a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061139e9190613470565b9050806113e65760405162461bcd60e51b815260206004820152601660248201527524b73b30b634b2103bb4ba34323930bb90383937b7b360511b604482015260640161092c565b60015b6003811161150057600084848381811061140557611405613502565b90506020020135146114ee57600e600085858481811061142757611427613502565b602090810292909201358352508101919091526040016000205460ff16156114615760405162461bcd60e51b815260040161092c906135d3565b6001600e600086868581811061147957611479613502565b90506020020135815260200190815260200160002060006101000a81548160ff0219169083151502179055508383828181106114b7576114b7613502565b9050602002013560001c7f49dad0e89c31a259d3e177fa5c4bb23dfb7bfbc2afce873328262a97dd39277860405160405180910390a25b806114f88161357a565b9150506113e9565b5060005b60038110156116f257600061151a82600461364d565b9050600061152983600761364d565b9050600061153884600a61364d565b9050600087878581811061154e5761154e613502565b9050602002013560001c9050600088888581811061156e5761156e613502565b9050602002013560001c9050600089898581811061158e5761158e613502565b602002919091013591505081156116e0576000836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156115df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611603919061332a565b9050600061161282600a61344a565b61161c9085613459565b60405163a9059cbb60e01b81526001600160a01b0385811660048301526024820183905291925060009187169063a9059cbb906044016020604051808303816000875af1158015611671573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116959190613470565b9050806116dc5760405162461bcd60e51b8152602060048201526015602482015274151bdad95b881d1c985b9cd9995c8819985a5b1959605a1b604482015260640161092c565b5050505b50506001909401935061150492505050565b505050505050565b61170261222a565b61170c60006125eb565b565b600080600086604051602001611724919061360a565b60408051601f198184030181526020601f89018190048102840181019092528783529250600091611775918b9185918b908b90819084018382808284376000920191909152508b925061263d915050565b8051602090910151909a909950975050505050505050565b6117a384846000818110610ed057610ed0613502565b6117bf5760405162461bcd60e51b815260040161092c906135ac565b600a54604051633a94343960e21b81526000916001600160a01b03169063ea50d0e4906117f6908a908a908a908a906004016134b6565b602060405180830381865afa158015611813573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118379190613470565b90508061187f5760405162461bcd60e51b815260206004820152601660248201527524b73b30b634b2103a3930b739b332b910383937b7b360511b604482015260640161092c565b60015b61188e6003600161364d565b81101561199a5760008686838181106118a9576118a9613502565b905060200201351461199257600e60008787848181106118cb576118cb613502565b602090810292909201358352508101919091526040016000205460ff16156119055760405162461bcd60e51b815260040161092c906135d3565b6001600e600088888581811061191d5761191d613502565b90506020020135815260200190815260200160002060006101000a81548160ff02191690831515021790555085858281811061195b5761195b613502565b9050602002013560001c7f49dad0e89c31a259d3e177fa5c4bb23dfb7bfbc2afce873328262a97dd39277860405160405180910390a25b600101611882565b5060006119a96003600161364d565b90505b60036119b981600161364d565b6119c3919061364d565b811015611a095760008686838181106119de576119de613502565b9050602002013514611a01576119ff868683818110610cd957610cd9613502565b505b6001016119ac565b5060005b600381108015611a1c57508281105b15611aba57838382818110611a3357611a33613502565b9050602002810190611a459190613518565b159050611aa8577f1350ba861189904691f5a79791c8b0eb3c5ea51a8954ae413a167e05c66ca1e0848483818110611a7f57611a7f613502565b9050602002810190611a919190613518565b604051611a9f92919061355e565b60405180910390a15b80611ab28161357a565b915050611a0d565b5050505050505050565b60009182526008602090815260408084206001600160a01b0393909316845291905290205460ff1690565b600081600003611b0157506000919050565b60025463ffffffff16805b63ffffffff81166000908152600160205260409020548403611b32575060019392505050565b8063ffffffff16600003611b44575060645b80611b4e81613660565b9150508163ffffffff168163ffffffff1603611b0c575060009392505050565b6000611b7981611f9c565b506001600160a01b03919091166000908152600f60205260409020805460ff1916911515919091179055565b611bad61222a565b60405163ca5eb5e160e01b81526001600160a01b0382811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063ca5eb5e190602401600060405180830381600087803b158015611c1057600080fd5b505af1158015611c24573d6000803e3d6000fd5b5050505050565b600082815260086020526040902060010154611c4681611f9c565b610dcd83836122ac565b600081600003611c8157507f1e2856f9f722631c878a92dc1d84283d04b76df3e1831492bdf7098c1e65e478919050565b81600103611cb057507f2c2eecb1b14035bfd9765e84195684b401a84fdb58c3c03f1bcea86dcf0c8105919050565b81600203611cdf57507f237e412a71db31e5769f63d92346a09dd0f30b9c335e9d9aa96b6625eb537445919050565b81600303611d0e57507f0b3ff120d61a7de2da3d80ff99d393796805c74be5c39e8a4c7436d1c65dad4c919050565b81600403611d3d57507f0fc58e21665302678bef68714d9e5889583071f7bd3cf018b64fafc51b0a9cf3919050565b81600503611d6c57507f235df7c585524ed8a26aea20a0fb168038f10df71d84720c9a8c1b3e78e3b6cd919050565b81600603611d9b57507f1c6cabee394ea24dc09eab1788f7f62b367e95789f883e33690d94215d819264919050565b81600703611dca57507f09bec327ab2c8dda5d2d435cd267cb21e71f21371a01739885817eb1625d8976919050565b81600803611df957507f2d35519ad7061578be50cbbfe040327843f6b4cdf1458e01b5f9737dbaf82b18919050565b81600903611e2857507f0f86c9e9c9e689394a4944bb87291a3f55cc930b21432fccf41b8267f1a98d6f919050565b81600a03611e5757507f181c9ba70900093b180c96f55cc2b1d73d60b8ab613344cbba83b33cbcc94e2b919050565b60405162461bcd60e51b8152602060048201526013602482015272496e646578206f7574206f6620626f756e647360681b604482015260640161092c565b919050565b611ea261222a565b6001600160a01b038116611ecc57604051631e4fbdf760e01b81526000600482015260240161092c565b611ed5816125eb565b50565b6000602082018035906007908390611ef090866132f3565b63ffffffff1681526020810191909152604001600020541492915050565b63ffffffff8116600090815260076020526040812054806108df5760405163f6ff4fb760e01b815263ffffffff8416600482015260240161092c565b6000611f5885870187613680565b905060005b8151811015611f9157611f88828281518110611f7b57611f7b613502565b6020026020010151611fa6565b50600101611f5d565b505050505050505050565b611ed5813361271e565b600354600454600091908103611fea5760405162461bcd60e51b8152602060048201526009602482015268151c995948119d5b1b60ba1b604482015260640161092c565b6000818152602081905260408120849055819084905b61202b60017f00000000000000000000000000000000000000000000000000000000000000006136b4565b8110156120fd57600061203f6002856136dd565b159050600081612059576120546001866136b4565b612064565b61206485600161364d565b602084811b8217600081815291829052604082205492935091908190036120915761208e85611c50565b90505b83156120a8576120a18682610e21565b95506120b5565b6120b28187610e21565b95505b6120c06002886136f1565b9650856000806120dc6120d489600161364d565b60201b8b1790565b81526020810191909152604001600020555050600190920191506120009050565b506002546000906064906121189063ffffffff166001613705565b6121229190613721565b6002805463ffffffff191663ffffffff8316908117909155600090815260016020819052604090912084905590915061215c90859061364d565b600355604051869085907f604f5a492f8c1622a2e239876074a13b33ec11384fe2b310339ece35e8eecac790600090a35091949350505050565b60006121a28383611ac4565b6122225760008381526008602090815260408083206001600160a01b03861684529091529020805460ff191660011790556121da3390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45060016108df565b5060006108df565b6006546001600160a01b0316331461170c5760405163118cdaa760e01b815233600482015260240161092c565b63ffffffff8216600081815260076020908152604091829020849055815192835282018390527f238399d427b947898edb290f5ff0f9109849b1c3ba196a42e35f00c50a54b98b910160405180910390a15050565b60006122b88383611ac4565b156122225760008381526008602090815260408083206001600160a01b0386168085529252808320805460ff1916905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45060016108df565b80611e9581612757565b6040805160038082526080820190925260609160009190602082018480368337019050509050600060045b600681116123cf57600086868381811061236a5761236a613502565b90506020020135146123bd5785858281811061238857612388613502565b9050602002013560001c8383815181106123a4576123a4613502565b6020908102919091010152816123b98161357a565b9250505b806123c78161357a565b91505061234e565b506000816001600160401b038111156123ea576123ea613037565b604051908082528060200260200182016040528015612413578160200160208202803683370190505b50905060005b828110156124605783818151811061243357612433613502565b602002602001015182828151811061244d5761244d613502565b6020908102919091010152600101612419565b5095945050505050565b612472612b91565b600061248184600001516127c6565b60208501519091501561249b5761249b84602001516127ee565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316632637a450826040518060a001604052808b63ffffffff1681526020016124eb8c611f0e565b81526020018a815260200189815260200160008960200151111515815250866040518463ffffffff1660e01b815260040161252792919061378f565b60806040518083038185885af1158015612545573d6000803e3d6000fd5b50505050506040513d601f19601f8201168201806040525081019061256a91906138c2565b979650505050505050565b60075b600a81101561099c57600085858381811061259557612595613502565b60200291909101359150506001600160a01b038116156125e2576125e288888389896125c288600361364d565b8181106125d1576125d1613502565b9050602002013560001c88886128d0565b50600101612578565b600680546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b60408051808201909152600080825260208201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ddc28c586040518060a001604052808863ffffffff1681526020016126a089611f0e565b8152602001878152602001868152602001851515815250306040518363ffffffff1660e01b81526004016126d592919061378f565b6040805180830381865afa1580156126f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061271591906138de565b95945050505050565b6127288282611ac4565b610de55760405163e2517d3f60e01b81526001600160a01b03821660048201526024810183905260440161092c565b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f00000018110611ed55760405162461bcd60e51b815260206004820152601960248201527f4669656c643a20696e70757420697320746f6f206c6172676500000000000000604482015260640161092c565b60008134146127ea576040516304fb820960e51b815234600482015260240161092c565b5090565b60007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e4fe1d946040518163ffffffff1660e01b8152600401602060405180830381865afa15801561284e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061287291906138fa565b90506001600160a01b03811661289b576040516329b99a9560e11b815260040160405180910390fd5b610de56001600160a01b038216337f000000000000000000000000000000000000000000000000000000000000000085612acb565b6000846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015612910573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612934919061332a565b61293f90600a61344a565b6129499085613459565b905060006040518060e001604052808963ffffffff16815260200188815260200183815260200183815260200185858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525093855250506040805160208181018352848252808601919091528151908101825283815293810193909352509051633b6f743b60e01b8152919250906001600160a01b03881690633b6f743b90612a05908590859060040161398d565b6040805180830381865afa158015612a21573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a4591906138de565b805160405163c7c7f5b360e01b81529192506001600160a01b0389169163c7c7f5b39190612a7b908690869033906004016139b1565b60c06040518083038185885af1158015612a99573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190612abe91906139f0565b5050505050505050505050565b604080516001600160a01b038581166024830152841660448201526064808201849052825180830390910181526084909101909152602080820180516001600160e01b03166323b872dd60e01b1781528251610dcd938893909260009283929183919082885af180612b43576040513d6000823e3d81fd5b50506000513d91508115612b5b578060011415612b68565b6001600160a01b0384163b155b15610dcd57604051635274afe760e01b81526001600160a01b038516600482015260240161092c565b60405180606001604052806000801916815260200160006001600160401b03168152602001612bd3604051806040016040528060008152602001600081525090565b905290565b600060208284031215612bea57600080fd5b81356001600160e01b031981168114610eb357600080fd5b600060608284031215612c1457600080fd5b50919050565b60008083601f840112612c2c57600080fd5b5081356001600160401b03811115612c4357600080fd5b602083019150836020828501011115612c5b57600080fd5b9250929050565b6001600160a01b0381168114611ed557600080fd5b600080600080600080600060e0888a031215612c9257600080fd5b612c9c8989612c02565b96506060880135955060808801356001600160401b03811115612cbe57600080fd5b612cca8a828b01612c1a565b90965094505060a0880135612cde81612c62565b925060c08801356001600160401b03811115612cf957600080fd5b612d058a828b01612c1a565b989b979a50959850939692959293505050565b6001600160401b0381168114611ed557600080fd5b60008083601f840112612d3f57600080fd5b5081356001600160401b03811115612d5657600080fd5b6020830191508360208260051b8501011115612c5b57600080fd5b60008060008060008060008060a0898b031215612d8d57600080fd5b8835612d9881612c62565b97506020890135612da881612d18565b965060408901356001600160401b03811115612dc357600080fd5b612dcf8b828c01612c1a565b90975095505060608901356001600160401b03811115612dee57600080fd5b612dfa8b828c01612d2d565b90955093505060808901356001600160401b03811115612e1957600080fd5b612e258b828c01612d2d565b999c989b5096995094979396929594505050565b600060208284031215612e4b57600080fd5b5035919050565b60008060408385031215612e6557600080fd5b823591506020830135612e7781612c62565b809150509250929050565b803563ffffffff81168114611e9557600080fd5b60008060408385031215612ea957600080fd5b612eb283612e82565b946020939093013593505050565b60008060408385031215612ed357600080fd5b50508035926020909101359150565b600080600080600080600080600060a08a8c031215612f0057600080fd5b612f098a612e82565b985060208a01356001600160401b03811115612f2457600080fd5b612f308c828d01612c1a565b90995097505060408a01356001600160401b03811115612f4f57600080fd5b612f5b8c828d01612d2d565b90975095505060608a01356001600160401b03811115612f7a57600080fd5b612f868c828d01612c1a565b90955093505060808a01356001600160401b03811115612fa557600080fd5b612fb18c828d01612d2d565b915080935050809150509295985092959850929598565b60008060008060408587031215612fde57600080fd5b84356001600160401b03811115612ff457600080fd5b61300087828801612c1a565b90955093505060208501356001600160401b0381111561301f57600080fd5b61302b87828801612d2d565b95989497509550505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b038111828210171561307557613075613037565b604052919050565b600082601f83011261308e57600080fd5b81356001600160401b038111156130a7576130a7613037565b8060051b6130b76020820161304d565b918252602081850181019290810190868411156130d357600080fd5b6020860192505b838310156130f55782358252602092830192909101906130da565b9695505050505050565b8015158114611ed557600080fd5b60008060008060006080868803121561312557600080fd5b61312e86612e82565b945060208601356001600160401b0381111561314957600080fd5b6131558882890161307d565b94505060408601356001600160401b0381111561317157600080fd5b61317d88828901612c1a565b9094509250506060860135613191816130ff565b809150509295509295909350565b6000602082840312156131b157600080fd5b8135610eb381612c62565b60008060008060a085870312156131d257600080fd5b6131dc8686612c02565b935060608501356001600160401b038111156131f757600080fd5b61320387828801612c1a565b909450925050608085013561321781612c62565b939692955090935050565b6000806000806000806060878903121561323b57600080fd5b86356001600160401b0381111561325157600080fd5b61325d89828a01612c1a565b90975095505060208701356001600160401b0381111561327c57600080fd5b61328889828a01612d2d565b90955093505060408701356001600160401b038111156132a757600080fd5b6132b389828a01612d2d565b979a9699509497509295939492505050565b600080604083850312156132d857600080fd5b82356132e381612c62565b91506020830135612e77816130ff565b60006020828403121561330557600080fd5b610eb382612e82565b60006060828403121561332057600080fd5b610eb38383612c02565b60006020828403121561333c57600080fd5b815160ff81168114610eb357600080fd5b634e487b7160e01b600052601160045260246000fd5b6001815b600184111561339e578085048111156133825761338261334d565b600184161561339057908102905b60019390931c928002613367565b935093915050565b6000826133b5575060016108df565b816133c2575060006108df565b81600181146133d857600281146133e2576133fe565b60019150506108df565b60ff8411156133f3576133f361334d565b50506001821b6108df565b5060208310610133831016604e8410600b8410161715613421575081810a6108df565b61342e6000198484613363565b80600019048211156134425761344261334d565b029392505050565b6000610eb360ff8416836133a6565b80820281158282048414176108df576108df61334d565b60006020828403121561348257600080fd5b8151610eb3816130ff565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6040815260006134ca60408301868861348d565b82810360208401528381526001600160fb1b038411156134e957600080fd5b8360051b80866020840137016020019695505050505050565b634e487b7160e01b600052603260045260246000fd5b6000808335601e1984360301811261352f57600080fd5b8301803591506001600160401b0382111561354957600080fd5b602001915036819003821315612c5b57600080fd5b60208152600061357260208301848661348d565b949350505050565b60006001820161358c5761358c61334d565b5060010190565b6000602082840312156135a557600080fd5b5051919050565b6020808252600d908201526c496e76616c696420526f6f742160981b604082015260600190565b60208082526017908201527f4e756c6c696669657220616c7265616479207370656e74000000000000000000604082015260600190565b602080825282518282018190526000918401906040840190835b81811015613642578351835260209384019390920191600101613624565b509095945050505050565b808201808211156108df576108df61334d565b600063ffffffff8216806136765761367661334d565b6000190192915050565b60006020828403121561369257600080fd5b81356001600160401b038111156136a857600080fd5b6135728482850161307d565b818103818111156108df576108df61334d565b634e487b7160e01b600052601260045260246000fd5b6000826136ec576136ec6136c7565b500690565b600082613700576137006136c7565b500490565b63ffffffff81811683821601908111156108df576108df61334d565b600063ffffffff831680613737576137376136c7565b8063ffffffff84160691505092915050565b6000815180845260005b8181101561376f57602081850181015186830182015201613753565b506000602082860101526020601f19601f83011685010191505092915050565b6040815263ffffffff8351166040820152602083015160608201526000604084015160a060808401526137c560e0840182613749565b90506060850151603f198483030160a08501526137e28282613749565b60809690960151151560c08501525050506001600160a01b039190911660209091015290565b60006040828403121561381a57600080fd5b604080519081016001600160401b038111828210171561383c5761383c613037565b604052825181526020928301519281019290925250919050565b60006080828403121561386857600080fd5b604051606081016001600160401b038111828210171561388a5761388a613037565b80604052508091508251815260208301516138a481612d18565b60208201526138b68460408501613808565b60408201525092915050565b6000608082840312156138d457600080fd5b610eb38383613856565b6000604082840312156138f057600080fd5b610eb38383613808565b60006020828403121561390c57600080fd5b8151610eb381612c62565b63ffffffff81511682526020810151602083015260408101516040830152606081015160608301526000608082015160e0608085015261395a60e0850182613749565b905060a083015184820360a08601526139738282613749565b91505060c083015184820360c08601526127158282613749565b6040815260006139a06040830185613917565b905082151560208301529392505050565b6080815260006139c46080830186613917565b8451602084810191909152909401516040830152506001600160a01b0391909116606090910152919050565b60008060c08385031215613a0357600080fd5b613a0d8484613856565b9150613a1c8460808501613808565b9050925092905056fea2646970667358221220c62b9a4ea0930f4e831270dc953dc2846a48cad862ce4efd41014f2dbb4f452464736f6c634300081b0033",
  "devdoc": {
    "errors": {
      "AccessControlBadConfirmation()": [
        {
          "details": "The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."
        }
      ],
      "AccessControlUnauthorizedAccount(address,bytes32)": [
        {
          "details": "The `account` is missing a role."
        }
      ],
      "OwnableInvalidOwner(address)": [
        {
          "details": "The owner is not a valid owner account. (eg. `address(0)`)"
        }
      ],
      "OwnableUnauthorizedAccount(address)": [
        {
          "details": "The caller account is not authorized to perform an operation."
        }
      ],
      "SafeERC20FailedOperation(address)": [
        {
          "details": "An operation with an ERC-20 token failed."
        }
      ]
    },
    "events": {
      "RoleAdminChanged(bytes32,bytes32,bytes32)": {
        "details": "Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted to signal this."
      },
      "RoleGranted(bytes32,address,address)": {
        "details": "Emitted when `account` is granted `role`. `sender` is the account that originated the contract call. This account bears the admin role (for the granted role). Expected in cases where the role was granted using the internal {AccessControl-_grantRole}."
      },
      "RoleRevoked(bytes32,address,address)": {
        "details": "Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"
      }
    },
    "kind": "dev",
    "methods": {
      "allowInitializePath((uint32,bytes32,uint64))": {
        "details": "This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.This defaults to assuming if a peer has been set, its initialized. Can be overridden by the OApp if there is other logic to determine this.",
        "params": {
          "origin": "The origin information containing the source endpoint and sender address."
        },
        "returns": {
          "_0": "Whether the path has been initialized."
        }
      },
      "getRoleAdmin(bytes32)": {
        "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
      },
      "grantRole(bytes32,address)": {
        "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."
      },
      "hasRole(bytes32,address)": {
        "details": "Returns `true` if `account` has been granted `role`."
      },
      "isComposeMsgSender((uint32,bytes32,uint64),bytes,address)": {
        "details": "_origin The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message._message The lzReceive payload.Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.The default sender IS the OAppReceiver implementer.",
        "params": {
          "_sender": "The sender address."
        },
        "returns": {
          "_0": "isSender Is a valid sender."
        }
      },
      "lzReceive((uint32,bytes32,uint64),bytes32,bytes,address,bytes)": {
        "details": "Entry point for receiving messages or packets from the endpoint.Entry point for receiving msg/packet from the LayerZero endpoint.",
        "params": {
          "_executor": "The address of the executor for the received message.",
          "_extraData": "Additional arbitrary data provided by the corresponding executor.",
          "_guid": "The unique identifier for the received LayerZero message.",
          "_message": "The payload of the received message.",
          "_origin": "The origin information containing the source endpoint and sender address.  - srcEid: The source chain endpoint ID.  - sender: The sender address on the src chain.  - nonce: The nonce of the message."
        }
      },
      "nextNonce(uint32,bytes32)": {
        "details": "_srcEid The source endpoint ID._sender The sender address.The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.Is required by the off-chain executor to determine the OApp expects msg execution is ordered.This is also enforced by the OApp.By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.",
        "returns": {
          "nonce": "The next nonce."
        }
      },
      "oAppVersion()": {
        "returns": {
          "receiverVersion": "The version of the OAppReceiver.sol implementation.",
          "senderVersion": "The version of the OAppSender.sol implementation."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "renounceRole(bytes32,address)": {
        "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."
      },
      "revokeRole(bytes32,address)": {
        "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."
      },
      "setDelegate(address)": {
        "details": "Only the owner/admin of the OApp can call this function.Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.",
        "params": {
          "_delegate": "The address of the delegate to be set."
        }
      },
      "setPeer(uint32,bytes32)": {
        "details": "Only the owner/admin of the OApp can call this function.Indicates that the peer is trusted to send LayerZero messages to this OApp.Set this to bytes32(0) to remove the peer address.Peer is a bytes32 to accommodate non-evm chains.",
        "params": {
          "_eid": "The endpoint ID.",
          "_peer": "The address of the peer to be associated with the corresponding endpoint."
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "allowInitializePath((uint32,bytes32,uint64))": {
        "notice": "Checks if the path initialization is allowed based on the provided origin."
      },
      "endpoint()": {
        "notice": "Retrieves the LayerZero endpoint associated with the OApp."
      },
      "isComposeMsgSender((uint32,bytes32,uint64),bytes,address)": {
        "notice": "Indicates whether an address is an approved composeMsg sender to the Endpoint."
      },
      "nextNonce(uint32,bytes32)": {
        "notice": "Retrieves the next nonce for a given source endpoint and sender address."
      },
      "oAppVersion()": {
        "notice": "Retrieves the OApp version information."
      },
      "peers(uint32)": {
        "notice": "Retrieves the peer (OApp) associated with a corresponding endpoint."
      },
      "setDelegate(address)": {
        "notice": "Sets the delegate address for the OApp."
      },
      "setPeer(uint32,bytes32)": {
        "notice": "Sets the peer address (OApp instance) for a corresponding endpoint."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11736,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "filledSubtrees",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 11740,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "roots",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 11748,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "currentRootIndex",
        "offset": 0,
        "slot": "2",
        "type": "t_uint32"
      },
      {
        "astId": 11751,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "nextIndex",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 11753,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "MAX_LEAF_INDEX",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 11756,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "poseidon2Hasher",
        "offset": 0,
        "slot": "5",
        "type": "t_contract(Poseidon2)16474"
      },
      {
        "astId": 8302,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "_owner",
        "offset": 0,
        "slot": "6",
        "type": "t_address"
      },
      {
        "astId": 5208,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "peers",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_uint32,t_bytes32)"
      },
      {
        "astId": 7941,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "_roles",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_bytes32,t_struct(RoleData)7936_storage)"
      },
      {
        "astId": 12218,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "depositVerifier",
        "offset": 0,
        "slot": "9",
        "type": "t_contract(DepositVerifier)27755"
      },
      {
        "astId": 12221,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "transferVerifier",
        "offset": 0,
        "slot": "10",
        "type": "t_contract(TransferVerifier)36194"
      },
      {
        "astId": 12224,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "withdrawVerifier",
        "offset": 0,
        "slot": "11",
        "type": "t_contract(WithdrawVerifier)53072"
      },
      {
        "astId": 12227,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "warpVerifier",
        "offset": 0,
        "slot": "12",
        "type": "t_contract(WarpVerifier)44633"
      },
      {
        "astId": 12232,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "DEPOSIT_ROLE",
        "offset": 0,
        "slot": "13",
        "type": "t_bytes32"
      },
      {
        "astId": 12236,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "nullifierUsed",
        "offset": 0,
        "slot": "14",
        "type": "t_mapping(t_bytes32,t_bool)"
      },
      {
        "astId": 12240,
        "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
        "label": "availableOFTs",
        "offset": 0,
        "slot": "15",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(DepositVerifier)27755": {
        "encoding": "inplace",
        "label": "contract DepositVerifier",
        "numberOfBytes": "20"
      },
      "t_contract(Poseidon2)16474": {
        "encoding": "inplace",
        "label": "contract Poseidon2",
        "numberOfBytes": "20"
      },
      "t_contract(TransferVerifier)36194": {
        "encoding": "inplace",
        "label": "contract TransferVerifier",
        "numberOfBytes": "20"
      },
      "t_contract(WarpVerifier)44633": {
        "encoding": "inplace",
        "label": "contract WarpVerifier",
        "numberOfBytes": "20"
      },
      "t_contract(WithdrawVerifier)53072": {
        "encoding": "inplace",
        "label": "contract WithdrawVerifier",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_struct(RoleData)7936_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct AccessControl.RoleData)",
        "numberOfBytes": "32",
        "value": "t_struct(RoleData)7936_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_struct(RoleData)7936_storage": {
        "encoding": "inplace",
        "label": "struct AccessControl.RoleData",
        "members": [
          {
            "astId": 7933,
            "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
            "label": "hasRole",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 7935,
            "contract": "contracts/PrivateStargateFinance.sol:PrivateStargateFinance",
            "label": "adminRole",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}